/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <zap-generated/CHIPClientCallbacks.h>
#include <zap-generated/CHIPClusters.h>

#include <controller/java/CHIPJNIError.h>
#include <controller/java/JniReferences.h>
#include <controller/java/JniTypeWrappers.h>
#include <controller/java/StackLock.h>
#include <jni.h>
#include <lib/core/CHIPSafeCasts.h>
#include <lib/support/CodeUtils.h>
#include <lib/support/Span.h>

#define JNI_METHOD(RETURN, CLASS_NAME, METHOD_NAME)                                                                                \
    extern "C" JNIEXPORT RETURN JNICALL Java_chip_devicecontroller_ChipClusters_00024##CLASS_NAME##_##METHOD_NAME

using namespace chip;
using namespace chip::Controller;

static CHIP_ERROR CreateChipClusterException(JNIEnv * env, jint errorCode, jthrowable & outEx);
static CHIP_ERROR CreateIllegalStateException(JNIEnv * env, const char message[], jint errorCode, jthrowable & outEx);
static void ReturnIllegalStateException(JNIEnv * env, jobject callback, const char message[], jint errorCode);

CHIP_ERROR CreateChipClusterException(JNIEnv * env, jint errorCode, jthrowable & outEx)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    jmethodID exceptionConstructor;
    jclass clusterExceptionCls;

    err = JniReferences::GetInstance().GetClassRef(env, "chip/devicecontroller/ChipClusterException", clusterExceptionCls);
    VerifyOrReturnError(err == CHIP_NO_ERROR, CHIP_JNI_ERROR_TYPE_NOT_FOUND);
    JniClass clusterExceptionJniCls(clusterExceptionCls);

    exceptionConstructor = env->GetMethodID(clusterExceptionCls, "<init>", "(I)V");
    VerifyOrReturnError(exceptionConstructor != nullptr, CHIP_JNI_ERROR_TYPE_NOT_FOUND);

    outEx = (jthrowable) env->NewObject(clusterExceptionCls, exceptionConstructor, errorCode);
    VerifyOrReturnError(outEx != nullptr, CHIP_JNI_ERROR_TYPE_NOT_FOUND);

    return err;
}

CHIP_ERROR CreateIllegalStateException(JNIEnv * env, const char message[], jint errorCode, jthrowable & outEx)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    jmethodID exceptionConstructor;
    jclass exceptionClass;
    jstring errStr;

    err = JniReferences::GetInstance().GetClassRef(env, "java/lang/IllegalStateException", exceptionClass);
    VerifyOrReturnError(err == CHIP_NO_ERROR, CHIP_JNI_ERROR_TYPE_NOT_FOUND);
    JniClass exceptionJniClass(exceptionClass);

    exceptionConstructor = env->GetMethodID(exceptionClass, "<init>", "(Ljava/lang/String;)V");
    VerifyOrReturnError(exceptionConstructor != nullptr, CHIP_JNI_ERROR_TYPE_NOT_FOUND);

    char buf[CHIP_CONFIG_LOG_MESSAGE_MAX_SIZE];
    snprintf(buf, sizeof(buf), "%s: %d", message, errorCode);
    errStr = env->NewStringUTF(buf);

    outEx = (jthrowable) env->NewObject(exceptionClass, exceptionConstructor, errStr);
    VerifyOrReturnError(outEx != nullptr, CHIP_JNI_ERROR_TYPE_NOT_FOUND);

    return err;
}

void ReturnIllegalStateException(JNIEnv * env, jobject callback, const char message[], jint errorCode)
{
    VerifyOrReturn(callback == nullptr, ChipLogDetail(Zcl, "Callback is null in ReturnIllegalStateException(), exiting early"));

    CHIP_ERROR err = CHIP_NO_ERROR;
    jmethodID method;
    err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
    if (err != CHIP_NO_ERROR)
    {
        ChipLogError(Zcl, "Error throwing IllegalStateException %d", errorCode);
        return;
    }

    jthrowable exception;
    err = CreateIllegalStateException(env, message, errorCode, exception);
    if (err != CHIP_NO_ERROR)
    {
        ChipLogError(Zcl, "Error throwing IllegalStateException %d", errorCode);
        return;
    }
    env->CallVoidMethod(callback, method, exception);
}

class CHIPDefaultSuccessCallback : public Callback::Callback<DefaultSuccessCallback>
{
public:
    CHIPDefaultSuccessCallback(jobject javaCallback) : Callback::Callback<DefaultSuccessCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    ~CHIPDefaultSuccessCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        jmethodID javaMethod;
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        CHIPDefaultSuccessCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDefaultSuccessCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDefaultFailureCallback : public Callback::Callback<DefaultFailureCallback>
{
public:
    CHIPDefaultFailureCallback(jobject javaCallback) : Callback::Callback<DefaultFailureCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    ~CHIPDefaultFailureCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        jmethodID javaMethod;
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jthrowable exception;
        CHIPDefaultFailureCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDefaultFailureCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onError", "(Ljava/lang/Exception;)V", &javaMethod);
        SuccessOrExit(err);

        err = CreateChipClusterException(env, status, exception);
        SuccessOrExit(err);

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, exception);
    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPBooleanAttributeCallback : public Callback::Callback<BooleanAttributeCallback>
{
public:
    CHIPBooleanAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<BooleanAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPBooleanAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, bool value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPBooleanAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPBooleanAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Z)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jboolean>(value));
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPCharStringAttributeCallback : public Callback::Callback<CharStringAttributeCallback>
{
public:
    CHIPCharStringAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<CharStringAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPCharStringAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, const chip::ByteSpan value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPCharStringAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPCharStringAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));

        UtfString valueStr(env, value);
        env->CallVoidMethod(javaCallbackRef, javaMethod, valueStr.jniValue());
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPInt8sAttributeCallback : public Callback::Callback<Int8sAttributeCallback>
{
public:
    CHIPInt8sAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<Int8sAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPInt8sAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, int8_t value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPInt8sAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPInt8sAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(value));
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPInt8uAttributeCallback : public Callback::Callback<Int8uAttributeCallback>
{
public:
    CHIPInt8uAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<Int8uAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPInt8uAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, uint8_t value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPInt8uAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPInt8uAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(value));
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPInt16sAttributeCallback : public Callback::Callback<Int16sAttributeCallback>
{
public:
    CHIPInt16sAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<Int16sAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPInt16sAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, int16_t value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPInt16sAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPInt16sAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(value));
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPInt16uAttributeCallback : public Callback::Callback<Int16uAttributeCallback>
{
public:
    CHIPInt16uAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<Int16uAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPInt16uAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, uint16_t value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPInt16uAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPInt16uAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(value));
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPInt32sAttributeCallback : public Callback::Callback<Int32sAttributeCallback>
{
public:
    CHIPInt32sAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<Int32sAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPInt32sAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, int32_t value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPInt32sAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPInt32sAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(J)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jlong>(value));
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPInt32uAttributeCallback : public Callback::Callback<Int32uAttributeCallback>
{
public:
    CHIPInt32uAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<Int32uAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPInt32uAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, uint32_t value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPInt32uAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPInt32uAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(J)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jlong>(value));
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPInt64sAttributeCallback : public Callback::Callback<Int64sAttributeCallback>
{
public:
    CHIPInt64sAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<Int64sAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPInt64sAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, int64_t value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPInt64sAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPInt64sAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(J)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jlong>(value));
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPInt64uAttributeCallback : public Callback::Callback<Int64uAttributeCallback>
{
public:
    CHIPInt64uAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<Int64uAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPInt64uAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, uint64_t value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPInt64uAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPInt64uAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(J)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jlong>(value));
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPOctetStringAttributeCallback : public Callback::Callback<OctetStringAttributeCallback>
{
public:
    CHIPOctetStringAttributeCallback(jobject javaCallback, bool keepAlive = false) :
        Callback::Callback<OctetStringAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void maybeDestroy(CHIPOctetStringAttributeCallback * callback)
    {
        if (!callback->keepAlive)
        {
            callback->Cancel();
            delete callback;
        }
    }

    static void CallbackFn(void * context, const chip::ByteSpan value)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPOctetStringAttributeCallback, decltype(&maybeDestroy)> cppCallback(
            reinterpret_cast<CHIPOctetStringAttributeCallback *>(context), maybeDestroy);

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

        jmethodID javaMethod;

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "([B)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));

        jbyteArray valueArr = env->NewByteArray(value.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(valueArr, 0, value.size(), reinterpret_cast<const jbyte *>(value.data()));

        env->CallVoidMethod(javaCallbackRef, javaMethod, valueArr);
    }

private:
    jobject javaCallbackRef;
    bool keepAlive;
};

class CHIPAccountLoginClusterGetSetupPINResponseCallback : public Callback::Callback<AccountLoginClusterGetSetupPINResponseCallback>
{
public:
    CHIPAccountLoginClusterGetSetupPINResponseCallback(jobject javaCallback) :
        Callback::Callback<AccountLoginClusterGetSetupPINResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPAccountLoginClusterGetSetupPINResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t * setupPIN)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPAccountLoginClusterGetSetupPINResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString setupPINStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPAccountLoginClusterGetSetupPINResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, setupPINStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPApplicationLauncherClusterLaunchAppResponseCallback
    : public Callback::Callback<ApplicationLauncherClusterLaunchAppResponseCallback>
{
public:
    CHIPApplicationLauncherClusterLaunchAppResponseCallback(jobject javaCallback) :
        Callback::Callback<ApplicationLauncherClusterLaunchAppResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPApplicationLauncherClusterLaunchAppResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint8_t * data)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPApplicationLauncherClusterLaunchAppResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString dataStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPApplicationLauncherClusterLaunchAppResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), dataStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPContentLauncherClusterLaunchContentResponseCallback
    : public Callback::Callback<ContentLauncherClusterLaunchContentResponseCallback>
{
public:
    CHIPContentLauncherClusterLaunchContentResponseCallback(jobject javaCallback) :
        Callback::Callback<ContentLauncherClusterLaunchContentResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPContentLauncherClusterLaunchContentResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t * data, uint8_t contentLaunchStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPContentLauncherClusterLaunchContentResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString dataStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPContentLauncherClusterLaunchContentResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, dataStr.jniValue(), static_cast<jint>(contentLaunchStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPContentLauncherClusterLaunchURLResponseCallback
    : public Callback::Callback<ContentLauncherClusterLaunchURLResponseCallback>
{
public:
    CHIPContentLauncherClusterLaunchURLResponseCallback(jobject javaCallback) :
        Callback::Callback<ContentLauncherClusterLaunchURLResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPContentLauncherClusterLaunchURLResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t * data, uint8_t contentLaunchStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPContentLauncherClusterLaunchURLResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString dataStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPContentLauncherClusterLaunchURLResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, dataStr.jniValue(), static_cast<jint>(contentLaunchStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearAllPinsResponseCallback : public Callback::Callback<DoorLockClusterClearAllPinsResponseCallback>
{
public:
    CHIPDoorLockClusterClearAllPinsResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearAllPinsResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearAllPinsResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearAllPinsResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearAllPinsResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearAllRfidsResponseCallback : public Callback::Callback<DoorLockClusterClearAllRfidsResponseCallback>
{
public:
    CHIPDoorLockClusterClearAllRfidsResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearAllRfidsResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearAllRfidsResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearAllRfidsResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearAllRfidsResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearHolidayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterClearHolidayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterClearHolidayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearHolidayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearHolidayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearHolidayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearHolidayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearPinResponseCallback : public Callback::Callback<DoorLockClusterClearPinResponseCallback>
{
public:
    CHIPDoorLockClusterClearPinResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearPinResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearPinResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearPinResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearPinResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearRfidResponseCallback : public Callback::Callback<DoorLockClusterClearRfidResponseCallback>
{
public:
    CHIPDoorLockClusterClearRfidResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearRfidResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearRfidResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearRfidResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearRfidResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearWeekdayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterClearWeekdayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterClearWeekdayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearWeekdayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearWeekdayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearWeekdayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearYeardayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterClearYeardayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterClearYeardayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearYeardayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearYeardayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearYeardayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearYeardayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetHolidayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterGetHolidayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterGetHolidayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetHolidayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetHolidayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t scheduleId, uint8_t status, uint32_t localStartTime, uint32_t localEndTime,
                           uint8_t operatingModeDuringHoliday)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetHolidayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetHolidayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIJJI)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(status),
                            static_cast<jlong>(localStartTime), static_cast<jlong>(localEndTime),
                            static_cast<jint>(operatingModeDuringHoliday));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetLogRecordResponseCallback : public Callback::Callback<DoorLockClusterGetLogRecordResponseCallback>
{
public:
    CHIPDoorLockClusterGetLogRecordResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetLogRecordResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetLogRecordResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t logEntryId, uint32_t timestamp, uint8_t eventType, uint8_t source,
                           uint8_t eventIdOrAlarmCode, uint16_t userId, uint8_t * pin)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetLogRecordResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString pinStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetLogRecordResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err =
            JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IJIIIILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(logEntryId), static_cast<jlong>(timestamp),
                            static_cast<jint>(eventType), static_cast<jint>(source), static_cast<jint>(eventIdOrAlarmCode),
                            static_cast<jint>(userId), pinStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetPinResponseCallback : public Callback::Callback<DoorLockClusterGetPinResponseCallback>
{
public:
    CHIPDoorLockClusterGetPinResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetPinResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetPinResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t userId, uint8_t userStatus, uint8_t userType, uint8_t * pin)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetPinResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString pinStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetPinResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userStatus),
                            static_cast<jint>(userType), pinStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetRfidResponseCallback : public Callback::Callback<DoorLockClusterGetRfidResponseCallback>
{
public:
    CHIPDoorLockClusterGetRfidResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetRfidResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetRfidResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t userId, uint8_t userStatus, uint8_t userType, uint8_t * rfid)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetRfidResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString rfidStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetRfidResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userStatus),
                            static_cast<jint>(userType), rfidStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetUserTypeResponseCallback : public Callback::Callback<DoorLockClusterGetUserTypeResponseCallback>
{
public:
    CHIPDoorLockClusterGetUserTypeResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetUserTypeResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetUserTypeResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t userId, uint8_t userType)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetUserTypeResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetUserTypeResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userType));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetWeekdayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterGetWeekdayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterGetWeekdayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetWeekdayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetWeekdayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t scheduleId, uint16_t userId, uint8_t status, uint8_t daysMask, uint8_t startHour,
                           uint8_t startMinute, uint8_t endHour, uint8_t endMinute)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetWeekdayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIIIIIII)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(userId),
                            static_cast<jint>(status), static_cast<jint>(daysMask), static_cast<jint>(startHour),
                            static_cast<jint>(startMinute), static_cast<jint>(endHour), static_cast<jint>(endMinute));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetYeardayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterGetYeardayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterGetYeardayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetYeardayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetYeardayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t scheduleId, uint16_t userId, uint8_t status, uint32_t localStartTime,
                           uint32_t localEndTime)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetYeardayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetYeardayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIIJJ)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(userId),
                            static_cast<jint>(status), static_cast<jlong>(localStartTime), static_cast<jlong>(localEndTime));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterLockDoorResponseCallback : public Callback::Callback<DoorLockClusterLockDoorResponseCallback>
{
public:
    CHIPDoorLockClusterLockDoorResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterLockDoorResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterLockDoorResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterLockDoorResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterLockDoorResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetHolidayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterSetHolidayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterSetHolidayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetHolidayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetHolidayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetHolidayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetHolidayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetPinResponseCallback : public Callback::Callback<DoorLockClusterSetPinResponseCallback>
{
public:
    CHIPDoorLockClusterSetPinResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetPinResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetPinResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetPinResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetPinResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetRfidResponseCallback : public Callback::Callback<DoorLockClusterSetRfidResponseCallback>
{
public:
    CHIPDoorLockClusterSetRfidResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetRfidResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetRfidResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetRfidResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetRfidResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetUserTypeResponseCallback : public Callback::Callback<DoorLockClusterSetUserTypeResponseCallback>
{
public:
    CHIPDoorLockClusterSetUserTypeResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetUserTypeResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetUserTypeResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetUserTypeResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetUserTypeResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetWeekdayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterSetWeekdayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterSetWeekdayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetWeekdayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetWeekdayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetWeekdayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetYeardayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterSetYeardayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterSetYeardayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetYeardayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetYeardayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetYeardayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetYeardayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterUnlockDoorResponseCallback : public Callback::Callback<DoorLockClusterUnlockDoorResponseCallback>
{
public:
    CHIPDoorLockClusterUnlockDoorResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterUnlockDoorResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterUnlockDoorResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterUnlockDoorResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterUnlockDoorResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterUnlockWithTimeoutResponseCallback
    : public Callback::Callback<DoorLockClusterUnlockWithTimeoutResponseCallback>
{
public:
    CHIPDoorLockClusterUnlockWithTimeoutResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterUnlockWithTimeoutResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterUnlockWithTimeoutResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterUnlockWithTimeoutResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralCommissioningClusterArmFailSafeResponseCallback
    : public Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback>
{
public:
    CHIPGeneralCommissioningClusterArmFailSafeResponseCallback(jobject javaCallback) :
        Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGeneralCommissioningClusterArmFailSafeResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGeneralCommissioningClusterArmFailSafeResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback
    : public Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback>
{
public:
    CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback(jobject javaCallback) :
        Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback
    : public Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>
{
public:
    CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback(jobject javaCallback) :
        Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterAddGroupResponseCallback : public Callback::Callback<GroupsClusterAddGroupResponseCallback>
{
public:
    CHIPGroupsClusterAddGroupResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterAddGroupResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterAddGroupResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterAddGroupResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterAddGroupResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterGetGroupMembershipResponseCallback
    : public Callback::Callback<GroupsClusterGetGroupMembershipResponseCallback>
{
public:
    CHIPGroupsClusterGetGroupMembershipResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterGetGroupMembershipResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterGetGroupMembershipResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t capacity, uint8_t groupCount,
                           /* TYPE WARNING: array array defaults to */ uint8_t * groupList)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterGetGroupMembershipResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterGetGroupMembershipResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(capacity), static_cast<jint>(groupCount)
                            // groupList: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterRemoveGroupResponseCallback : public Callback::Callback<GroupsClusterRemoveGroupResponseCallback>
{
public:
    CHIPGroupsClusterRemoveGroupResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterRemoveGroupResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterRemoveGroupResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterRemoveGroupResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterRemoveGroupResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterViewGroupResponseCallback : public Callback::Callback<GroupsClusterViewGroupResponseCallback>
{
public:
    CHIPGroupsClusterViewGroupResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterViewGroupResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterViewGroupResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t * groupName)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterViewGroupResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString groupNameStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterViewGroupResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            groupNameStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPIdentifyClusterIdentifyQueryResponseCallback : public Callback::Callback<IdentifyClusterIdentifyQueryResponseCallback>
{
public:
    CHIPIdentifyClusterIdentifyQueryResponseCallback(jobject javaCallback) :
        Callback::Callback<IdentifyClusterIdentifyQueryResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPIdentifyClusterIdentifyQueryResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t timeout)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPIdentifyClusterIdentifyQueryResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPIdentifyClusterIdentifyQueryResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(timeout));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPKeypadInputClusterSendKeyResponseCallback : public Callback::Callback<KeypadInputClusterSendKeyResponseCallback>
{
public:
    CHIPKeypadInputClusterSendKeyResponseCallback(jobject javaCallback) :
        Callback::Callback<KeypadInputClusterSendKeyResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPKeypadInputClusterSendKeyResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPKeypadInputClusterSendKeyResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPKeypadInputClusterSendKeyResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaFastForwardResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaFastForwardResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaFastForwardResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaFastForwardResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaFastForwardResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaFastForwardResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaNextResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaNextResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaNextResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaNextResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaNextResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaNextResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaNextResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaPauseResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaPauseResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaPauseResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaPauseResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaPauseResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaPauseResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaPauseResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaPlayResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaPlayResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaPlayResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaPlayResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaPlayResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaPlayResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaPlayResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaPreviousResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaPreviousResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaPreviousResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaPreviousResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaPreviousResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaPreviousResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaPreviousResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaRewindResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaRewindResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaRewindResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaRewindResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaRewindResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaRewindResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaRewindResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaSeekResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaSeekResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaSeekResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaSeekResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaSeekResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaSeekResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaSeekResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaSkipBackwardResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaSkipBackwardResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaSkipForwardResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaSkipForwardResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaStartOverResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaStartOverResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaStartOverResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaStartOverResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaStartOverResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaStartOverResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaStartOverResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaStopResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaStopResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaStopResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaStopResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaStopResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaStopResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaStopResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterAddThreadNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterAddThreadNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterAddWiFiNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterAddWiFiNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterDisableNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterDisableNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterDisableNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterDisableNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterDisableNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterDisableNetworkResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterEnableNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterEnableNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterEnableNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterEnableNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterEnableNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterEnableNetworkResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterRemoveNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterRemoveNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterScanNetworksResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterScanNetworksResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterScanNetworksResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText,
                           /* TYPE WARNING: array array defaults to */ uint8_t * wifiScanResults,
                           /* TYPE WARNING: array array defaults to */ uint8_t * threadScanResults)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterScanNetworksResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterScanNetworksResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue()
                            // wifiScanResults: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
                            // threadScanResults: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestResponseCallback
    : public Callback::Callback<OtaSoftwareUpdateProviderClusterApplyUpdateRequestResponseCallback>
{
public:
    CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestResponseCallback(jobject javaCallback) :
        Callback::Callback<OtaSoftwareUpdateProviderClusterApplyUpdateRequestResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t action, uint32_t delayedActionTime)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IJ)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(action), static_cast<jlong>(delayedActionTime));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback
    : public Callback::Callback<OtaSoftwareUpdateProviderClusterQueryImageResponseCallback>
{
public:
    CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback(jobject javaCallback) :
        Callback::Callback<OtaSoftwareUpdateProviderClusterQueryImageResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint32_t delayedActionTime, uint8_t * imageURI, uint32_t softwareVersion,
                           chip::ByteSpan updateToken, bool userConsentNeeded, chip::ByteSpan metadataForRequestor)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString imageURIStr(env, "");
        jbyteArray updateTokenArr;
        jbyteArray metadataForRequestorArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IJLjava/lang/String;J[BZ[B)V",
                                                      &javaMethod);
        SuccessOrExit(err);

        updateTokenArr = env->NewByteArray(updateToken.size());
        VerifyOrExit(updateTokenArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(updateTokenArr, 0, updateToken.size(), reinterpret_cast<const jbyte *>(updateToken.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);
        metadataForRequestorArr = env->NewByteArray(metadataForRequestor.size());
        VerifyOrExit(metadataForRequestorArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(metadataForRequestorArr, 0, metadataForRequestor.size(),
                                reinterpret_cast<const jbyte *>(metadataForRequestor.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jlong>(delayedActionTime),
                            imageURIStr.jniValue(), static_cast<jlong>(softwareVersion), updateTokenArr,
                            static_cast<jboolean>(userConsentNeeded), metadataForRequestorArr);

        env->DeleteLocalRef(updateTokenArr);
        env->DeleteLocalRef(metadataForRequestorArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOperationalCredentialsClusterNOCResponseCallback
    : public Callback::Callback<OperationalCredentialsClusterNOCResponseCallback>
{
public:
    CHIPOperationalCredentialsClusterNOCResponseCallback(jobject javaCallback) :
        Callback::Callback<OperationalCredentialsClusterNOCResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOperationalCredentialsClusterNOCResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t StatusCode, uint8_t FabricIndex, chip::ByteSpan DebugText)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOperationalCredentialsClusterNOCResponseCallback * cppCallback = nullptr;
        jbyteArray DebugTextArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOperationalCredentialsClusterNOCResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II[B)V", &javaMethod);
        SuccessOrExit(err);

        DebugTextArr = env->NewByteArray(DebugText.size());
        VerifyOrExit(DebugTextArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(DebugTextArr, 0, DebugText.size(), reinterpret_cast<const jbyte *>(DebugText.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(StatusCode), static_cast<jint>(FabricIndex),
                            DebugTextArr);

        env->DeleteLocalRef(DebugTextArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOperationalCredentialsClusterOpCSRResponseCallback
    : public Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback>
{
public:
    CHIPOperationalCredentialsClusterOpCSRResponseCallback(jobject javaCallback) :
        Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOperationalCredentialsClusterOpCSRResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, chip::ByteSpan NOCSRElements, chip::ByteSpan AttestationSignature)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOperationalCredentialsClusterOpCSRResponseCallback * cppCallback = nullptr;
        jbyteArray NOCSRElementsArr;
        jbyteArray AttestationSignatureArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOperationalCredentialsClusterOpCSRResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "([B[B)V", &javaMethod);
        SuccessOrExit(err);

        NOCSRElementsArr = env->NewByteArray(NOCSRElements.size());
        VerifyOrExit(NOCSRElementsArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(NOCSRElementsArr, 0, NOCSRElements.size(), reinterpret_cast<const jbyte *>(NOCSRElements.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);
        AttestationSignatureArr = env->NewByteArray(AttestationSignature.size());
        VerifyOrExit(AttestationSignatureArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(AttestationSignatureArr, 0, AttestationSignature.size(),
                                reinterpret_cast<const jbyte *>(AttestationSignature.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, NOCSRElementsArr, AttestationSignatureArr);

        env->DeleteLocalRef(NOCSRElementsArr);
        env->DeleteLocalRef(AttestationSignatureArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterAddSceneResponseCallback : public Callback::Callback<ScenesClusterAddSceneResponseCallback>
{
public:
    CHIPScenesClusterAddSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterAddSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterAddSceneResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterAddSceneResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterAddSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterGetSceneMembershipResponseCallback
    : public Callback::Callback<ScenesClusterGetSceneMembershipResponseCallback>
{
public:
    CHIPScenesClusterGetSceneMembershipResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterGetSceneMembershipResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterGetSceneMembershipResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint8_t capacity, uint16_t groupId, uint8_t sceneCount,
                           /* TYPE WARNING: array array defaults to */ uint8_t * sceneList)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterGetSceneMembershipResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterGetSceneMembershipResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIII)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(capacity),
                            static_cast<jint>(groupId), static_cast<jint>(sceneCount)
                            // sceneList: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterRemoveAllScenesResponseCallback : public Callback::Callback<ScenesClusterRemoveAllScenesResponseCallback>
{
public:
    CHIPScenesClusterRemoveAllScenesResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterRemoveAllScenesResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterRemoveAllScenesResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterRemoveAllScenesResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterRemoveAllScenesResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterRemoveSceneResponseCallback : public Callback::Callback<ScenesClusterRemoveSceneResponseCallback>
{
public:
    CHIPScenesClusterRemoveSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterRemoveSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterRemoveSceneResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterRemoveSceneResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterRemoveSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterStoreSceneResponseCallback : public Callback::Callback<ScenesClusterStoreSceneResponseCallback>
{
public:
    CHIPScenesClusterStoreSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterStoreSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterStoreSceneResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterStoreSceneResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterStoreSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterViewSceneResponseCallback : public Callback::Callback<ScenesClusterViewSceneResponseCallback>
{
public:
    CHIPScenesClusterViewSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterViewSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterViewSceneResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId, uint16_t transitionTime,
                           uint8_t * sceneName, /* TYPE WARNING: array array defaults to */ uint8_t * extensionFieldSets)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterViewSceneResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString sceneNameStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterViewSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIIILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId), static_cast<jint>(transitionTime), sceneNameStr.jniValue()
                            // extensionFieldSets: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTvChannelClusterChangeChannelResponseCallback : public Callback::Callback<TvChannelClusterChangeChannelResponseCallback>
{
public:
    CHIPTvChannelClusterChangeChannelResponseCallback(jobject javaCallback) :
        Callback::Callback<TvChannelClusterChangeChannelResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTvChannelClusterChangeChannelResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, /* TYPE WARNING: array array defaults to */ uint8_t * ChannelMatch, uint8_t ErrorType)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTvChannelClusterChangeChannelResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTvChannelClusterChangeChannelResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef,
                            javaMethod
                            // ChannelMatch: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
                            ,
                            static_cast<jint>(ErrorType));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTargetNavigatorClusterNavigateTargetResponseCallback
    : public Callback::Callback<TargetNavigatorClusterNavigateTargetResponseCallback>
{
public:
    CHIPTargetNavigatorClusterNavigateTargetResponseCallback(jobject javaCallback) :
        Callback::Callback<TargetNavigatorClusterNavigateTargetResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTargetNavigatorClusterNavigateTargetResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint8_t * data)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTargetNavigatorClusterNavigateTargetResponseCallback * cppCallback = nullptr;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString dataStr(env, "");

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTargetNavigatorClusterNavigateTargetResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), dataStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterClusterTestAddArgumentsResponseCallback
    : public Callback::Callback<TestClusterClusterTestAddArgumentsResponseCallback>
{
public:
    CHIPTestClusterClusterTestAddArgumentsResponseCallback(jobject javaCallback) :
        Callback::Callback<TestClusterClusterTestAddArgumentsResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTestClusterClusterTestAddArgumentsResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t returnValue)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTestClusterClusterTestAddArgumentsResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTestClusterClusterTestAddArgumentsResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(returnValue));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterClusterTestSpecificResponseCallback : public Callback::Callback<TestClusterClusterTestSpecificResponseCallback>
{
public:
    CHIPTestClusterClusterTestSpecificResponseCallback(jobject javaCallback) :
        Callback::Callback<TestClusterClusterTestSpecificResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTestClusterClusterTestSpecificResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t returnValue)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTestClusterClusterTestSpecificResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTestClusterClusterTestSpecificResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(returnValue));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPApplicationLauncherApplicationLauncherListAttributeCallback
    : public Callback::Callback<ApplicationLauncherApplicationLauncherListListAttributeCallback>
{
public:
    CHIPApplicationLauncherApplicationLauncherListAttributeCallback(jobject javaCallback) :
        Callback::Callback<ApplicationLauncherApplicationLauncherListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, uint16_t * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPApplicationLauncherApplicationLauncherListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPApplicationLauncherApplicationLauncherListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        for (uint16_t i = 0; i < count; i++)
        {
            jclass entryTypeCls;
            JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            jmethodID entryTypeCtor         = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            jobject applicationLauncherList = env->NewObject(entryTypeCls, entryTypeCtor, entries[i]);
            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, applicationLauncherList);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPAudioOutputAudioOutputListAttributeCallback : public Callback::Callback<AudioOutputAudioOutputListListAttributeCallback>
{
public:
    CHIPAudioOutputAudioOutputListAttributeCallback(jobject javaCallback) :
        Callback::Callback<AudioOutputAudioOutputListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _AudioOutputInfo * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPAudioOutputAudioOutputListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPAudioOutputAudioOutputListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$AudioOutputCluster$AudioOutputListAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(Zcl,
                         "Could not find class chip/devicecontroller/ChipClusters$AudioOutputCluster$AudioOutputListAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(II[B)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find AudioOutputListAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jint index      = entries[i].index;
            jint outputType = entries[i].outputType;
            jbyteArray name = env->NewByteArray(entries[i].name.size());
            env->SetByteArrayRegion(name, 0, entries[i].name.size(), reinterpret_cast<const jbyte *>(entries[i].name.data()));

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, index, outputType, name);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create AudioOutputListAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPContentLauncherAcceptsHeaderListAttributeCallback
    : public Callback::Callback<ContentLauncherAcceptsHeaderListListAttributeCallback>
{
public:
    CHIPContentLauncherAcceptsHeaderListAttributeCallback(jobject javaCallback) :
        Callback::Callback<ContentLauncherAcceptsHeaderListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, chip::ByteSpan * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPContentLauncherAcceptsHeaderListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPContentLauncherAcceptsHeaderListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        for (uint16_t i = 0; i < count; i++)
        {
            jbyteArray acceptsHeaderList = env->NewByteArray(entries[i].size());
            env->SetByteArrayRegion(acceptsHeaderList, 0, entries[i].size(), reinterpret_cast<const jbyte *>(entries[i].data()));
            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, acceptsHeaderList);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPContentLauncherSupportedStreamingTypesAttributeCallback
    : public Callback::Callback<ContentLauncherSupportedStreamingTypesListAttributeCallback>
{
public:
    CHIPContentLauncherSupportedStreamingTypesAttributeCallback(jobject javaCallback) :
        Callback::Callback<ContentLauncherSupportedStreamingTypesListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, uint8_t * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPContentLauncherSupportedStreamingTypesAttributeCallback> cppCallback(
            reinterpret_cast<CHIPContentLauncherSupportedStreamingTypesAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        for (uint16_t i = 0; i < count; i++)
        {
            jclass entryTypeCls;
            JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            jmethodID entryTypeCtor         = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            jobject supportedStreamingTypes = env->NewObject(entryTypeCls, entryTypeCtor, entries[i]);
            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, supportedStreamingTypes);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPDescriptorDeviceListAttributeCallback : public Callback::Callback<DescriptorDeviceListListAttributeCallback>
{
public:
    CHIPDescriptorDeviceListAttributeCallback(jobject javaCallback) :
        Callback::Callback<DescriptorDeviceListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _DeviceType * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDescriptorDeviceListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPDescriptorDeviceListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$DescriptorCluster$DeviceListAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$DescriptorCluster$DeviceListAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(JI)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find DeviceListAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jlong type    = entries[i].type;
            jint revision = entries[i].revision;

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, type, revision);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create DeviceListAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPDescriptorServerListAttributeCallback : public Callback::Callback<DescriptorServerListListAttributeCallback>
{
public:
    CHIPDescriptorServerListAttributeCallback(jobject javaCallback) :
        Callback::Callback<DescriptorServerListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, chip::ClusterId * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDescriptorServerListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPDescriptorServerListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        for (uint16_t i = 0; i < count; i++)
        {
            jclass entryTypeCls;
            JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(J)V");
            jobject serverList      = env->NewObject(entryTypeCls, entryTypeCtor, entries[i]);
            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, serverList);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPDescriptorClientListAttributeCallback : public Callback::Callback<DescriptorClientListListAttributeCallback>
{
public:
    CHIPDescriptorClientListAttributeCallback(jobject javaCallback) :
        Callback::Callback<DescriptorClientListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, chip::ClusterId * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDescriptorClientListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPDescriptorClientListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        for (uint16_t i = 0; i < count; i++)
        {
            jclass entryTypeCls;
            JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(J)V");
            jobject clientList      = env->NewObject(entryTypeCls, entryTypeCtor, entries[i]);
            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, clientList);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPDescriptorPartsListAttributeCallback : public Callback::Callback<DescriptorPartsListListAttributeCallback>
{
public:
    CHIPDescriptorPartsListAttributeCallback(jobject javaCallback) :
        Callback::Callback<DescriptorPartsListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, chip::EndpointId * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDescriptorPartsListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPDescriptorPartsListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        for (uint16_t i = 0; i < count; i++)
        {
            jclass entryTypeCls;
            JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            jobject partsList       = env->NewObject(entryTypeCls, entryTypeCtor, entries[i]);
            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, partsList);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPFixedLabelLabelListAttributeCallback : public Callback::Callback<FixedLabelLabelListListAttributeCallback>
{
public:
    CHIPFixedLabelLabelListAttributeCallback(jobject javaCallback) :
        Callback::Callback<FixedLabelLabelListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _LabelStruct * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPFixedLabelLabelListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPFixedLabelLabelListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$FixedLabelCluster$LabelListAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$FixedLabelCluster$LabelListAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "([B[B)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find LabelListAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jbyteArray label = env->NewByteArray(entries[i].label.size());
            env->SetByteArrayRegion(label, 0, entries[i].label.size(), reinterpret_cast<const jbyte *>(entries[i].label.data()));
            jbyteArray value = env->NewByteArray(entries[i].value.size());
            env->SetByteArrayRegion(value, 0, entries[i].value.size(), reinterpret_cast<const jbyte *>(entries[i].value.data()));

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, label, value);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create LabelListAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback
    : public Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback>
{
public:
    CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback(jobject javaCallback) :
        Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _BasicCommissioningInfoType * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$GeneralCommissioningCluster$BasicCommissioningInfoListAttribute",
            attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(Zcl,
                         "Could not find class "
                         "chip/devicecontroller/ChipClusters$GeneralCommissioningCluster$BasicCommissioningInfoListAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(J)V");
        VerifyOrReturn(attributeCtor != nullptr,
                       ChipLogError(Zcl, "Could not find BasicCommissioningInfoListAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jlong failSafeExpiryLengthMs = entries[i].FailSafeExpiryLengthMs;

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, failSafeExpiryLengthMs);
            VerifyOrReturn(attributeObj != nullptr,
                           ChipLogError(Zcl, "Could not create BasicCommissioningInfoListAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback
    : public Callback::Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback>
{
public:
    CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback(jobject javaCallback) :
        Callback::Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _NetworkInterfaceType * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback> cppCallback(
            reinterpret_cast<CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$GeneralDiagnosticsCluster$NetworkInterfacesAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(
                Zcl,
                "Could not find class chip/devicecontroller/ChipClusters$GeneralDiagnosticsCluster$NetworkInterfacesAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "([BZZZ[BI)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find NetworkInterfacesAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jbyteArray name = env->NewByteArray(entries[i].Name.size());
            env->SetByteArrayRegion(name, 0, entries[i].Name.size(), reinterpret_cast<const jbyte *>(entries[i].Name.data()));
            jboolean fabricConnected                 = entries[i].FabricConnected;
            jboolean offPremiseServicesReachableIPv4 = entries[i].OffPremiseServicesReachableIPv4;
            jboolean offPremiseServicesReachableIPv6 = entries[i].OffPremiseServicesReachableIPv6;
            jbyteArray hardwareAddress               = env->NewByteArray(entries[i].HardwareAddress.size());
            env->SetByteArrayRegion(hardwareAddress, 0, entries[i].HardwareAddress.size(),
                                    reinterpret_cast<const jbyte *>(entries[i].HardwareAddress.data()));
            jint type = entries[i].Type;

            jobject attributeObj =
                env->NewObject(attributeClass, attributeCtor, name, fabricConnected, offPremiseServicesReachableIPv4,
                               offPremiseServicesReachableIPv6, hardwareAddress, type);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create NetworkInterfacesAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupKeyManagementGroupsAttributeCallback : public Callback::Callback<GroupKeyManagementGroupsListAttributeCallback>
{
public:
    CHIPGroupKeyManagementGroupsAttributeCallback(jobject javaCallback) :
        Callback::Callback<GroupKeyManagementGroupsListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _GroupState * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGroupKeyManagementGroupsAttributeCallback> cppCallback(
            reinterpret_cast<CHIPGroupKeyManagementGroupsAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$GroupKeyManagementCluster$GroupsAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$GroupKeyManagementCluster$GroupsAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(III)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find GroupsAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jint vendorId         = entries[i].VendorId;
            jint vendorGroupId    = entries[i].VendorGroupId;
            jint groupKeySetIndex = entries[i].GroupKeySetIndex;

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, vendorId, vendorGroupId, groupKeySetIndex);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create GroupsAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupKeyManagementGroupKeysAttributeCallback : public Callback::Callback<GroupKeyManagementGroupKeysListAttributeCallback>
{
public:
    CHIPGroupKeyManagementGroupKeysAttributeCallback(jobject javaCallback) :
        Callback::Callback<GroupKeyManagementGroupKeysListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _GroupKey * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGroupKeyManagementGroupKeysAttributeCallback> cppCallback(
            reinterpret_cast<CHIPGroupKeyManagementGroupKeysAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$GroupKeyManagementCluster$GroupKeysAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(Zcl,
                         "Could not find class chip/devicecontroller/ChipClusters$GroupKeyManagementCluster$GroupKeysAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(II[BJI)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find GroupKeysAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jint vendorId           = entries[i].VendorId;
            jint groupKeyIndex      = entries[i].GroupKeyIndex;
            jbyteArray groupKeyRoot = env->NewByteArray(entries[i].GroupKeyRoot.size());
            env->SetByteArrayRegion(groupKeyRoot, 0, entries[i].GroupKeyRoot.size(),
                                    reinterpret_cast<const jbyte *>(entries[i].GroupKeyRoot.data()));
            jlong groupKeyEpochStartTime = entries[i].GroupKeyEpochStartTime;
            jint groupKeySecurityPolicy  = entries[i].GroupKeySecurityPolicy;

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, vendorId, groupKeyIndex, groupKeyRoot,
                                                  groupKeyEpochStartTime, groupKeySecurityPolicy);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create GroupKeysAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaInputMediaInputListAttributeCallback : public Callback::Callback<MediaInputMediaInputListListAttributeCallback>
{
public:
    CHIPMediaInputMediaInputListAttributeCallback(jobject javaCallback) :
        Callback::Callback<MediaInputMediaInputListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _MediaInputInfo * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaInputMediaInputListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPMediaInputMediaInputListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$MediaInputCluster$MediaInputListAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$MediaInputCluster$MediaInputListAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(II[B[B)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find MediaInputListAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jint index      = entries[i].index;
            jint inputType  = entries[i].inputType;
            jbyteArray name = env->NewByteArray(entries[i].name.size());
            env->SetByteArrayRegion(name, 0, entries[i].name.size(), reinterpret_cast<const jbyte *>(entries[i].name.data()));
            jbyteArray description = env->NewByteArray(entries[i].description.size());
            env->SetByteArrayRegion(description, 0, entries[i].description.size(),
                                    reinterpret_cast<const jbyte *>(entries[i].description.data()));

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, index, inputType, name, description);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create MediaInputListAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPOperationalCredentialsFabricsListAttributeCallback
    : public Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback>
{
public:
    CHIPOperationalCredentialsFabricsListAttributeCallback(jobject javaCallback) :
        Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _FabricDescriptor * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPOperationalCredentialsFabricsListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPOperationalCredentialsFabricsListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$OperationalCredentialsCluster$FabricsListAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(
                Zcl, "Could not find class chip/devicecontroller/ChipClusters$OperationalCredentialsCluster$FabricsListAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(I[BIJJ[B)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find FabricsListAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jint fabricIndex         = entries[i].FabricIndex;
            jbyteArray rootPublicKey = env->NewByteArray(entries[i].RootPublicKey.size());
            env->SetByteArrayRegion(rootPublicKey, 0, entries[i].RootPublicKey.size(),
                                    reinterpret_cast<const jbyte *>(entries[i].RootPublicKey.data()));
            jint vendorId    = entries[i].VendorId;
            jlong fabricId   = entries[i].FabricId;
            jlong nodeId     = entries[i].NodeId;
            jbyteArray label = env->NewByteArray(entries[i].Label.size());
            env->SetByteArrayRegion(label, 0, entries[i].Label.size(), reinterpret_cast<const jbyte *>(entries[i].Label.data()));

            jobject attributeObj =
                env->NewObject(attributeClass, attributeCtor, fabricIndex, rootPublicKey, vendorId, fabricId, nodeId, label);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create FabricsListAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPTvChannelTvChannelListAttributeCallback : public Callback::Callback<TvChannelTvChannelListListAttributeCallback>
{
public:
    CHIPTvChannelTvChannelListAttributeCallback(jobject javaCallback) :
        Callback::Callback<TvChannelTvChannelListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _TvChannelInfo * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTvChannelTvChannelListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPTvChannelTvChannelListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$TvChannelCluster$TvChannelListAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$TvChannelCluster$TvChannelListAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(II[B[B[B)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find TvChannelListAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jint majorNumber = entries[i].majorNumber;
            jint minorNumber = entries[i].minorNumber;
            jbyteArray name  = env->NewByteArray(entries[i].name.size());
            env->SetByteArrayRegion(name, 0, entries[i].name.size(), reinterpret_cast<const jbyte *>(entries[i].name.data()));
            jbyteArray callSign = env->NewByteArray(entries[i].callSign.size());
            env->SetByteArrayRegion(callSign, 0, entries[i].callSign.size(),
                                    reinterpret_cast<const jbyte *>(entries[i].callSign.data()));
            jbyteArray affiliateCallSign = env->NewByteArray(entries[i].affiliateCallSign.size());
            env->SetByteArrayRegion(affiliateCallSign, 0, entries[i].affiliateCallSign.size(),
                                    reinterpret_cast<const jbyte *>(entries[i].affiliateCallSign.data()));

            jobject attributeObj =
                env->NewObject(attributeClass, attributeCtor, majorNumber, minorNumber, name, callSign, affiliateCallSign);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create TvChannelListAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPTargetNavigatorTargetNavigatorListAttributeCallback
    : public Callback::Callback<TargetNavigatorTargetNavigatorListListAttributeCallback>
{
public:
    CHIPTargetNavigatorTargetNavigatorListAttributeCallback(jobject javaCallback) :
        Callback::Callback<TargetNavigatorTargetNavigatorListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _NavigateTargetTargetInfo * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTargetNavigatorTargetNavigatorListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPTargetNavigatorTargetNavigatorListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$TargetNavigatorCluster$TargetNavigatorListAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(
                Zcl,
                "Could not find class chip/devicecontroller/ChipClusters$TargetNavigatorCluster$TargetNavigatorListAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(I[B)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find TargetNavigatorListAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jint identifier = entries[i].identifier;
            jbyteArray name = env->NewByteArray(entries[i].name.size());
            env->SetByteArrayRegion(name, 0, entries[i].name.size(), reinterpret_cast<const jbyte *>(entries[i].name.data()));

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, identifier, name);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create TargetNavigatorListAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterListInt8uAttributeCallback : public Callback::Callback<TestClusterListInt8uListAttributeCallback>
{
public:
    CHIPTestClusterListInt8uAttributeCallback(jobject javaCallback) :
        Callback::Callback<TestClusterListInt8uListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, uint8_t * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTestClusterListInt8uAttributeCallback> cppCallback(
            reinterpret_cast<CHIPTestClusterListInt8uAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        for (uint16_t i = 0; i < count; i++)
        {
            jclass entryTypeCls;
            JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            jobject listInt8u       = env->NewObject(entryTypeCls, entryTypeCtor, entries[i]);
            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, listInt8u);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterListOctetStringAttributeCallback : public Callback::Callback<TestClusterListOctetStringListAttributeCallback>
{
public:
    CHIPTestClusterListOctetStringAttributeCallback(jobject javaCallback) :
        Callback::Callback<TestClusterListOctetStringListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, chip::ByteSpan * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTestClusterListOctetStringAttributeCallback> cppCallback(
            reinterpret_cast<CHIPTestClusterListOctetStringAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        for (uint16_t i = 0; i < count; i++)
        {
            jbyteArray listOctetString = env->NewByteArray(entries[i].size());
            env->SetByteArrayRegion(listOctetString, 0, entries[i].size(), reinterpret_cast<const jbyte *>(entries[i].data()));
            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, listOctetString);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterListStructOctetStringAttributeCallback
    : public Callback::Callback<TestClusterListStructOctetStringListAttributeCallback>
{
public:
    CHIPTestClusterListStructOctetStringAttributeCallback(jobject javaCallback) :
        Callback::Callback<TestClusterListStructOctetStringListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _TestListStructOctet * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTestClusterListStructOctetStringAttributeCallback> cppCallback(
            reinterpret_cast<CHIPTestClusterListStructOctetStringAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$TestClusterCluster$ListStructOctetStringAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(
                Zcl, "Could not find class chip/devicecontroller/ChipClusters$TestClusterCluster$ListStructOctetStringAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(J[B)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find ListStructOctetStringAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jlong fabricIndex          = entries[i].fabricIndex;
            jbyteArray operationalCert = env->NewByteArray(entries[i].operationalCert.size());
            env->SetByteArrayRegion(operationalCert, 0, entries[i].operationalCert.size(),
                                    reinterpret_cast<const jbyte *>(entries[i].operationalCert.data()));

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, fabricIndex, operationalCert);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create ListStructOctetStringAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback
    : public Callback::Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback>
{
public:
    CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback(jobject javaCallback) :
        Callback::Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _NeighborTable * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$NeighborTableListAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(Zcl,
                         "Could not find class "
                         "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$NeighborTableListAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(JJIJJIIIIIZZZZ)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find NeighborTableListAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jlong extAddress          = entries[i].ExtAddress;
            jlong age                 = entries[i].Age;
            jint rloc16               = entries[i].Rloc16;
            jlong linkFrameCounter    = entries[i].LinkFrameCounter;
            jlong mleFrameCounter     = entries[i].MleFrameCounter;
            jint lqi                  = entries[i].LQI;
            jint averageRssi          = entries[i].AverageRssi;
            jint lastRssi             = entries[i].LastRssi;
            jint frameErrorRate       = entries[i].FrameErrorRate;
            jint messageErrorRate     = entries[i].MessageErrorRate;
            jboolean rxOnWhenIdle     = entries[i].RxOnWhenIdle;
            jboolean fullThreadDevice = entries[i].FullThreadDevice;
            jboolean fullNetworkData  = entries[i].FullNetworkData;
            jboolean isChild          = entries[i].IsChild;

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, extAddress, age, rloc16, linkFrameCounter,
                                                  mleFrameCounter, lqi, averageRssi, lastRssi, frameErrorRate, messageErrorRate,
                                                  rxOnWhenIdle, fullThreadDevice, fullNetworkData, isChild);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create NeighborTableListAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback
    : public Callback::Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback>
{
public:
    CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback(jobject javaCallback) :
        Callback::Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _RouteTable * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$RouteTableListAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(
                Zcl,
                "Could not find class chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$RouteTableListAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(JIIIIIIIZZ)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find RouteTableListAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jlong extAddress         = entries[i].ExtAddress;
            jint rloc16              = entries[i].Rloc16;
            jint routerId            = entries[i].RouterId;
            jint nextHop             = entries[i].NextHop;
            jint pathCost            = entries[i].PathCost;
            jint lQIIn               = entries[i].LQIIn;
            jint lQIOut              = entries[i].LQIOut;
            jint age                 = entries[i].Age;
            jboolean allocated       = entries[i].Allocated;
            jboolean linkEstablished = entries[i].LinkEstablished;

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, extAddress, rloc16, routerId, nextHop, pathCost,
                                                  lQIIn, lQIOut, age, allocated, linkEstablished);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create RouteTableListAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback
    : public Callback::Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback>
{
public:
    CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback(jobject javaCallback) :
        Callback::Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _SecurityPolicy * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback> cppCallback(
            reinterpret_cast<CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$SecurityPolicyAttribute", attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(
                Zcl,
                "Could not find class chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$SecurityPolicyAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(II)V");
        VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find SecurityPolicyAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jint rotationTime = entries[i].RotationTime;
            jint flags        = entries[i].Flags;

            jobject attributeObj = env->NewObject(attributeClass, attributeCtor, rotationTime, flags);
            VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create SecurityPolicyAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback
    : public Callback::Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback>
{
public:
    CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback(jobject javaCallback) :
        Callback::Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, _OperationalDatasetComponents * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback> cppCallback(
            reinterpret_cast<CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        jclass attributeClass;
        err = JniReferences::GetInstance().GetClassRef(
            env, "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$OperationalDatasetComponentsAttribute",
            attributeClass);
        VerifyOrReturn(
            err == CHIP_NO_ERROR,
            ChipLogError(
                Zcl,
                "Could not find class "
                "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$OperationalDatasetComponentsAttribute"));
        JniClass attributeJniClass(attributeClass);
        jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(ZZZZZZZZZZZZ)V");
        VerifyOrReturn(attributeCtor != nullptr,
                       ChipLogError(Zcl, "Could not find OperationalDatasetComponentsAttribute constructor"));

        for (uint16_t i = 0; i < count; i++)
        {
            jboolean activeTimestampPresent  = entries[i].ActiveTimestampPresent;
            jboolean pendingTimestampPresent = entries[i].PendingTimestampPresent;
            jboolean masterKeyPresent        = entries[i].MasterKeyPresent;
            jboolean networkNamePresent      = entries[i].NetworkNamePresent;
            jboolean extendedPanIdPresent    = entries[i].ExtendedPanIdPresent;
            jboolean meshLocalPrefixPresent  = entries[i].MeshLocalPrefixPresent;
            jboolean delayPresent            = entries[i].DelayPresent;
            jboolean panIdPresent            = entries[i].PanIdPresent;
            jboolean channelPresent          = entries[i].ChannelPresent;
            jboolean pskcPresent             = entries[i].PskcPresent;
            jboolean securityPolicyPresent   = entries[i].SecurityPolicyPresent;
            jboolean channelMaskPresent      = entries[i].ChannelMaskPresent;

            jobject attributeObj =
                env->NewObject(attributeClass, attributeCtor, activeTimestampPresent, pendingTimestampPresent, masterKeyPresent,
                               networkNamePresent, extendedPanIdPresent, meshLocalPrefixPresent, delayPresent, panIdPresent,
                               channelPresent, pskcPresent, securityPolicyPresent, channelMaskPresent);
            VerifyOrReturn(attributeObj != nullptr,
                           ChipLogError(Zcl, "Could not create OperationalDatasetComponentsAttribute object"));

            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

class CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback
    : public Callback::Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback>
{
public:
    CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback(jobject javaCallback) :
        Callback::Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    static void CallbackFn(void * context, uint16_t count, uint8_t * entries)
    {
        StackUnlockGuard unlockGuard(JniReferences::GetInstance().GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;

        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback> cppCallback(
            reinterpret_cast<CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback *>(context));

        // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
        javaCallbackRef = cppCallback.get()->javaCallbackRef;
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

        jclass arrayListClass;
        err = JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
        JniClass arrayListJniClass(arrayListClass);
        jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
        jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
        VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                       ChipLogError(Zcl, "Error finding Java ArrayList methods"));
        jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
        VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

        for (uint16_t i = 0; i < count; i++)
        {
            jclass entryTypeCls;
            JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            jmethodID entryTypeCtor         = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            jobject activeNetworkFaultsList = env->NewObject(entryTypeCls, entryTypeCtor, entries[i]);
            env->CallBooleanMethod(arrayListObj, arrayListAddMethod, activeNetworkFaultsList);
        }

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
    }

private:
    jobject javaCallbackRef;
};

JNI_METHOD(void, BaseChipCluster, deleteCluster)(JNIEnv * env, jobject self, jlong clusterPtr)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    ClusterBase * cluster = reinterpret_cast<ClusterBase *>(clusterPtr);
    if (cluster != nullptr)
    {
        delete cluster;
    }
}

JNI_METHOD(jlong, AccountLoginCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    AccountLoginCluster * cppCluster = new AccountLoginCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AccountLoginCluster, getSetupPIN)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster;

    JniUtfString tempAccountIdentifierStr(env, tempAccountIdentifier);
    CHIPAccountLoginClusterGetSetupPINResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPAccountLoginClusterGetSetupPINResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->GetSetupPIN(onSuccess->Cancel(), onFailure->Cancel(),
                                chip::ByteSpan((const uint8_t *) tempAccountIdentifier, strlen(tempAccountIdentifierStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, AccountLoginCluster, login)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier, jstring setupPIN)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster;

    JniUtfString tempAccountIdentifierStr(env, tempAccountIdentifier);
    JniUtfString setupPINStr(env, setupPIN);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Login(onSuccess->Cancel(), onFailure->Cancel(),
                            chip::ByteSpan((const uint8_t *) tempAccountIdentifier, strlen(tempAccountIdentifierStr.c_str())),
                            chip::ByteSpan((const uint8_t *) setupPIN, strlen(setupPINStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, AccountLoginCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, AdministratorCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    AdministratorCommissioningCluster * cppCluster = new AdministratorCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AdministratorCommissioningCluster, openBasicCommissioningWindow)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint commissioningTimeout)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OpenBasicCommissioningWindow(onSuccess->Cancel(), onFailure->Cancel(), commissioningTimeout);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, AdministratorCommissioningCluster, openCommissioningWindow)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint commissioningTimeout, jbyteArray pAKEVerifier,
 jint discriminator, jlong iterations, jbyteArray salt, jint passcodeID)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    JniByteArray pAKEVerifierArr(env, pAKEVerifier);
    JniByteArray saltArr(env, salt);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OpenCommissioningWindow(onSuccess->Cancel(), onFailure->Cancel(), commissioningTimeout,
                                              chip::ByteSpan((const uint8_t *) pAKEVerifierArr.data(), pAKEVerifierArr.size()),
                                              discriminator, iterations,
                                              chip::ByteSpan((const uint8_t *) saltArr.data(), saltArr.size()), passcodeID);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, AdministratorCommissioningCluster, revokeCommissioning)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RevokeCommissioning(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, AdministratorCommissioningCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, ApplicationBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    ApplicationBasicCluster * cppCluster = new ApplicationBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationBasicCluster, changeStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint status)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ChangeStatus(onSuccess->Cancel(), onFailure->Cancel(), status);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, ApplicationBasicCluster, readVendorNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeVendorName(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ApplicationBasicCluster, readVendorIdAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeVendorId(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ApplicationBasicCluster, readApplicationNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeApplicationName(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ApplicationBasicCluster, readProductIdAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeProductId(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ApplicationBasicCluster, readApplicationIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeApplicationId(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ApplicationBasicCluster, readCatalogVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCatalogVendorId(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ApplicationBasicCluster, readApplicationStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeApplicationStatus(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ApplicationBasicCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, ApplicationLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    ApplicationLauncherCluster * cppCluster = new ApplicationLauncherCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationLauncherCluster, launchApp)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring data, jint catalogVendorId, jstring applicationId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster;

    JniUtfString dataStr(env, data);
    JniUtfString applicationIdStr(env, applicationId);
    CHIPApplicationLauncherClusterLaunchAppResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPApplicationLauncherClusterLaunchAppResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LaunchApp(onSuccess->Cancel(), onFailure->Cancel(),
                                chip::ByteSpan((const uint8_t *) data, strlen(dataStr.c_str())), catalogVendorId,
                                chip::ByteSpan((const uint8_t *) applicationId, strlen(applicationIdStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, ApplicationLauncherCluster, readApplicationLauncherListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPApplicationLauncherApplicationLauncherListAttributeCallback * onSuccess =
        new CHIPApplicationLauncherApplicationLauncherListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeApplicationLauncherList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ApplicationLauncherCluster, readCatalogVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCatalogVendorId(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ApplicationLauncherCluster, readApplicationIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeApplicationId(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ApplicationLauncherCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, AudioOutputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    AudioOutputCluster * cppCluster = new AudioOutputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AudioOutputCluster, renameOutput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index, jstring name)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster;

    JniUtfString nameStr(env, name);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RenameOutput(onSuccess->Cancel(), onFailure->Cancel(), index,
                                   chip::ByteSpan((const uint8_t *) name, strlen(nameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, AudioOutputCluster, selectOutput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SelectOutput(onSuccess->Cancel(), onFailure->Cancel(), index);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, AudioOutputCluster, readAudioOutputListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPAudioOutputAudioOutputListAttributeCallback * onSuccess = new CHIPAudioOutputAudioOutputListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeAudioOutputList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, AudioOutputCluster, readCurrentAudioOutputAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentAudioOutput(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, AudioOutputCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, BarrierControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    BarrierControlCluster * cppCluster = new BarrierControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BarrierControlCluster, barrierControlGoToPercent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint percentOpen)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->BarrierControlGoToPercent(onSuccess->Cancel(), onFailure->Cancel(), percentOpen);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, BarrierControlCluster, barrierControlStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->BarrierControlStop(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, BarrierControlCluster, readBarrierMovingStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBarrierMovingState(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BarrierControlCluster, readBarrierSafetyStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBarrierSafetyStatus(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BarrierControlCluster, readBarrierCapabilitiesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBarrierCapabilities(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BarrierControlCluster, readBarrierPositionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBarrierPosition(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BarrierControlCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, BasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    BasicCluster * cppCluster = new BasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BasicCluster, mfgSpecificPing)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    BasicCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MfgSpecificPing(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, BasicCluster, readInteractionModelVersionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInteractionModelVersion(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readVendorNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeVendorName(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readVendorIDAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeVendorID(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readProductNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeProductName(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readProductIDAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeProductID(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readUserLabelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeUserLabel(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, writeUserLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeUserLabel(onSuccess->Cancel(), onFailure->Cancel(),
                                              chip::ByteSpan((const uint8_t *) valueStr.c_str(), strlen(valueStr.c_str())));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readLocationAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeLocation(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, writeLocationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeLocation(onSuccess->Cancel(), onFailure->Cancel(),
                                             chip::ByteSpan((const uint8_t *) valueStr.c_str(), strlen(valueStr.c_str())));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readHardwareVersionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeHardwareVersion(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readHardwareVersionStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeHardwareVersionString(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readSoftwareVersionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSoftwareVersion(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readSoftwareVersionStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSoftwareVersionString(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readManufacturingDateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeManufacturingDate(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readPartNumberAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePartNumber(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readProductURLAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeProductURL(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readProductLabelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeProductLabel(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readSerialNumberAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSerialNumber(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readLocalConfigDisabledAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeLocalConfigDisabled(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, writeLocalConfigDisabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeLocalConfigDisabled(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readReachableAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeReachable(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BasicCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, BinaryInputBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    BinaryInputBasicCluster * cppCluster = new BinaryInputBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BinaryInputBasicCluster, readOutOfServiceAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOutOfService(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BinaryInputBasicCluster, writeOutOfServiceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeOutOfService(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BinaryInputBasicCluster, readPresentValueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePresentValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BinaryInputBasicCluster, writePresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributePresentValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BinaryInputBasicCluster, readStatusFlagsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeStatusFlags(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BinaryInputBasicCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, BindingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    BindingCluster * cppCluster = new BindingCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BindingCluster, bind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong nodeId, jint groupId, jint endpointId, jlong clusterId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    BindingCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Bind(onSuccess->Cancel(), onFailure->Cancel(), nodeId, groupId, endpointId, clusterId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, BindingCluster, unbind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong nodeId, jint groupId, jint endpointId, jlong clusterId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    BindingCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Unbind(onSuccess->Cancel(), onFailure->Cancel(), nodeId, groupId, endpointId, clusterId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, BindingCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err              = CHIP_NO_ERROR;
    BindingCluster * cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, BridgedDeviceBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    BridgedDeviceBasicCluster * cppCluster = new BridgedDeviceBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readVendorNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeVendorName(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readVendorIDAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeVendorID(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readProductNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeProductName(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readUserLabelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeUserLabel(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, writeUserLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeUserLabel(onSuccess->Cancel(), onFailure->Cancel(),
                                              chip::ByteSpan((const uint8_t *) valueStr.c_str(), strlen(valueStr.c_str())));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readHardwareVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeHardwareVersion(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readHardwareVersionStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeHardwareVersionString(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readSoftwareVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSoftwareVersion(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readSoftwareVersionStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSoftwareVersionString(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readManufacturingDateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeManufacturingDate(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readPartNumberAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePartNumber(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readProductURLAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeProductURL(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readProductLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeProductLabel(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readSerialNumberAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSerialNumber(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readReachableAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeReachable(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, ColorControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    ColorControlCluster * cppCluster = new ColorControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ColorControlCluster, colorLoopSet)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint updateFlags, jint action, jint direction, jint time,
 jint startHue, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ColorLoopSet(onSuccess->Cancel(), onFailure->Cancel(), updateFlags, action, direction, time, startHue,
                                   optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnhancedMoveHue(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint enhancedHue, jint direction, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnhancedMoveToHue(onSuccess->Cancel(), onFailure->Cancel(), enhancedHue, direction, transitionTime,
                                        optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint enhancedHue, jint saturation, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnhancedMoveToHueAndSaturation(onSuccess->Cancel(), onFailure->Cancel(), enhancedHue, saturation,
                                                     transitionTime, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, enhancedStepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnhancedStepHue(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime, optionsMask,
                                      optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint rateX, jint rateY, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveColor(onSuccess->Cancel(), onFailure->Cancel(), rateX, rateY, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint colorTemperatureMinimum,
 jint colorTemperatureMaximum, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveColorTemperature(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate, colorTemperatureMinimum,
                                           colorTemperatureMaximum, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveHue(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveSaturation(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveToColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint colorX, jint colorY, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToColor(onSuccess->Cancel(), onFailure->Cancel(), colorX, colorY, transitionTime, optionsMask,
                                  optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveToColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint colorTemperature, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToColorTemperature(onSuccess->Cancel(), onFailure->Cancel(), colorTemperature, transitionTime,
                                             optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint hue, jint direction, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToHue(onSuccess->Cancel(), onFailure->Cancel(), hue, direction, transitionTime, optionsMask,
                                optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint hue, jint saturation, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToHueAndSaturation(onSuccess->Cancel(), onFailure->Cancel(), hue, saturation, transitionTime, optionsMask,
                                             optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveToSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint saturation, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToSaturation(onSuccess->Cancel(), onFailure->Cancel(), saturation, transitionTime, optionsMask,
                                       optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, stepColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepX, jint stepY, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->StepColor(onSuccess->Cancel(), onFailure->Cancel(), stepX, stepY, transitionTime, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, stepColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint colorTemperatureMinimum, jint colorTemperatureMaximum, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepColorTemperature(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime,
                                           colorTemperatureMinimum, colorTemperatureMaximum, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, stepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepHue(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime, optionsMask,
                              optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, stepSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepSaturation(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime, optionsMask,
                                     optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, stopMoveStep)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StopMoveStep(onSuccess->Cancel(), onFailure->Cancel(), optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, ColorControlCluster, readCurrentHueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentHue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readCurrentSaturationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentSaturation(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readRemainingTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRemainingTime(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readCurrentXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentX(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readCurrentYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentY(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readDriftCompensationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeDriftCompensation(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readCompensationTextAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCompensationText(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorTemperatureAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorTemperature(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorMode(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorControlOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorControlOptions(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeColorControlOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeColorControlOptions(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readNumberOfPrimariesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeNumberOfPrimaries(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary1XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary1X(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary1YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary1Y(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary1IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary1Intensity(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary2XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary2X(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary2YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary2Y(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary2IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary2Intensity(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary3XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary3X(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary3YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary3Y(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary3IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary3Intensity(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary4XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary4X(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary4YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary4Y(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary4IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary4Intensity(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary5XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary5X(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary5YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary5Y(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary5IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary5Intensity(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary6XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary6X(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary6YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary6Y(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readPrimary6IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePrimary6Intensity(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readWhitePointXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeWhitePointX(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeWhitePointX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readWhitePointYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeWhitePointY(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeWhitePointY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorPointRXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorPointRX(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeColorPointRX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorPointRYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorPointRY(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeColorPointRY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorPointRIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorPointRIntensity(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeColorPointRIntensity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorPointGXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorPointGX(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeColorPointGX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorPointGYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorPointGY(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeColorPointGY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorPointGIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorPointGIntensity(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeColorPointGIntensity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorPointBXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorPointBX(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeColorPointBX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorPointBYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorPointBY(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeColorPointBY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorPointBIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorPointBIntensity(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeColorPointBIntensity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readEnhancedCurrentHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeEnhancedCurrentHue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readEnhancedColorModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeEnhancedColorMode(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorLoopActiveAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorLoopActive(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorLoopDirectionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorLoopDirection(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorLoopTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorLoopTime(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorLoopStartEnhancedHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorLoopStartEnhancedHue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorLoopStoredEnhancedHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorLoopStoredEnhancedHue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorCapabilitiesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorCapabilities(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorTempPhysicalMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorTempPhysicalMin(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readColorTempPhysicalMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeColorTempPhysicalMax(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readCoupleColorTempToLevelMinMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCoupleColorTempToLevelMinMireds(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readStartUpColorTemperatureMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeStartUpColorTemperatureMireds(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, writeStartUpColorTemperatureMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeStartUpColorTemperatureMireds(onSuccess->Cancel(), onFailure->Cancel(),
                                                                  static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ColorControlCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, ContentLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    ContentLauncherCluster * cppCluster = new ContentLauncherCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ContentLauncherCluster, launchContent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean autoPlay, jstring data)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster;

    JniUtfString dataStr(env, data);
    CHIPContentLauncherClusterLaunchContentResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPContentLauncherClusterLaunchContentResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LaunchContent(onSuccess->Cancel(), onFailure->Cancel(), autoPlay,
                                    chip::ByteSpan((const uint8_t *) data, strlen(dataStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ContentLauncherCluster, launchURL)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring contentURL, jstring displayString)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster;

    JniUtfString contentURLStr(env, contentURL);
    JniUtfString displayStringStr(env, displayString);
    CHIPContentLauncherClusterLaunchURLResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPContentLauncherClusterLaunchURLResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LaunchURL(onSuccess->Cancel(), onFailure->Cancel(),
                                chip::ByteSpan((const uint8_t *) contentURL, strlen(contentURLStr.c_str())),
                                chip::ByteSpan((const uint8_t *) displayString, strlen(displayStringStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, ContentLauncherCluster, readAcceptsHeaderListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPContentLauncherAcceptsHeaderListAttributeCallback * onSuccess =
        new CHIPContentLauncherAcceptsHeaderListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeAcceptsHeaderList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ContentLauncherCluster, readSupportedStreamingTypesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPContentLauncherSupportedStreamingTypesAttributeCallback * onSuccess =
        new CHIPContentLauncherSupportedStreamingTypesAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSupportedStreamingTypes(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ContentLauncherCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, DescriptorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    DescriptorCluster * cppCluster = new DescriptorCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DescriptorCluster, readDeviceListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDescriptorDeviceListAttributeCallback * onSuccess = new CHIPDescriptorDeviceListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    DescriptorCluster * cppCluster = reinterpret_cast<DescriptorCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeDeviceList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, DescriptorCluster, readServerListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDescriptorServerListAttributeCallback * onSuccess = new CHIPDescriptorServerListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    DescriptorCluster * cppCluster = reinterpret_cast<DescriptorCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeServerList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, DescriptorCluster, readClientListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDescriptorClientListAttributeCallback * onSuccess = new CHIPDescriptorClientListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    DescriptorCluster * cppCluster = reinterpret_cast<DescriptorCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClientList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, DescriptorCluster, readPartsListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDescriptorPartsListAttributeCallback * onSuccess = new CHIPDescriptorPartsListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    DescriptorCluster * cppCluster = reinterpret_cast<DescriptorCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePartsList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, DescriptorCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    DescriptorCluster * cppCluster = reinterpret_cast<DescriptorCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, DiagnosticLogsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    DiagnosticLogsCluster * cppCluster = new DiagnosticLogsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DiagnosticLogsCluster, retrieveLogsRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint intent, jint requestedProtocol,
 jbyteArray transferFileDesignator)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DiagnosticLogsCluster * cppCluster;

    JniByteArray transferFileDesignatorArr(env, transferFileDesignator);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DiagnosticLogsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RetrieveLogsRequest(
        onSuccess->Cancel(), onFailure->Cancel(), intent, requestedProtocol,
        chip::ByteSpan((const uint8_t *) transferFileDesignatorArr.data(), transferFileDesignatorArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, DoorLockCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    DoorLockCluster * cppCluster = new DoorLockCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DoorLockCluster, clearAllPins)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearAllPinsResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearAllPinsResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearAllPins(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearAllRfids)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearAllRfidsResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearAllRfidsResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearAllRfids(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearHolidayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearHolidayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearHolidaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearPin)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearPinResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearPinResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearPin(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearRfid)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearRfidResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearRfidResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearRfid(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearWeekdayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearWeekdayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearWeekdaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearYeardayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearYeardayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearYeardaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetHolidayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetHolidayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetHolidaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getLogRecord)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint logIndex)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetLogRecordResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetLogRecordResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetLogRecord(onSuccess->Cancel(), onFailure->Cancel(), logIndex);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getPin)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetPinResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetPinResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetPin(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getRfid)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetRfidResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetRfidResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetRfid(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getUserType)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetUserTypeResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetUserTypeResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetUserType(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetWeekdayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetWeekdayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetWeekdaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetYeardayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetYeardayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetYeardaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, lockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring pin)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniUtfString pinStr(env, pin);
    CHIPDoorLockClusterLockDoorResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterLockDoorResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LockDoor(onSuccess->Cancel(), onFailure->Cancel(),
                               chip::ByteSpan((const uint8_t *) pin, strlen(pinStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jlong localStartTime, jlong localEndTime,
 jint operatingModeDuringHoliday)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterSetHolidayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetHolidayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetHolidaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, localStartTime, localEndTime,
                                         operatingModeDuringHoliday);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setPin)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userStatus, jint userType, jstring pin)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniUtfString pinStr(env, pin);
    CHIPDoorLockClusterSetPinResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetPinResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetPin(onSuccess->Cancel(), onFailure->Cancel(), userId, userStatus, userType,
                             chip::ByteSpan((const uint8_t *) pin, strlen(pinStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setRfid)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userStatus, jint userType, jstring id)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniUtfString idStr(env, id);
    CHIPDoorLockClusterSetRfidResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetRfidResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetRfid(onSuccess->Cancel(), onFailure->Cancel(), userId, userStatus, userType,
                              chip::ByteSpan((const uint8_t *) id, strlen(idStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setUserType)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userType)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterSetUserTypeResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetUserTypeResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetUserType(onSuccess->Cancel(), onFailure->Cancel(), userId, userType);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId, jint daysMask, jint startHour,
 jint startMinute, jint endHour, jint endMinute)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterSetWeekdayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetWeekdayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetWeekdaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId, daysMask, startHour,
                                         startMinute, endHour, endMinute);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId, jlong localStartTime,
 jlong localEndTime)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterSetYeardayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetYeardayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->SetYeardaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId, localStartTime, localEndTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, unlockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring pin)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniUtfString pinStr(env, pin);
    CHIPDoorLockClusterUnlockDoorResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterUnlockDoorResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UnlockDoor(onSuccess->Cancel(), onFailure->Cancel(),
                                 chip::ByteSpan((const uint8_t *) pin, strlen(pinStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, unlockWithTimeout)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint timeoutInSeconds, jstring pin)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniUtfString pinStr(env, pin);
    CHIPDoorLockClusterUnlockWithTimeoutResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterUnlockWithTimeoutResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UnlockWithTimeout(onSuccess->Cancel(), onFailure->Cancel(), timeoutInSeconds,
                                        chip::ByteSpan((const uint8_t *) pin, strlen(pinStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, DoorLockCluster, readLockStateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeLockState(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, DoorLockCluster, readLockTypeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeLockType(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, DoorLockCluster, readActuatorEnabledAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeActuatorEnabled(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, DoorLockCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, ElectricalMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    ElectricalMeasurementCluster * cppCluster = new ElectricalMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ElectricalMeasurementCluster, readMeasurementTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMeasurementType(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readTotalActivePowerAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32sAttributeCallback * onSuccess = new CHIPInt32sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTotalActivePower(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsVoltageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRmsVoltage(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsVoltageMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRmsVoltageMin(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsVoltageMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRmsVoltageMax(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsCurrentAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRmsCurrent(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsCurrentMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRmsCurrentMin(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsCurrentMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRmsCurrentMax(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readActivePowerAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeActivePower(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readActivePowerMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeActivePowerMin(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readActivePowerMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeActivePowerMax(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ElectricalMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, EthernetNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    EthernetNetworkDiagnosticsCluster * cppCluster = new EthernetNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResetCounts(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readPacketRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePacketRxCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readPacketTxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePacketTxCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readTxErrCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxErrCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readCollisionCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCollisionCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOverrunCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, FixedLabelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    FixedLabelCluster * cppCluster = new FixedLabelCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, FixedLabelCluster, readLabelListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPFixedLabelLabelListAttributeCallback * onSuccess = new CHIPFixedLabelLabelListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    FixedLabelCluster * cppCluster = reinterpret_cast<FixedLabelCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeLabelList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, FixedLabelCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    FixedLabelCluster * cppCluster = reinterpret_cast<FixedLabelCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, FlowMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    FlowMeasurementCluster * cppCluster = new FlowMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, FlowMeasurementCluster, readMeasuredValueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, FlowMeasurementCluster, readMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMinMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, FlowMeasurementCluster, readMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMaxMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, FlowMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, GeneralCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    GeneralCommissioningCluster * cppCluster = new GeneralCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GeneralCommissioningCluster, armFailSafe)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint expiryLengthSeconds, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    CHIPGeneralCommissioningClusterArmFailSafeResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGeneralCommissioningClusterArmFailSafeResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ArmFailSafe(onSuccess->Cancel(), onFailure->Cancel(), expiryLengthSeconds, breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GeneralCommissioningCluster, commissioningComplete)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->CommissioningComplete(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GeneralCommissioningCluster, setRegulatoryConfig)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint location, jstring countryCode, jlong breadcrumb,
 jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    JniUtfString countryCodeStr(env, countryCode);
    CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetRegulatoryConfig(onSuccess->Cancel(), onFailure->Cancel(), location,
                                          chip::ByteSpan((const uint8_t *) countryCode, strlen(countryCodeStr.c_str())), breadcrumb,
                                          timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, GeneralCommissioningCluster, readBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBreadcrumb(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, GeneralCommissioningCluster, writeBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeBreadcrumb(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, GeneralCommissioningCluster, readBasicCommissioningInfoListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback * onSuccess =
        new CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBasicCommissioningInfoList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, GeneralCommissioningCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, GeneralDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    GeneralDiagnosticsCluster * cppCluster = new GeneralDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GeneralDiagnosticsCluster, readNetworkInterfacesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback * onSuccess =
        new CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeNetworkInterfaces(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, GeneralDiagnosticsCluster, readRebootCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRebootCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, GeneralDiagnosticsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, GroupKeyManagementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    GroupKeyManagementCluster * cppCluster = new GroupKeyManagementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GroupKeyManagementCluster, readGroupsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPGroupKeyManagementGroupsAttributeCallback * onSuccess = new CHIPGroupKeyManagementGroupsAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GroupKeyManagementCluster * cppCluster = reinterpret_cast<GroupKeyManagementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeGroups(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, GroupKeyManagementCluster, readGroupKeysAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPGroupKeyManagementGroupKeysAttributeCallback * onSuccess = new CHIPGroupKeyManagementGroupKeysAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GroupKeyManagementCluster * cppCluster = reinterpret_cast<GroupKeyManagementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeGroupKeys(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, GroupKeyManagementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GroupKeyManagementCluster * cppCluster = reinterpret_cast<GroupKeyManagementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, GroupsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    GroupsCluster * cppCluster = new GroupsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GroupsCluster, addGroup)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jstring groupName)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    JniUtfString groupNameStr(env, groupName);
    CHIPGroupsClusterAddGroupResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGroupsClusterAddGroupResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddGroup(onSuccess->Cancel(), onFailure->Cancel(), groupId,
                               chip::ByteSpan((const uint8_t *) groupName, strlen(groupNameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GroupsCluster, addGroupIfIdentifying)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jstring groupName)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    JniUtfString groupNameStr(env, groupName);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddGroupIfIdentifying(onSuccess->Cancel(), onFailure->Cancel(), groupId,
                                            chip::ByteSpan((const uint8_t *) groupName, strlen(groupNameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GroupsCluster, getGroupMembership)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupCount, jint groupList)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    CHIPGroupsClusterGetGroupMembershipResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGroupsClusterGetGroupMembershipResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetGroupMembership(onSuccess->Cancel(), onFailure->Cancel(), groupCount, groupList);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GroupsCluster, removeAllGroups)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveAllGroups(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GroupsCluster, removeGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    CHIPGroupsClusterRemoveGroupResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGroupsClusterRemoveGroupResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveGroup(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GroupsCluster, viewGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    CHIPGroupsClusterViewGroupResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGroupsClusterViewGroupResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ViewGroup(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, GroupsCluster, readNameSupportAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    GroupsCluster * cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeNameSupport(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, GroupsCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    GroupsCluster * cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, IdentifyCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    IdentifyCluster * cppCluster = new IdentifyCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, IdentifyCluster, identify)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint identifyTime)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Identify(onSuccess->Cancel(), onFailure->Cancel(), identifyTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, IdentifyCluster, identifyQuery)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    CHIPIdentifyClusterIdentifyQueryResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPIdentifyClusterIdentifyQueryResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->IdentifyQuery(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, IdentifyCluster, readIdentifyTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeIdentifyTime(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, IdentifyCluster, writeIdentifyTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeIdentifyTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, IdentifyCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, KeypadInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    KeypadInputCluster * cppCluster = new KeypadInputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, KeypadInputCluster, sendKey)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint keyCode)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    KeypadInputCluster * cppCluster;

    CHIPKeypadInputClusterSendKeyResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<KeypadInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPKeypadInputClusterSendKeyResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SendKey(onSuccess->Cancel(), onFailure->Cancel(), keyCode);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, KeypadInputCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    KeypadInputCluster * cppCluster = reinterpret_cast<KeypadInputCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, LevelControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    LevelControlCluster * cppCluster = new LevelControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LevelControlCluster, move)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionMask, jint optionOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Move(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate, optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, moveToLevel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint level, jint transitionTime, jint optionMask,
 jint optionOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToLevel(onSuccess->Cancel(), onFailure->Cancel(), level, transitionTime, optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, moveToLevelWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint level, jint transitionTime)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToLevelWithOnOff(onSuccess->Cancel(), onFailure->Cancel(), level, transitionTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, moveWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveWithOnOff(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, step)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime, jint optionMask,
 jint optionOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->Step(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime, optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, stepWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepWithOnOff(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, stop)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint optionMask, jint optionOverride)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Stop(onSuccess->Cancel(), onFailure->Cancel(), optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, stopWithOnOff)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StopWithOnOff(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, LevelControlCluster, readCurrentLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentLevel(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, LevelControlCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, LowPowerCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    LowPowerCluster * cppCluster = new LowPowerCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LowPowerCluster, sleep)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LowPowerCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LowPowerCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Sleep(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, LowPowerCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err               = CHIP_NO_ERROR;
    LowPowerCluster * cppCluster = reinterpret_cast<LowPowerCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, MediaInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    MediaInputCluster * cppCluster = new MediaInputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaInputCluster, hideInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->HideInputStatus(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaInputCluster, renameInput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index, jstring name)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    JniUtfString nameStr(env, name);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RenameInput(onSuccess->Cancel(), onFailure->Cancel(), index,
                                  chip::ByteSpan((const uint8_t *) name, strlen(nameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaInputCluster, selectInput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SelectInput(onSuccess->Cancel(), onFailure->Cancel(), index);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaInputCluster, showInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ShowInputStatus(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, MediaInputCluster, readMediaInputListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPMediaInputMediaInputListAttributeCallback * onSuccess = new CHIPMediaInputMediaInputListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMediaInputList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, MediaInputCluster, readCurrentMediaInputAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentMediaInput(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, MediaInputCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, MediaPlaybackCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    MediaPlaybackCluster * cppCluster = new MediaPlaybackCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaPlaybackCluster, mediaFastForward)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaFastForwardResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaFastForwardResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaFastForward(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaNext)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaNextResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaNextResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaNext(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPause)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaPauseResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaPauseResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaPause(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPlay)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaPlayResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaPlayResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaPlay(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPrevious)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaPreviousResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaPreviousResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaPrevious(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaRewind)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaRewindResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaRewindResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaRewind(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSeek)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong position)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaSeekResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaSeekResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaSeek(onSuccess->Cancel(), onFailure->Cancel(), position);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipBackward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong deltaPositionMilliseconds)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaSkipBackward(onSuccess->Cancel(), onFailure->Cancel(), deltaPositionMilliseconds);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipForward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong deltaPositionMilliseconds)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaSkipForward(onSuccess->Cancel(), onFailure->Cancel(), deltaPositionMilliseconds);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStartOver)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaStartOverResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaStartOverResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaStartOver(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaStopResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaStopResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaStop(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, MediaPlaybackCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, NetworkCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    NetworkCommissioningCluster * cppCluster = new NetworkCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, NetworkCommissioningCluster, addThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray operationalDatasetArr(env, operationalDataset);
    CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddThreadNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                       chip::ByteSpan((const uint8_t *) operationalDatasetArr.data(), operationalDatasetArr.size()),
                                       breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, addWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jlong breadcrumb,
 jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray ssidArr(env, ssid);
    JniByteArray credentialsArr(env, credentials);
    CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddWiFiNetwork(
        onSuccess->Cancel(), onFailure->Cancel(), chip::ByteSpan((const uint8_t *) ssidArr.data(), ssidArr.size()),
        chip::ByteSpan((const uint8_t *) credentialsArr.data(), credentialsArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, disableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray networkIDArr(env, networkID);
    CHIPNetworkCommissioningClusterDisableNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterDisableNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->DisableNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                     chip::ByteSpan((const uint8_t *) networkIDArr.data(), networkIDArr.size()), breadcrumb,
                                     timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, enableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray networkIDArr(env, networkID);
    CHIPNetworkCommissioningClusterEnableNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterEnableNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnableNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                    chip::ByteSpan((const uint8_t *) networkIDArr.data(), networkIDArr.size()), breadcrumb,
                                    timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, getLastNetworkCommissioningResult)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetLastNetworkCommissioningResult(onSuccess->Cancel(), onFailure->Cancel(), timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, removeNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray networkIDArr(env, networkID);
    CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                    chip::ByteSpan((const uint8_t *) networkIDArr.data(), networkIDArr.size()), breadcrumb,
                                    timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, scanNetworks)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray ssidArr(env, ssid);
    CHIPNetworkCommissioningClusterScanNetworksResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterScanNetworksResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ScanNetworks(onSuccess->Cancel(), onFailure->Cancel(),
                                   chip::ByteSpan((const uint8_t *) ssidArr.data(), ssidArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, updateThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray operationalDatasetArr(env, operationalDataset);
    CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateThreadNetwork(
        onSuccess->Cancel(), onFailure->Cancel(),
        chip::ByteSpan((const uint8_t *) operationalDatasetArr.data(), operationalDatasetArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, updateWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jlong breadcrumb,
 jlong timeoutMs)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray ssidArr(env, ssid);
    JniByteArray credentialsArr(env, credentials);
    CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateWiFiNetwork(
        onSuccess->Cancel(), onFailure->Cancel(), chip::ByteSpan((const uint8_t *) ssidArr.data(), ssidArr.size()),
        chip::ByteSpan((const uint8_t *) credentialsArr.data(), credentialsArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, NetworkCommissioningCluster, readFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeFeatureMap(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, NetworkCommissioningCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, OtaSoftwareUpdateProviderCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    OtaSoftwareUpdateProviderCluster * cppCluster = new OtaSoftwareUpdateProviderCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, applyUpdateRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray updateToken, jlong newVersion)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    JniByteArray updateTokenArr(env, updateToken);
    CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->ApplyUpdateRequest(onSuccess->Cancel(), onFailure->Cancel(),
                                       chip::ByteSpan((const uint8_t *) updateTokenArr.data(), updateTokenArr.size()), newVersion);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, notifyUpdateApplied)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray updateToken, jlong currentVersion)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    JniByteArray updateTokenArr(env, updateToken);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->NotifyUpdateApplied(onSuccess->Cancel(), onFailure->Cancel(),
                                          chip::ByteSpan((const uint8_t *) updateTokenArr.data(), updateTokenArr.size()),
                                          currentVersion);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, queryImage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint vendorId, jint productId, jint imageType,
 jint hardwareVersion, jlong currentVersion, jint protocolsSupported, jstring location, jboolean requestorCanConsent,
 jbyteArray metadataForProvider)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    JniUtfString locationStr(env, location);
    JniByteArray metadataForProviderArr(env, metadataForProvider);
    CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->QueryImage(onSuccess->Cancel(), onFailure->Cancel(), vendorId, productId, imageType, hardwareVersion,
                                 currentVersion, protocolsSupported,
                                 chip::ByteSpan((const uint8_t *) location, strlen(locationStr.c_str())), requestorCanConsent,
                                 chip::ByteSpan((const uint8_t *) metadataForProviderArr.data(), metadataForProviderArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, OccupancySensingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    OccupancySensingCluster * cppCluster = new OccupancySensingCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OccupancySensingCluster, readOccupancyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOccupancy(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OccupancySensingCluster, readOccupancySensorTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOccupancySensorType(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OccupancySensingCluster, readOccupancySensorTypeBitmapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOccupancySensorTypeBitmap(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OccupancySensingCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, OnOffCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    OnOffCluster * cppCluster = new OnOffCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffCluster, off)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Off(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OnOffCluster, offWithEffect)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint effectId, jint effectVariant)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OffWithEffect(onSuccess->Cancel(), onFailure->Cancel(), effectId, effectVariant);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OnOffCluster, on)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->On(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OnOffCluster, onWithRecallGlobalScene)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OnWithRecallGlobalScene(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OnOffCluster, onWithTimedOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint onOffControl, jint onTime, jint offWaitTime)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OnWithTimedOff(onSuccess->Cancel(), onFailure->Cancel(), onOffControl, onTime, offWaitTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OnOffCluster, toggle)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Toggle(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, OnOffCluster, readOnOffAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOnOff(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffCluster, readGlobalSceneControlAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeGlobalSceneControl(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffCluster, readOnTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOnTime(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffCluster, writeOnTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeOnTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffCluster, readOffWaitTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOffWaitTime(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffCluster, writeOffWaitTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeOffWaitTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffCluster, readStartUpOnOffAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeStartUpOnOff(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffCluster, writeStartUpOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeStartUpOnOff(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffCluster, readFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeFeatureMap(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, OnOffSwitchConfigurationCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    OnOffSwitchConfigurationCluster * cppCluster = new OnOffSwitchConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, readSwitchTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSwitchType(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, readSwitchActionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSwitchActions(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, writeSwitchActionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeSwitchActions(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, OperationalCredentialsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    OperationalCredentialsCluster * cppCluster = new OperationalCredentialsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OperationalCredentialsCluster, addNOC)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray nOCArray, jbyteArray iPKValue, jlong caseAdminNode,
 jint adminVendorId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray nOCArrayArr(env, nOCArray);
    JniByteArray iPKValueArr(env, iPKValue);
    CHIPOperationalCredentialsClusterNOCResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOperationalCredentialsClusterNOCResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddNOC(
        onSuccess->Cancel(), onFailure->Cancel(), chip::ByteSpan((const uint8_t *) nOCArrayArr.data(), nOCArrayArr.size()),
        chip::ByteSpan((const uint8_t *) iPKValueArr.data(), iPKValueArr.size()), caseAdminNode, adminVendorId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, addTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray rootCertificate)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray rootCertificateArr(env, rootCertificate);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddTrustedRootCertificate(
        onSuccess->Cancel(), onFailure->Cancel(),
        chip::ByteSpan((const uint8_t *) rootCertificateArr.data(), rootCertificateArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, opCSRRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray cSRNonce)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray cSRNonceArr(env, cSRNonce);
    CHIPOperationalCredentialsClusterOpCSRResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOperationalCredentialsClusterOpCSRResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OpCSRRequest(onSuccess->Cancel(), onFailure->Cancel(),
                                   chip::ByteSpan((const uint8_t *) cSRNonceArr.data(), cSRNonceArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, removeFabric)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint fabricIndex)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    CHIPOperationalCredentialsClusterNOCResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOperationalCredentialsClusterNOCResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveFabric(onSuccess->Cancel(), onFailure->Cancel(), fabricIndex);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, removeTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray trustedRootIdentifier)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray trustedRootIdentifierArr(env, trustedRootIdentifier);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveTrustedRootCertificate(
        onSuccess->Cancel(), onFailure->Cancel(),
        chip::ByteSpan((const uint8_t *) trustedRootIdentifierArr.data(), trustedRootIdentifierArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, updateFabricLabel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring label)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniUtfString labelStr(env, label);
    CHIPOperationalCredentialsClusterNOCResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOperationalCredentialsClusterNOCResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateFabricLabel(onSuccess->Cancel(), onFailure->Cancel(),
                                        chip::ByteSpan((const uint8_t *) label, strlen(labelStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, updateNOC)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray nOCArray)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray nOCArrayArr(env, nOCArray);
    CHIPOperationalCredentialsClusterNOCResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOperationalCredentialsClusterNOCResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateNOC(onSuccess->Cancel(), onFailure->Cancel(),
                                chip::ByteSpan((const uint8_t *) nOCArrayArr.data(), nOCArrayArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, OperationalCredentialsCluster, readFabricsListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPOperationalCredentialsFabricsListAttributeCallback * onSuccess =
        new CHIPOperationalCredentialsFabricsListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeFabricsList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OperationalCredentialsCluster, readSupportedFabricsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSupportedFabrics(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OperationalCredentialsCluster, readCommissionedFabricsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCommissionedFabrics(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, OperationalCredentialsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, PressureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    PressureMeasurementCluster * cppCluster = new PressureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PressureMeasurementCluster, readMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PressureMeasurementCluster, readMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMinMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PressureMeasurementCluster, readMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMaxMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PressureMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, PumpConfigurationAndControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    PumpConfigurationAndControlCluster * cppCluster = new PumpConfigurationAndControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMaxPressure(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMaxSpeed(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxFlowAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMaxFlow(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readEffectiveOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeEffectiveOperationMode(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readEffectiveControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeEffectiveControlMode(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readCapacityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCapacity(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOperationMode(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeOperationMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, RelativeHumidityMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    RelativeHumidityMeasurementCluster * cppCluster = new RelativeHumidityMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, readMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, readMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMinMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, readMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMaxMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, ScenesCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    ScenesCluster * cppCluster = new ScenesCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ScenesCluster, addScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId, jint transitionTime, jstring sceneName,
 jlong clusterId, jint length, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    JniUtfString sceneNameStr(env, sceneName);
    CHIPScenesClusterAddSceneResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterAddSceneResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId, transitionTime,
                               chip::ByteSpan((const uint8_t *) sceneName, strlen(sceneNameStr.c_str())), clusterId, length, value);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, getSceneMembership)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPScenesClusterGetSceneMembershipResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterGetSceneMembershipResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetSceneMembership(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, recallScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId, jint transitionTime)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RecallScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId, transitionTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, removeAllScenes)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPScenesClusterRemoveAllScenesResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterRemoveAllScenesResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveAllScenes(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, removeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPScenesClusterRemoveSceneResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterRemoveSceneResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, storeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPScenesClusterStoreSceneResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterStoreSceneResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StoreScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, viewScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPScenesClusterViewSceneResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterViewSceneResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ViewScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, ScenesCluster, readSceneCountAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSceneCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ScenesCluster, readCurrentSceneAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentScene(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ScenesCluster, readCurrentGroupAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentGroup(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ScenesCluster, readSceneValidAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSceneValid(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ScenesCluster, readNameSupportAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeNameSupport(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ScenesCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, SoftwareDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    SoftwareDiagnosticsCluster * cppCluster = new SoftwareDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, resetWatermarks)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResetWatermarks(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, readCurrentHeapHighWatermarkAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentHeapHighWatermark(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, SwitchCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    SwitchCluster * cppCluster = new SwitchCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SwitchCluster, readNumberOfPositionsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeNumberOfPositions(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, SwitchCluster, readCurrentPositionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentPosition(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, SwitchCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, TvChannelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    TvChannelCluster * cppCluster = new TvChannelCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TvChannelCluster, changeChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring match)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    JniUtfString matchStr(env, match);
    CHIPTvChannelClusterChangeChannelResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPTvChannelClusterChangeChannelResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ChangeChannel(onSuccess->Cancel(), onFailure->Cancel(),
                                    chip::ByteSpan((const uint8_t *) match, strlen(matchStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TvChannelCluster, changeChannelByNumber)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint majorNumber, jint minorNumber)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ChangeChannelByNumber(onSuccess->Cancel(), onFailure->Cancel(), majorNumber, minorNumber);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TvChannelCluster, skipChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint count)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SkipChannel(onSuccess->Cancel(), onFailure->Cancel(), count);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, TvChannelCluster, readTvChannelListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPTvChannelTvChannelListAttributeCallback * onSuccess = new CHIPTvChannelTvChannelListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTvChannelList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TvChannelCluster, readTvChannelLineupAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPOctetStringAttributeCallback * onSuccess = new CHIPOctetStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTvChannelLineup(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TvChannelCluster, readCurrentTvChannelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPOctetStringAttributeCallback * onSuccess = new CHIPOctetStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentTvChannel(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TvChannelCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, TargetNavigatorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    TargetNavigatorCluster * cppCluster = new TargetNavigatorCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TargetNavigatorCluster, navigateTarget)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint target, jstring data)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TargetNavigatorCluster * cppCluster;

    JniUtfString dataStr(env, data);
    CHIPTargetNavigatorClusterNavigateTargetResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TargetNavigatorCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPTargetNavigatorClusterNavigateTargetResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->NavigateTarget(onSuccess->Cancel(), onFailure->Cancel(), target,
                                     chip::ByteSpan((const uint8_t *) data, strlen(dataStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, TargetNavigatorCluster, readTargetNavigatorListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPTargetNavigatorTargetNavigatorListAttributeCallback * onSuccess =
        new CHIPTargetNavigatorTargetNavigatorListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    TargetNavigatorCluster * cppCluster = reinterpret_cast<TargetNavigatorCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTargetNavigatorList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TargetNavigatorCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    TargetNavigatorCluster * cppCluster = reinterpret_cast<TargetNavigatorCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, TemperatureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    TemperatureMeasurementCluster * cppCluster = new TemperatureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TemperatureMeasurementCluster, readMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TemperatureMeasurementCluster, readMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMinMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TemperatureMeasurementCluster, readMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMaxMeasuredValue(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TemperatureMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, TestClusterCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    TestClusterCluster * cppCluster = new TestClusterCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TestClusterCluster, test)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Test(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TestClusterCluster, testAddArguments)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1, jint arg2)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    CHIPTestClusterClusterTestAddArgumentsResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPTestClusterClusterTestAddArgumentsResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestAddArguments(onSuccess->Cancel(), onFailure->Cancel(), arg1, arg2);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TestClusterCluster, testNotHandled)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestNotHandled(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TestClusterCluster, testSpecific)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    CHIPTestClusterClusterTestSpecificResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPTestClusterClusterTestSpecificResponseCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestSpecific(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TestClusterCluster, testUnknownCommand)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestUnknownCommand(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, TestClusterCluster, readBooleanAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBoolean(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeBoolean(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readBitmap8Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBitmap8(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeBitmap8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readBitmap16Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBitmap16(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeBitmap16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readBitmap32Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBitmap32(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeBitmap32(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint32_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readBitmap64Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBitmap64(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeBitmap64(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readInt8uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInt8u(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeInt8u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readInt16uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInt16u(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeInt16u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readInt32uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInt32u(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeInt32u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint32_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readInt64uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInt64u(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeInt64u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readInt8sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8sAttributeCallback * onSuccess = new CHIPInt8sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInt8s(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeInt8s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readInt16sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInt16s(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeInt16s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readInt32sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32sAttributeCallback * onSuccess = new CHIPInt32sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInt32s(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeInt32s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int32_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readInt64sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64sAttributeCallback * onSuccess = new CHIPInt64sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInt64s(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeInt64s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int64_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readEnum8Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeEnum8(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeEnum8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readEnum16Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeEnum16(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeEnum16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readOctetStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPOctetStringAttributeCallback * onSuccess = new CHIPOctetStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOctetString(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    JniByteArray jniArr(env, value);
    err = cppCluster->WriteAttributeOctetString(onSuccess->Cancel(), onFailure->Cancel(),
                                                chip::ByteSpan((const uint8_t *) jniArr.data(), jniArr.size()));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readListInt8uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPTestClusterListInt8uAttributeCallback * onSuccess = new CHIPTestClusterListInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeListInt8u(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readListOctetStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPTestClusterListOctetStringAttributeCallback * onSuccess = new CHIPTestClusterListOctetStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeListOctetString(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readListStructOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPTestClusterListStructOctetStringAttributeCallback * onSuccess =
        new CHIPTestClusterListStructOctetStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeListStructOctetString(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readLongOctetStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPOctetStringAttributeCallback * onSuccess = new CHIPOctetStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeLongOctetString(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeLongOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    JniByteArray jniArr(env, value);
    err = cppCluster->WriteAttributeLongOctetString(onSuccess->Cancel(), onFailure->Cancel(),
                                                    chip::ByteSpan((const uint8_t *) jniArr.data(), jniArr.size()));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readCharStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCharString(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeCharString(onSuccess->Cancel(), onFailure->Cancel(),
                                               chip::ByteSpan((const uint8_t *) valueStr.c_str(), strlen(valueStr.c_str())));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readLongCharStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeLongCharString(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeLongCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeLongCharString(onSuccess->Cancel(), onFailure->Cancel(),
                                                   chip::ByteSpan((const uint8_t *) valueStr.c_str(), strlen(valueStr.c_str())));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readUnsupportedAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPBooleanAttributeCallback * onSuccess = new CHIPBooleanAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeUnsupported(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, writeUnsupportedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeUnsupported(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, TestClusterCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, ThermostatCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    ThermostatCluster * cppCluster = new ThermostatCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatCluster, clearWeeklySchedule)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearWeeklySchedule(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ThermostatCluster, getRelayStatusLog)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetRelayStatusLog(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ThermostatCluster, getWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint daysToReturn, jint modeToReturn)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetWeeklySchedule(onSuccess->Cancel(), onFailure->Cancel(), daysToReturn, modeToReturn);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ThermostatCluster, setWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint numberOfTransitionsForSequence, jint dayOfWeekForSequence,
 jint modeForSequence, jint payload)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetWeeklySchedule(onSuccess->Cancel(), onFailure->Cancel(), numberOfTransitionsForSequence,
                                        dayOfWeekForSequence, modeForSequence, payload);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ThermostatCluster, setpointRaiseLower)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint mode, jint amount)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetpointRaiseLower(onSuccess->Cancel(), onFailure->Cancel(), mode, amount);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, ThermostatCluster, readLocalTemperatureAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeLocalTemperature(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readAbsMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeAbsMinHeatSetpointLimit(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readAbsMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeAbsMaxHeatSetpointLimit(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readAbsMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeAbsMinCoolSetpointLimit(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readAbsMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeAbsMaxCoolSetpointLimit(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readOccupiedCoolingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOccupiedCoolingSetpoint(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedCoolingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeOccupiedCoolingSetpoint(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readOccupiedHeatingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOccupiedHeatingSetpoint(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedHeatingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeOccupiedHeatingSetpoint(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMinHeatSetpointLimit(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, writeMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeMinHeatSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMaxHeatSetpointLimit(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, writeMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeMaxHeatSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMinCoolSetpointLimit(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, writeMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeMinCoolSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16sAttributeCallback * onSuccess = new CHIPInt16sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMaxCoolSetpointLimit(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, writeMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeMaxCoolSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readControlSequenceOfOperationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeControlSequenceOfOperation(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, writeControlSequenceOfOperationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err =
        cppCluster->WriteAttributeControlSequenceOfOperation(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readSystemModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSystemMode(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, writeSystemModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeSystemMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readStartOfWeekAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeStartOfWeek(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readNumberOfWeeklyTransitionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeNumberOfWeeklyTransitions(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readNumberOfDailyTransitionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeNumberOfDailyTransitions(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeFeatureMap(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, ThermostatUserInterfaceConfigurationCluster, initWithDevice)
(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    ThermostatUserInterfaceConfigurationCluster * cppCluster = new ThermostatUserInterfaceConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, readTemperatureDisplayModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTemperatureDisplayMode(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeTemperatureDisplayModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeTemperatureDisplayMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, readKeypadLockoutAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeKeypadLockout(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeKeypadLockoutAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeKeypadLockout(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, readScheduleProgrammingVisibilityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeScheduleProgrammingVisibility(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeScheduleProgrammingVisibilityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeScheduleProgrammingVisibility(onSuccess->Cancel(), onFailure->Cancel(),
                                                                  static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, ThreadNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    ThreadNetworkDiagnosticsCluster * cppCluster = new ThreadNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResetCounts(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readChannelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeChannel(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRoutingRoleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRoutingRole(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readNetworkNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPOctetStringAttributeCallback * onSuccess = new CHIPOctetStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeNetworkName(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readPanIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePanId(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readExtendedPanIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeExtendedPanId(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readMeshLocalPrefixAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPOctetStringAttributeCallback * onSuccess = new CHIPOctetStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMeshLocalPrefix(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt64uAttributeCallback * onSuccess = new CHIPInt64uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOverrunCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readNeighborTableListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback * onSuccess =
        new CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeNeighborTableList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRouteTableListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback * onSuccess =
        new CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRouteTableList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readPartitionIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePartitionId(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readWeightingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeWeighting(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readDataVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeDataVersion(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readStableDataVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeStableDataVersion(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readLeaderRouterIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeLeaderRouterId(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readDetachedRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeDetachedRoleCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readChildRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeChildRoleCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRouterRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRouterRoleCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readLeaderRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeLeaderRoleCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readAttachAttemptCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeAttachAttemptCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readPartitionIdChangeCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributePartitionIdChangeCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readBetterPartitionAttachAttemptCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBetterPartitionAttachAttemptCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readParentChangeCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeParentChangeCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxTotalCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxTotalCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxUnicastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxUnicastCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxBroadcastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxBroadcastCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxAckRequestedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxAckRequestedCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxAckedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxAckedCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxNoAckRequestedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxNoAckRequestedCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxDataCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxDataCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxDataPollCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxDataPollCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxBeaconCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxBeaconCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxBeaconRequestCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxBeaconRequestCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxOtherCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxRetryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxRetryCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxDirectMaxRetryExpiryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxDirectMaxRetryExpiryCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxIndirectMaxRetryExpiryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxIndirectMaxRetryExpiryCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxErrCcaCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxErrCcaCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxErrAbortCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxErrAbortCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxErrBusyChannelCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTxErrBusyChannelCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxTotalCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxTotalCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxUnicastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxUnicastCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxBroadcastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxBroadcastCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxDataCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxDataCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxDataPollCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxDataPollCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxBeaconCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxBeaconCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxBeaconRequestCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxBeaconRequestCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxOtherCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxAddressFilteredCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxAddressFilteredCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxDestAddrFilteredCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxDestAddrFilteredCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxDuplicatedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxDuplicatedCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrNoFrameCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxErrNoFrameCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrUnknownNeighborCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxErrUnknownNeighborCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrInvalidSrcAddrCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxErrInvalidSrcAddrCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrSecCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxErrSecCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrFcsCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxErrFcsCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt32uAttributeCallback * onSuccess = new CHIPInt32uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRxErrOtherCount(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readSecurityPolicyAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback * onSuccess =
        new CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSecurityPolicy(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readChannelMaskAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeChannelMask(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readOperationalDatasetComponentsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback * onSuccess =
        new CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOperationalDatasetComponents(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readActiveNetworkFaultsListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback * onSuccess =
        new CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeActiveNetworkFaultsList(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, WakeOnLanCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    WakeOnLanCluster * cppCluster = new WakeOnLanCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WakeOnLanCluster, readWakeOnLanMacAddressAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPCharStringAttributeCallback * onSuccess = new CHIPCharStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                = CHIP_NO_ERROR;
    WakeOnLanCluster * cppCluster = reinterpret_cast<WakeOnLanCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeWakeOnLanMacAddress(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WakeOnLanCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                = CHIP_NO_ERROR;
    WakeOnLanCluster * cppCluster = reinterpret_cast<WakeOnLanCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, WiFiNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    WiFiNetworkDiagnosticsCluster * cppCluster = new WiFiNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResetCounts(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readBssidAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPOctetStringAttributeCallback * onSuccess = new CHIPOctetStringAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeBssid(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readSecurityTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSecurityType(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readWiFiVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeWiFiVersion(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readChannelNumberAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeChannelNumber(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readRssiAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8sAttributeCallback * onSuccess = new CHIPInt8sAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeRssi(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
JNI_METHOD(jlong, WindowCoveringCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    WindowCoveringCluster * cppCluster = new WindowCoveringCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WindowCoveringCluster, downOrClose)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->DownOrClose(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, goToLiftPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint liftPercentageValue, jint liftPercent100thsValue)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GoToLiftPercentage(onSuccess->Cancel(), onFailure->Cancel(), liftPercentageValue, liftPercent100thsValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, goToLiftValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint liftValue)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GoToLiftValue(onSuccess->Cancel(), onFailure->Cancel(), liftValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, goToTiltPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint tiltPercentageValue, jint tiltPercent100thsValue)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GoToTiltPercentage(onSuccess->Cancel(), onFailure->Cancel(), tiltPercentageValue, tiltPercent100thsValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, goToTiltValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint tiltValue)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GoToTiltValue(onSuccess->Cancel(), onFailure->Cancel(), tiltValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, stopMotion)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StopMotion(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, upOrOpen)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpOrOpen(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err.Format(), exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}

JNI_METHOD(void, WindowCoveringCluster, readTypeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeType(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentPositionLift(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentPositionTilt(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readConfigStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeConfigStatus(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionLiftPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentPositionLiftPercentage(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionTiltPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentPositionTiltPercentage(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readOperationalStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeOperationalStatus(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readTargetPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTargetPositionLiftPercent100ths(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readTargetPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeTargetPositionTiltPercent100ths(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readEndProductTypeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeEndProductType(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentPositionLiftPercent100ths(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeCurrentPositionTiltPercent100ths(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readInstalledOpenLimitLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInstalledOpenLimitLift(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readInstalledClosedLimitLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInstalledClosedLimitLift(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readInstalledOpenLimitTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInstalledOpenLimitTilt(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readInstalledClosedLimitTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeInstalledClosedLimitTilt(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt8uAttributeCallback * onSuccess = new CHIPInt8uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeMode(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, writeModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPDefaultSuccessCallback * onSuccess = new CHIPDefaultSuccessCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->WriteAttributeMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error writing attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readSafetyStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeSafetyStatus(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}

JNI_METHOD(void, WindowCoveringCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(JniReferences::GetInstance().GetStackLock());
    CHIPInt16uAttributeCallback * onSuccess = new CHIPInt16uAttributeCallback(callback);
    if (!onSuccess)
    {
        ReturnIllegalStateException(env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIPDefaultFailureCallback * onFailure = new CHIPDefaultFailureCallback(callback);
    if (!onFailure)
    {
        delete onSuccess;
        ReturnIllegalStateException(env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY.AsInteger());
        return;
    }

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    if (cppCluster == nullptr)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE.AsInteger());
        return;
    }

    err = cppCluster->ReadAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel());
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;
        ReturnIllegalStateException(env, callback, "Error reading attribute", err.AsInteger());
    }
}
