/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#include "CHIPReadCallbacks.h"

#include <app-common/zap-generated/cluster-objects.h>
#include <zap-generated/CHIPClientCallbacks.h>
#include <zap-generated/CHIPClusters.h>

#include <controller/java/AndroidClusterExceptions.h>
#include <controller/java/CHIPCallbackWrapper.h>
#include <controller/java/CHIPDefaultCallbacks.h>
#include <jni.h>
#include <lib/support/CHIPJNIError.h>
#include <lib/support/CodeUtils.h>
#include <lib/support/JniReferences.h>
#include <lib/support/JniTypeWrappers.h>
#include <lib/support/Span.h>
#include <platform/PlatformManager.h>

#define JNI_METHOD(RETURN, CLASS_NAME, METHOD_NAME)                                                                                \
    extern "C" JNIEXPORT RETURN JNICALL Java_chip_devicecontroller_ChipClusters_00024##CLASS_NAME##_##METHOD_NAME

using namespace chip;
using namespace chip::Controller;

class CHIPAccountLoginClusterGetSetupPINResponseCallback
    : public CHIPCallbackWrapper<AccountLoginClusterGetSetupPINResponseCallback>
{
public:
    static void CallbackFn(void * context, chip::CharSpan setupPIN)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPAccountLoginClusterGetSetupPINResponseCallback,
                        void (*)(CHIPAccountLoginClusterGetSetupPINResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPAccountLoginClusterGetSetupPINResponseCallback *>(context),
                        chip::Platform::Delete<CHIPAccountLoginClusterGetSetupPINResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString setupPINStr(env, setupPIN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, setupPINStr.jniValue());
    }

    CHIPAccountLoginClusterGetSetupPINResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<AccountLoginClusterGetSetupPINResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPApplicationLauncherClusterLaunchAppResponseCallback
    : public CHIPCallbackWrapper<ApplicationLauncherClusterLaunchAppResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, chip::CharSpan data)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPApplicationLauncherClusterLaunchAppResponseCallback,
                        void (*)(CHIPApplicationLauncherClusterLaunchAppResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPApplicationLauncherClusterLaunchAppResponseCallback *>(context),
                        chip::Platform::Delete<CHIPApplicationLauncherClusterLaunchAppResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString dataStr(env, data);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), dataStr.jniValue());
    }

    CHIPApplicationLauncherClusterLaunchAppResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                            bool keepAlive = false) :
        CHIPCallbackWrapper<ApplicationLauncherClusterLaunchAppResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPContentLauncherClusterLaunchContentResponseCallback
    : public CHIPCallbackWrapper<ContentLauncherClusterLaunchContentResponseCallback>
{
public:
    static void CallbackFn(void * context, chip::CharSpan data, uint8_t contentLaunchStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPContentLauncherClusterLaunchContentResponseCallback,
                        void (*)(CHIPContentLauncherClusterLaunchContentResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPContentLauncherClusterLaunchContentResponseCallback *>(context),
                        chip::Platform::Delete<CHIPContentLauncherClusterLaunchContentResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString dataStr(env, data);

        env->CallVoidMethod(javaCallbackRef, javaMethod, dataStr.jniValue(), static_cast<jint>(contentLaunchStatus));
    }

    CHIPContentLauncherClusterLaunchContentResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                            bool keepAlive = false) :
        CHIPCallbackWrapper<ContentLauncherClusterLaunchContentResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPContentLauncherClusterLaunchURLResponseCallback
    : public CHIPCallbackWrapper<ContentLauncherClusterLaunchURLResponseCallback>
{
public:
    static void CallbackFn(void * context, chip::CharSpan data, uint8_t contentLaunchStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPContentLauncherClusterLaunchURLResponseCallback,
                        void (*)(CHIPContentLauncherClusterLaunchURLResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPContentLauncherClusterLaunchURLResponseCallback *>(context),
                        chip::Platform::Delete<CHIPContentLauncherClusterLaunchURLResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString dataStr(env, data);

        env->CallVoidMethod(javaCallbackRef, javaMethod, dataStr.jniValue(), static_cast<jint>(contentLaunchStatus));
    }

    CHIPContentLauncherClusterLaunchURLResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                        bool keepAlive = false) :
        CHIPCallbackWrapper<ContentLauncherClusterLaunchURLResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback
    : public CHIPCallbackWrapper<DiagnosticLogsClusterRetrieveLogsResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, chip::ByteSpan content, uint32_t timeStamp, uint32_t timeSinceBoot)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback,
                        void (*)(CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I[BJJ)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        jbyteArray contentArr = env->NewByteArray(content.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(contentArr, 0, content.size(), reinterpret_cast<const jbyte *>(content.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), contentArr, static_cast<jlong>(timeStamp),
                            static_cast<jlong>(timeSinceBoot));

        env->DeleteLocalRef(contentArr);
    }

    CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                          bool keepAlive = false) :
        CHIPCallbackWrapper<DiagnosticLogsClusterRetrieveLogsResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterClearAllPinsResponseCallback : public CHIPCallbackWrapper<DoorLockClusterClearAllPinsResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterClearAllPinsResponseCallback,
                        void (*)(CHIPDoorLockClusterClearAllPinsResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterClearAllPinsResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterClearAllPinsResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterClearAllPinsResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterClearAllPinsResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterClearAllRfidsResponseCallback : public CHIPCallbackWrapper<DoorLockClusterClearAllRfidsResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterClearAllRfidsResponseCallback,
                        void (*)(CHIPDoorLockClusterClearAllRfidsResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterClearAllRfidsResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterClearAllRfidsResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterClearAllRfidsResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterClearAllRfidsResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterClearHolidayScheduleResponseCallback
    : public CHIPCallbackWrapper<DoorLockClusterClearHolidayScheduleResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterClearHolidayScheduleResponseCallback,
                        void (*)(CHIPDoorLockClusterClearHolidayScheduleResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterClearHolidayScheduleResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterClearHolidayScheduleResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterClearHolidayScheduleResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                            bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterClearHolidayScheduleResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterClearPinResponseCallback : public CHIPCallbackWrapper<DoorLockClusterClearPinResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterClearPinResponseCallback, void (*)(CHIPDoorLockClusterClearPinResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterClearPinResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterClearPinResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterClearPinResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterClearPinResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterClearRfidResponseCallback : public CHIPCallbackWrapper<DoorLockClusterClearRfidResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterClearRfidResponseCallback, void (*)(CHIPDoorLockClusterClearRfidResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterClearRfidResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterClearRfidResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterClearRfidResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterClearRfidResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterClearWeekdayScheduleResponseCallback
    : public CHIPCallbackWrapper<DoorLockClusterClearWeekdayScheduleResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback,
                        void (*)(CHIPDoorLockClusterClearWeekdayScheduleResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterClearWeekdayScheduleResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                            bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterClearWeekdayScheduleResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterClearYeardayScheduleResponseCallback
    : public CHIPCallbackWrapper<DoorLockClusterClearYeardayScheduleResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterClearYeardayScheduleResponseCallback,
                        void (*)(CHIPDoorLockClusterClearYeardayScheduleResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterClearYeardayScheduleResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterClearYeardayScheduleResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterClearYeardayScheduleResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                            bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterClearYeardayScheduleResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterGetHolidayScheduleResponseCallback
    : public CHIPCallbackWrapper<DoorLockClusterGetHolidayScheduleResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t scheduleId, uint8_t status, uint32_t localStartTime, uint32_t localEndTime,
                           uint8_t operatingModeDuringHoliday)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterGetHolidayScheduleResponseCallback,
                        void (*)(CHIPDoorLockClusterGetHolidayScheduleResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterGetHolidayScheduleResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterGetHolidayScheduleResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIJJI)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(status),
                            static_cast<jlong>(localStartTime), static_cast<jlong>(localEndTime),
                            static_cast<jint>(operatingModeDuringHoliday));
    }

    CHIPDoorLockClusterGetHolidayScheduleResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                          bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterGetHolidayScheduleResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterGetLogRecordResponseCallback : public CHIPCallbackWrapper<DoorLockClusterGetLogRecordResponseCallback>
{
public:
    static void CallbackFn(void * context, uint16_t logEntryId, uint32_t timestamp, uint8_t eventType, uint8_t source,
                           uint8_t eventIdOrAlarmCode, uint16_t userId, chip::ByteSpan pin)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterGetLogRecordResponseCallback,
                        void (*)(CHIPDoorLockClusterGetLogRecordResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterGetLogRecordResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterGetLogRecordResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IJIIII[B)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        jbyteArray pinArr = env->NewByteArray(pin.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(pinArr, 0, pin.size(), reinterpret_cast<const jbyte *>(pin.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(logEntryId), static_cast<jlong>(timestamp),
                            static_cast<jint>(eventType), static_cast<jint>(source), static_cast<jint>(eventIdOrAlarmCode),
                            static_cast<jint>(userId), pinArr);

        env->DeleteLocalRef(pinArr);
    }

    CHIPDoorLockClusterGetLogRecordResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterGetLogRecordResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterGetPinResponseCallback : public CHIPCallbackWrapper<DoorLockClusterGetPinResponseCallback>
{
public:
    static void CallbackFn(void * context, uint16_t userId, uint8_t userStatus, uint8_t userType, chip::ByteSpan pin)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterGetPinResponseCallback, void (*)(CHIPDoorLockClusterGetPinResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterGetPinResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterGetPinResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III[B)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        jbyteArray pinArr = env->NewByteArray(pin.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(pinArr, 0, pin.size(), reinterpret_cast<const jbyte *>(pin.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userStatus),
                            static_cast<jint>(userType), pinArr);

        env->DeleteLocalRef(pinArr);
    }

    CHIPDoorLockClusterGetPinResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterGetPinResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterGetRfidResponseCallback : public CHIPCallbackWrapper<DoorLockClusterGetRfidResponseCallback>
{
public:
    static void CallbackFn(void * context, uint16_t userId, uint8_t userStatus, uint8_t userType, chip::ByteSpan rfid)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterGetRfidResponseCallback, void (*)(CHIPDoorLockClusterGetRfidResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterGetRfidResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterGetRfidResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III[B)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        jbyteArray rfidArr = env->NewByteArray(rfid.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(rfidArr, 0, rfid.size(), reinterpret_cast<const jbyte *>(rfid.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userStatus),
                            static_cast<jint>(userType), rfidArr);

        env->DeleteLocalRef(rfidArr);
    }

    CHIPDoorLockClusterGetRfidResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterGetRfidResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterGetUserTypeResponseCallback : public CHIPCallbackWrapper<DoorLockClusterGetUserTypeResponseCallback>
{
public:
    static void CallbackFn(void * context, uint16_t userId, uint8_t userType)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterGetUserTypeResponseCallback, void (*)(CHIPDoorLockClusterGetUserTypeResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterGetUserTypeResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterGetUserTypeResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userType));
    }

    CHIPDoorLockClusterGetUserTypeResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterGetUserTypeResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterGetWeekdayScheduleResponseCallback
    : public CHIPCallbackWrapper<DoorLockClusterGetWeekdayScheduleResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t scheduleId, uint16_t userId, uint8_t status, uint8_t daysMask, uint8_t startHour,
                           uint8_t startMinute, uint8_t endHour, uint8_t endMinute)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback,
                        void (*)(CHIPDoorLockClusterGetWeekdayScheduleResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIIIIIII)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(userId),
                            static_cast<jint>(status), static_cast<jint>(daysMask), static_cast<jint>(startHour),
                            static_cast<jint>(startMinute), static_cast<jint>(endHour), static_cast<jint>(endMinute));
    }

    CHIPDoorLockClusterGetWeekdayScheduleResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                          bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterGetWeekdayScheduleResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterGetYeardayScheduleResponseCallback
    : public CHIPCallbackWrapper<DoorLockClusterGetYeardayScheduleResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t scheduleId, uint16_t userId, uint8_t status, uint32_t localStartTime,
                           uint32_t localEndTime)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterGetYeardayScheduleResponseCallback,
                        void (*)(CHIPDoorLockClusterGetYeardayScheduleResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterGetYeardayScheduleResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterGetYeardayScheduleResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIIJJ)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(userId),
                            static_cast<jint>(status), static_cast<jlong>(localStartTime), static_cast<jlong>(localEndTime));
    }

    CHIPDoorLockClusterGetYeardayScheduleResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                          bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterGetYeardayScheduleResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterLockDoorResponseCallback : public CHIPCallbackWrapper<DoorLockClusterLockDoorResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterLockDoorResponseCallback, void (*)(CHIPDoorLockClusterLockDoorResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterLockDoorResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterLockDoorResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterLockDoorResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterLockDoorResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterSetHolidayScheduleResponseCallback
    : public CHIPCallbackWrapper<DoorLockClusterSetHolidayScheduleResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterSetHolidayScheduleResponseCallback,
                        void (*)(CHIPDoorLockClusterSetHolidayScheduleResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterSetHolidayScheduleResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterSetHolidayScheduleResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterSetHolidayScheduleResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                          bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterSetHolidayScheduleResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterSetPinResponseCallback : public CHIPCallbackWrapper<DoorLockClusterSetPinResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterSetPinResponseCallback, void (*)(CHIPDoorLockClusterSetPinResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterSetPinResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterSetPinResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterSetPinResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterSetPinResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterSetRfidResponseCallback : public CHIPCallbackWrapper<DoorLockClusterSetRfidResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterSetRfidResponseCallback, void (*)(CHIPDoorLockClusterSetRfidResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterSetRfidResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterSetRfidResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterSetRfidResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterSetRfidResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterSetUserTypeResponseCallback : public CHIPCallbackWrapper<DoorLockClusterSetUserTypeResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterSetUserTypeResponseCallback, void (*)(CHIPDoorLockClusterSetUserTypeResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterSetUserTypeResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterSetUserTypeResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterSetUserTypeResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterSetUserTypeResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterSetWeekdayScheduleResponseCallback
    : public CHIPCallbackWrapper<DoorLockClusterSetWeekdayScheduleResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback,
                        void (*)(CHIPDoorLockClusterSetWeekdayScheduleResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterSetWeekdayScheduleResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                          bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterSetWeekdayScheduleResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterSetYeardayScheduleResponseCallback
    : public CHIPCallbackWrapper<DoorLockClusterSetYeardayScheduleResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterSetYeardayScheduleResponseCallback,
                        void (*)(CHIPDoorLockClusterSetYeardayScheduleResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterSetYeardayScheduleResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterSetYeardayScheduleResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterSetYeardayScheduleResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                          bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterSetYeardayScheduleResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterUnlockDoorResponseCallback : public CHIPCallbackWrapper<DoorLockClusterUnlockDoorResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterUnlockDoorResponseCallback, void (*)(CHIPDoorLockClusterUnlockDoorResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterUnlockDoorResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterUnlockDoorResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterUnlockDoorResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterUnlockDoorResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPDoorLockClusterUnlockWithTimeoutResponseCallback
    : public CHIPCallbackWrapper<DoorLockClusterUnlockWithTimeoutResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback,
                        void (*)(CHIPDoorLockClusterUnlockWithTimeoutResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback *>(context),
                        chip::Platform::Delete<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPDoorLockClusterUnlockWithTimeoutResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                         bool keepAlive = false) :
        CHIPCallbackWrapper<DoorLockClusterUnlockWithTimeoutResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPGeneralCommissioningClusterArmFailSafeResponseCallback
    : public CHIPCallbackWrapper<GeneralCommissioningClusterArmFailSafeResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback,
                        void (*)(CHIPGeneralCommissioningClusterArmFailSafeResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback *>(context),
                        chip::Platform::Delete<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());
    }

    CHIPGeneralCommissioningClusterArmFailSafeResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                               bool keepAlive = false) :
        CHIPCallbackWrapper<GeneralCommissioningClusterArmFailSafeResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback
    : public CHIPCallbackWrapper<GeneralCommissioningClusterCommissioningCompleteResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback,
                        void (*)(CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback *>(context),
                        chip::Platform::Delete<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());
    }

    CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                         bool keepAlive = false) :
        CHIPCallbackWrapper<GeneralCommissioningClusterCommissioningCompleteResponseCallback>(javaCallback, action, CallbackFn,
                                                                                              keepAlive){};
};

class CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback
    : public CHIPCallbackWrapper<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback,
                        void (*)(CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback *>(context),
                        chip::Platform::Delete<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());
    }

    CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                       bool keepAlive = false) :
        CHIPCallbackWrapper<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>(javaCallback, action, CallbackFn,
                                                                                            keepAlive){};
};

class CHIPGroupsClusterAddGroupResponseCallback : public CHIPCallbackWrapper<GroupsClusterAddGroupResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, uint16_t groupId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGroupsClusterAddGroupResponseCallback, void (*)(CHIPGroupsClusterAddGroupResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPGroupsClusterAddGroupResponseCallback *>(context),
                        chip::Platform::Delete<CHIPGroupsClusterAddGroupResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId));
    }

    CHIPGroupsClusterAddGroupResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<GroupsClusterAddGroupResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPGroupsClusterGetGroupMembershipResponseCallback
    : public CHIPCallbackWrapper<GroupsClusterGetGroupMembershipResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t capacity, uint8_t groupCount,
                           /* TYPE WARNING: array array defaults to */ uint8_t * groupList)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGroupsClusterGetGroupMembershipResponseCallback,
                        void (*)(CHIPGroupsClusterGetGroupMembershipResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPGroupsClusterGetGroupMembershipResponseCallback *>(context),
                        chip::Platform::Delete<CHIPGroupsClusterGetGroupMembershipResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(capacity), static_cast<jint>(groupCount)
                            // groupList: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );
    }

    CHIPGroupsClusterGetGroupMembershipResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                        bool keepAlive = false) :
        CHIPCallbackWrapper<GroupsClusterGetGroupMembershipResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPGroupsClusterRemoveGroupResponseCallback : public CHIPCallbackWrapper<GroupsClusterRemoveGroupResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, uint16_t groupId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGroupsClusterRemoveGroupResponseCallback, void (*)(CHIPGroupsClusterRemoveGroupResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPGroupsClusterRemoveGroupResponseCallback *>(context),
                        chip::Platform::Delete<CHIPGroupsClusterRemoveGroupResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId));
    }

    CHIPGroupsClusterRemoveGroupResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<GroupsClusterRemoveGroupResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPGroupsClusterViewGroupResponseCallback : public CHIPCallbackWrapper<GroupsClusterViewGroupResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPGroupsClusterViewGroupResponseCallback, void (*)(CHIPGroupsClusterViewGroupResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPGroupsClusterViewGroupResponseCallback *>(context),
                        chip::Platform::Delete<CHIPGroupsClusterViewGroupResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString groupNameStr(env, groupName);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            groupNameStr.jniValue());
    }

    CHIPGroupsClusterViewGroupResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<GroupsClusterViewGroupResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPIdentifyClusterIdentifyQueryResponseCallback : public CHIPCallbackWrapper<IdentifyClusterIdentifyQueryResponseCallback>
{
public:
    static void CallbackFn(void * context, uint16_t timeout)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPIdentifyClusterIdentifyQueryResponseCallback,
                        void (*)(CHIPIdentifyClusterIdentifyQueryResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPIdentifyClusterIdentifyQueryResponseCallback *>(context),
                        chip::Platform::Delete<CHIPIdentifyClusterIdentifyQueryResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(timeout));
    }

    CHIPIdentifyClusterIdentifyQueryResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<IdentifyClusterIdentifyQueryResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPKeypadInputClusterSendKeyResponseCallback : public CHIPCallbackWrapper<KeypadInputClusterSendKeyResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPKeypadInputClusterSendKeyResponseCallback, void (*)(CHIPKeypadInputClusterSendKeyResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPKeypadInputClusterSendKeyResponseCallback *>(context),
                        chip::Platform::Delete<CHIPKeypadInputClusterSendKeyResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));
    }

    CHIPKeypadInputClusterSendKeyResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<KeypadInputClusterSendKeyResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaFastForwardResponseCallback
    : public CHIPCallbackWrapper<MediaPlaybackClusterMediaFastForwardResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaFastForwardResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaFastForwardResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                             bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaFastForwardResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaNextResponseCallback : public CHIPCallbackWrapper<MediaPlaybackClusterMediaNextResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaNextResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaNextResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaNextResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaNextResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaNextResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaNextResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaPauseResponseCallback
    : public CHIPCallbackWrapper<MediaPlaybackClusterMediaPauseResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaPauseResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaPauseResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaPauseResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaPauseResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaPauseResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaPauseResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaPlayResponseCallback : public CHIPCallbackWrapper<MediaPlaybackClusterMediaPlayResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaPlayResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaPlayResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaPlayResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaPlayResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaPlayResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaPlayResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaPreviousResponseCallback
    : public CHIPCallbackWrapper<MediaPlaybackClusterMediaPreviousResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaPreviousResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaPreviousResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaPreviousResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaPreviousResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaPreviousResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                          bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaPreviousResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaRewindResponseCallback
    : public CHIPCallbackWrapper<MediaPlaybackClusterMediaRewindResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaRewindResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaRewindResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaRewindResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaRewindResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaRewindResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                        bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaRewindResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaSeekResponseCallback : public CHIPCallbackWrapper<MediaPlaybackClusterMediaSeekResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaSeekResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaSeekResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaSeekResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaSeekResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaSeekResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaSeekResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback
    : public CHIPCallbackWrapper<MediaPlaybackClusterMediaSkipBackwardResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                              bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaSkipBackwardResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback
    : public CHIPCallbackWrapper<MediaPlaybackClusterMediaSkipForwardResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                             bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaSkipForwardResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaStartOverResponseCallback
    : public CHIPCallbackWrapper<MediaPlaybackClusterMediaStartOverResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaStartOverResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaStartOverResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaStartOverResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaStartOverResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaStartOverResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                           bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaStartOverResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPMediaPlaybackClusterMediaStopResponseCallback : public CHIPCallbackWrapper<MediaPlaybackClusterMediaStopResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPMediaPlaybackClusterMediaStopResponseCallback,
                        void (*)(CHIPMediaPlaybackClusterMediaStopResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPMediaPlaybackClusterMediaStopResponseCallback *>(context),
                        chip::Platform::Delete<CHIPMediaPlaybackClusterMediaStopResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));
    }

    CHIPMediaPlaybackClusterMediaStopResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<MediaPlaybackClusterMediaStopResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback
    : public CHIPCallbackWrapper<NetworkCommissioningClusterAddThreadNetworkResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback,
                        void (*)(CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback *>(context),
                        chip::Platform::Delete<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());
    }

    CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                    bool keepAlive = false) :
        CHIPCallbackWrapper<NetworkCommissioningClusterAddThreadNetworkResponseCallback>(javaCallback, action, CallbackFn,
                                                                                         keepAlive){};
};

class CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback
    : public CHIPCallbackWrapper<NetworkCommissioningClusterAddWiFiNetworkResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback,
                        void (*)(CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback *>(context),
                        chip::Platform::Delete<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());
    }

    CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                  bool keepAlive = false) :
        CHIPCallbackWrapper<NetworkCommissioningClusterAddWiFiNetworkResponseCallback>(javaCallback, action, CallbackFn,
                                                                                       keepAlive){};
};

class CHIPNetworkCommissioningClusterDisableNetworkResponseCallback
    : public CHIPCallbackWrapper<NetworkCommissioningClusterDisableNetworkResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback,
                        void (*)(CHIPNetworkCommissioningClusterDisableNetworkResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback *>(context),
                        chip::Platform::Delete<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());
    }

    CHIPNetworkCommissioningClusterDisableNetworkResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                  bool keepAlive = false) :
        CHIPCallbackWrapper<NetworkCommissioningClusterDisableNetworkResponseCallback>(javaCallback, action, CallbackFn,
                                                                                       keepAlive){};
};

class CHIPNetworkCommissioningClusterEnableNetworkResponseCallback
    : public CHIPCallbackWrapper<NetworkCommissioningClusterEnableNetworkResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback,
                        void (*)(CHIPNetworkCommissioningClusterEnableNetworkResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback *>(context),
                        chip::Platform::Delete<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());
    }

    CHIPNetworkCommissioningClusterEnableNetworkResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                 bool keepAlive = false) :
        CHIPCallbackWrapper<NetworkCommissioningClusterEnableNetworkResponseCallback>(javaCallback, action, CallbackFn,
                                                                                      keepAlive){};
};

class CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback
    : public CHIPCallbackWrapper<NetworkCommissioningClusterRemoveNetworkResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback,
                        void (*)(CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback *>(context),
                        chip::Platform::Delete<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());
    }

    CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                 bool keepAlive = false) :
        CHIPCallbackWrapper<NetworkCommissioningClusterRemoveNetworkResponseCallback>(javaCallback, action, CallbackFn,
                                                                                      keepAlive){};
};

class CHIPNetworkCommissioningClusterScanNetworksResponseCallback
    : public CHIPCallbackWrapper<NetworkCommissioningClusterScanNetworksResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText,
                           /* TYPE WARNING: array array defaults to */ uint8_t * wifiScanResults,
                           /* TYPE WARNING: array array defaults to */ uint8_t * threadScanResults)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPNetworkCommissioningClusterScanNetworksResponseCallback,
                        void (*)(CHIPNetworkCommissioningClusterScanNetworksResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPNetworkCommissioningClusterScanNetworksResponseCallback *>(context),
                        chip::Platform::Delete<CHIPNetworkCommissioningClusterScanNetworksResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue()
                            // wifiScanResults: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
                            // threadScanResults: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );
    }

    CHIPNetworkCommissioningClusterScanNetworksResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                bool keepAlive = false) :
        CHIPCallbackWrapper<NetworkCommissioningClusterScanNetworksResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback
    : public CHIPCallbackWrapper<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback,
                        void (*)(CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback *>(context),
                        chip::Platform::Delete<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());
    }

    CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                       bool keepAlive = false) :
        CHIPCallbackWrapper<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback>(javaCallback, action, CallbackFn,
                                                                                            keepAlive){};
};

class CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback
    : public CHIPCallbackWrapper<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback,
                        void (*)(CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback *>(context),
                        chip::Platform::Delete<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString debugTextStr(env, debugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());
    }

    CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                     bool keepAlive = false) :
        CHIPCallbackWrapper<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>(javaCallback, action, CallbackFn,
                                                                                          keepAlive){};
};

class CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback
    : public CHIPCallbackWrapper<OtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t action, uint32_t delayedActionTime)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback,
                        void (*)(CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback *>(context),
                        chip::Platform::Delete<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IJ)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(action), static_cast<jlong>(delayedActionTime));
    }

    CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                    bool keepAlive = false) :
        CHIPCallbackWrapper<OtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>(javaCallback, action, CallbackFn,
                                                                                         keepAlive){};
};

class CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback
    : public CHIPCallbackWrapper<OtaSoftwareUpdateProviderClusterQueryImageResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, uint32_t delayedActionTime, chip::CharSpan imageURI,
                           uint32_t softwareVersion, chip::CharSpan softwareVersionString, chip::ByteSpan updateToken,
                           bool userConsentNeeded, chip::ByteSpan metadataForRequestor)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback,
                        void (*)(CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback *>(context),
                        chip::Platform::Delete<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess",
                                                      "(IJLjava/lang/String;JLjava/lang/String;[BZ[B)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString imageURIStr(env, imageURI);
        UtfString softwareVersionStringStr(env, softwareVersionString);
        jbyteArray updateTokenArr = env->NewByteArray(updateToken.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(updateTokenArr, 0, updateToken.size(), reinterpret_cast<const jbyte *>(updateToken.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));
        jbyteArray metadataForRequestorArr = env->NewByteArray(metadataForRequestor.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(metadataForRequestorArr, 0, metadataForRequestor.size(),
                                reinterpret_cast<const jbyte *>(metadataForRequestor.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jlong>(delayedActionTime),
                            imageURIStr.jniValue(), static_cast<jlong>(softwareVersion), softwareVersionStringStr.jniValue(),
                            updateTokenArr, static_cast<jboolean>(userConsentNeeded), metadataForRequestorArr);

        env->DeleteLocalRef(updateTokenArr);
        env->DeleteLocalRef(metadataForRequestorArr);
    }

    CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                   bool keepAlive = false) :
        CHIPCallbackWrapper<OtaSoftwareUpdateProviderClusterQueryImageResponseCallback>(javaCallback, action, CallbackFn,
                                                                                        keepAlive){};
};

class CHIPOperationalCredentialsClusterAttestationResponseCallback
    : public CHIPCallbackWrapper<OperationalCredentialsClusterAttestationResponseCallback>
{
public:
    static void CallbackFn(void * context, chip::ByteSpan AttestationElements, chip::ByteSpan Signature)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPOperationalCredentialsClusterAttestationResponseCallback,
                        void (*)(CHIPOperationalCredentialsClusterAttestationResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPOperationalCredentialsClusterAttestationResponseCallback *>(context),
                        chip::Platform::Delete<CHIPOperationalCredentialsClusterAttestationResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "([B[B)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        jbyteArray AttestationElementsArr = env->NewByteArray(AttestationElements.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(AttestationElementsArr, 0, AttestationElements.size(),
                                reinterpret_cast<const jbyte *>(AttestationElements.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));
        jbyteArray SignatureArr = env->NewByteArray(Signature.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(SignatureArr, 0, Signature.size(), reinterpret_cast<const jbyte *>(Signature.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, AttestationElementsArr, SignatureArr);

        env->DeleteLocalRef(AttestationElementsArr);
        env->DeleteLocalRef(SignatureArr);
    }

    CHIPOperationalCredentialsClusterAttestationResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                 bool keepAlive = false) :
        CHIPCallbackWrapper<OperationalCredentialsClusterAttestationResponseCallback>(javaCallback, action, CallbackFn,
                                                                                      keepAlive){};
};

class CHIPOperationalCredentialsClusterCertificateChainResponseCallback
    : public CHIPCallbackWrapper<OperationalCredentialsClusterCertificateChainResponseCallback>
{
public:
    static void CallbackFn(void * context, chip::ByteSpan Certificate)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPOperationalCredentialsClusterCertificateChainResponseCallback,
                        void (*)(CHIPOperationalCredentialsClusterCertificateChainResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPOperationalCredentialsClusterCertificateChainResponseCallback *>(context),
                        chip::Platform::Delete<CHIPOperationalCredentialsClusterCertificateChainResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "([B)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        jbyteArray CertificateArr = env->NewByteArray(Certificate.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(CertificateArr, 0, Certificate.size(), reinterpret_cast<const jbyte *>(Certificate.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, CertificateArr);

        env->DeleteLocalRef(CertificateArr);
    }

    CHIPOperationalCredentialsClusterCertificateChainResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                                      bool keepAlive = false) :
        CHIPCallbackWrapper<OperationalCredentialsClusterCertificateChainResponseCallback>(javaCallback, action, CallbackFn,
                                                                                           keepAlive){};
};

class CHIPOperationalCredentialsClusterNOCResponseCallback
    : public CHIPCallbackWrapper<OperationalCredentialsClusterNOCResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t StatusCode, uint8_t FabricIndex, chip::CharSpan DebugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                        void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPOperationalCredentialsClusterNOCResponseCallback *>(context),
                        chip::Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString DebugTextStr(env, DebugText);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(StatusCode), static_cast<jint>(FabricIndex),
                            DebugTextStr.jniValue());
    }

    CHIPOperationalCredentialsClusterNOCResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                         bool keepAlive = false) :
        CHIPCallbackWrapper<OperationalCredentialsClusterNOCResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPOperationalCredentialsClusterOpCSRResponseCallback
    : public CHIPCallbackWrapper<OperationalCredentialsClusterOpCSRResponseCallback>
{
public:
    static void CallbackFn(void * context, chip::ByteSpan NOCSRElements, chip::ByteSpan AttestationSignature)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPOperationalCredentialsClusterOpCSRResponseCallback,
                        void (*)(CHIPOperationalCredentialsClusterOpCSRResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPOperationalCredentialsClusterOpCSRResponseCallback *>(context),
                        chip::Platform::Delete<CHIPOperationalCredentialsClusterOpCSRResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "([B[B)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        jbyteArray NOCSRElementsArr = env->NewByteArray(NOCSRElements.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(NOCSRElementsArr, 0, NOCSRElements.size(), reinterpret_cast<const jbyte *>(NOCSRElements.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));
        jbyteArray AttestationSignatureArr = env->NewByteArray(AttestationSignature.size());
        env->ExceptionClear();
        env->SetByteArrayRegion(AttestationSignatureArr, 0, AttestationSignature.size(),
                                reinterpret_cast<const jbyte *>(AttestationSignature.data()));
        VerifyOrReturn(!env->ExceptionCheck(), ChipLogError(Zcl, "JNI exception setting byte array region"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, NOCSRElementsArr, AttestationSignatureArr);

        env->DeleteLocalRef(NOCSRElementsArr);
        env->DeleteLocalRef(AttestationSignatureArr);
    }

    CHIPOperationalCredentialsClusterOpCSRResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                           bool keepAlive = false) :
        CHIPCallbackWrapper<OperationalCredentialsClusterOpCSRResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPScenesClusterAddSceneResponseCallback : public CHIPCallbackWrapper<ScenesClusterAddSceneResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPScenesClusterAddSceneResponseCallback, void (*)(CHIPScenesClusterAddSceneResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPScenesClusterAddSceneResponseCallback *>(context),
                        chip::Platform::Delete<CHIPScenesClusterAddSceneResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId));
    }

    CHIPScenesClusterAddSceneResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<ScenesClusterAddSceneResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPScenesClusterGetSceneMembershipResponseCallback
    : public CHIPCallbackWrapper<ScenesClusterGetSceneMembershipResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, uint8_t capacity, uint16_t groupId, uint8_t sceneCount,
                           /* TYPE WARNING: array array defaults to */ uint8_t * sceneList)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPScenesClusterGetSceneMembershipResponseCallback,
                        void (*)(CHIPScenesClusterGetSceneMembershipResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPScenesClusterGetSceneMembershipResponseCallback *>(context),
                        chip::Platform::Delete<CHIPScenesClusterGetSceneMembershipResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIII)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(capacity),
                            static_cast<jint>(groupId), static_cast<jint>(sceneCount)
                            // sceneList: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );
    }

    CHIPScenesClusterGetSceneMembershipResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                        bool keepAlive = false) :
        CHIPCallbackWrapper<ScenesClusterGetSceneMembershipResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPScenesClusterRemoveAllScenesResponseCallback : public CHIPCallbackWrapper<ScenesClusterRemoveAllScenesResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, uint16_t groupId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPScenesClusterRemoveAllScenesResponseCallback,
                        void (*)(CHIPScenesClusterRemoveAllScenesResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPScenesClusterRemoveAllScenesResponseCallback *>(context),
                        chip::Platform::Delete<CHIPScenesClusterRemoveAllScenesResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId));
    }

    CHIPScenesClusterRemoveAllScenesResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<ScenesClusterRemoveAllScenesResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPScenesClusterRemoveSceneResponseCallback : public CHIPCallbackWrapper<ScenesClusterRemoveSceneResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPScenesClusterRemoveSceneResponseCallback, void (*)(CHIPScenesClusterRemoveSceneResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPScenesClusterRemoveSceneResponseCallback *>(context),
                        chip::Platform::Delete<CHIPScenesClusterRemoveSceneResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId));
    }

    CHIPScenesClusterRemoveSceneResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<ScenesClusterRemoveSceneResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPScenesClusterStoreSceneResponseCallback : public CHIPCallbackWrapper<ScenesClusterStoreSceneResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPScenesClusterStoreSceneResponseCallback, void (*)(CHIPScenesClusterStoreSceneResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPScenesClusterStoreSceneResponseCallback *>(context),
                        chip::Platform::Delete<CHIPScenesClusterStoreSceneResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId));
    }

    CHIPScenesClusterStoreSceneResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<ScenesClusterStoreSceneResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPScenesClusterViewSceneResponseCallback : public CHIPCallbackWrapper<ScenesClusterViewSceneResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId, uint16_t transitionTime,
                           chip::CharSpan sceneName, /* TYPE WARNING: array array defaults to */ uint8_t * extensionFieldSets)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPScenesClusterViewSceneResponseCallback, void (*)(CHIPScenesClusterViewSceneResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPScenesClusterViewSceneResponseCallback *>(context),
                        chip::Platform::Delete<CHIPScenesClusterViewSceneResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIIILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString sceneNameStr(env, sceneName);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId), static_cast<jint>(transitionTime), sceneNameStr.jniValue()
                            // extensionFieldSets: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );
    }

    CHIPScenesClusterViewSceneResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<ScenesClusterViewSceneResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPTvChannelClusterChangeChannelResponseCallback : public CHIPCallbackWrapper<TvChannelClusterChangeChannelResponseCallback>
{
public:
    static void CallbackFn(void * context, /* TYPE WARNING: array array defaults to */ uint8_t * ChannelMatch, uint8_t ErrorType)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTvChannelClusterChangeChannelResponseCallback,
                        void (*)(CHIPTvChannelClusterChangeChannelResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPTvChannelClusterChangeChannelResponseCallback *>(context),
                        chip::Platform::Delete<CHIPTvChannelClusterChangeChannelResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef,
                            javaMethod
                            // ChannelMatch: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
                            ,
                            static_cast<jint>(ErrorType));
    }

    CHIPTvChannelClusterChangeChannelResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<TvChannelClusterChangeChannelResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPTargetNavigatorClusterNavigateTargetResponseCallback
    : public CHIPCallbackWrapper<TargetNavigatorClusterNavigateTargetResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t status, chip::CharSpan data)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTargetNavigatorClusterNavigateTargetResponseCallback,
                        void (*)(CHIPTargetNavigatorClusterNavigateTargetResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPTargetNavigatorClusterNavigateTargetResponseCallback *>(context),
                        chip::Platform::Delete<CHIPTargetNavigatorClusterNavigateTargetResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        UtfString dataStr(env, data);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), dataStr.jniValue());
    }

    CHIPTargetNavigatorClusterNavigateTargetResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                             bool keepAlive = false) :
        CHIPCallbackWrapper<TargetNavigatorClusterNavigateTargetResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPTestClusterClusterBooleanResponseCallback : public CHIPCallbackWrapper<TestClusterClusterBooleanResponseCallback>
{
public:
    static void CallbackFn(void * context, bool value)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPTestClusterClusterBooleanResponseCallback *>(context),
                        chip::Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Z)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jboolean>(value));
    }

    CHIPTestClusterClusterBooleanResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<TestClusterClusterBooleanResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPTestClusterClusterTestAddArgumentsResponseCallback
    : public CHIPCallbackWrapper<TestClusterClusterTestAddArgumentsResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t returnValue)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTestClusterClusterTestAddArgumentsResponseCallback,
                        void (*)(CHIPTestClusterClusterTestAddArgumentsResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPTestClusterClusterTestAddArgumentsResponseCallback *>(context),
                        chip::Platform::Delete<CHIPTestClusterClusterTestAddArgumentsResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(returnValue));
    }

    CHIPTestClusterClusterTestAddArgumentsResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                           bool keepAlive = false) :
        CHIPCallbackWrapper<TestClusterClusterTestAddArgumentsResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPTestClusterClusterTestEnumsResponseCallback : public CHIPCallbackWrapper<TestClusterClusterTestEnumsResponseCallback>
{
public:
    static void CallbackFn(void * context, chip::VendorId arg1, uint8_t arg2)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTestClusterClusterTestEnumsResponseCallback,
                        void (*)(CHIPTestClusterClusterTestEnumsResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPTestClusterClusterTestEnumsResponseCallback *>(context),
                        chip::Platform::Delete<CHIPTestClusterClusterTestEnumsResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(arg1), static_cast<jint>(arg2));
    }

    CHIPTestClusterClusterTestEnumsResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<TestClusterClusterTestEnumsResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPTestClusterClusterTestListInt8UReverseResponseCallback
    : public CHIPCallbackWrapper<TestClusterClusterTestListInt8UReverseResponseCallback>
{
public:
    static void CallbackFn(void * context, /* TYPE WARNING: array array defaults to */ uint8_t * arg1)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTestClusterClusterTestListInt8UReverseResponseCallback,
                        void (*)(CHIPTestClusterClusterTestListInt8UReverseResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPTestClusterClusterTestListInt8UReverseResponseCallback *>(context),
                        chip::Platform::Delete<CHIPTestClusterClusterTestListInt8UReverseResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod
                            // arg1: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );
    }

    CHIPTestClusterClusterTestListInt8UReverseResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                               bool keepAlive = false) :
        CHIPCallbackWrapper<TestClusterClusterTestListInt8UReverseResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPTestClusterClusterTestNullableOptionalResponseCallback
    : public CHIPCallbackWrapper<TestClusterClusterTestNullableOptionalResponseCallback>
{
public:
    static void CallbackFn(void * context, bool wasPresent, bool wasNull, uint8_t value, uint8_t originalValue)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTestClusterClusterTestNullableOptionalResponseCallback,
                        void (*)(CHIPTestClusterClusterTestNullableOptionalResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPTestClusterClusterTestNullableOptionalResponseCallback *>(context),
                        chip::Platform::Delete<CHIPTestClusterClusterTestNullableOptionalResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ZZII)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jboolean>(wasPresent), static_cast<jboolean>(wasNull),
                            static_cast<jint>(value), static_cast<jint>(originalValue));
    }

    CHIPTestClusterClusterTestNullableOptionalResponseCallback(jobject javaCallback, chip::CHIPActionBlock action,
                                                               bool keepAlive = false) :
        CHIPCallbackWrapper<TestClusterClusterTestNullableOptionalResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

class CHIPTestClusterClusterTestSpecificResponseCallback
    : public CHIPCallbackWrapper<TestClusterClusterTestSpecificResponseCallback>
{
public:
    static void CallbackFn(void * context, uint8_t returnValue)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;

        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

        std::unique_ptr<CHIPTestClusterClusterTestSpecificResponseCallback,
                        void (*)(CHIPTestClusterClusterTestSpecificResponseCallback *)>
            cppCallback(reinterpret_cast<CHIPTestClusterClusterTestSpecificResponseCallback *>(context),
                        chip::Platform::Delete<CHIPTestClusterClusterTestSpecificResponseCallback>);
        VerifyOrReturn(cppCallback.get() != nullptr, ChipLogProgress(Zcl, "Unable to cast context to callback object"));

        jobject javaCallbackRef = cppCallback->JavaCallback();
        VerifyOrReturn(javaCallbackRef != nullptr,
                       ChipLogDetail(Zcl, "Early return from command callback since Java callback is null"));

        jmethodID javaMethod;
        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method for command response"));

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(returnValue));
    }

    CHIPTestClusterClusterTestSpecificResponseCallback(jobject javaCallback, chip::CHIPActionBlock action, bool keepAlive = false) :
        CHIPCallbackWrapper<TestClusterClusterTestSpecificResponseCallback>(javaCallback, action, CallbackFn, keepAlive){};
};

JNI_METHOD(void, BaseChipCluster, deleteCluster)(JNIEnv * env, jobject self, jlong clusterPtr)
{
    chip::DeviceLayer::StackLock lock;
    ClusterBase * cluster = reinterpret_cast<ClusterBase *>(clusterPtr);
    if (cluster != nullptr)
    {
        delete cluster;
    }
}

JNI_METHOD(jlong, AccountLoginCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AccountLoginCluster * cppCluster = new AccountLoginCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AccountLoginCluster, getSetupPIN)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier)
{
    chip::DeviceLayer::StackLock lock;
    AccountLoginCluster * cppCluster;

    JniUtfString * tempAccountIdentifierStr = new JniUtfString(env, tempAccountIdentifier);

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, tempAccountIdentifierStr](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetSetupPIN(
            success, failure, chip::CharSpan(tempAccountIdentifierStr->c_str(), strlen(tempAccountIdentifierStr->c_str())));
        delete tempAccountIdentifierStr;
        return err;
    };

    std::unique_ptr<CHIPAccountLoginClusterGetSetupPINResponseCallback,
                    void (*)(CHIPAccountLoginClusterGetSetupPINResponseCallback *)>
        commandCallback(Platform::New<CHIPAccountLoginClusterGetSetupPINResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPAccountLoginClusterGetSetupPINResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, AccountLoginCluster, login)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier, jstring setupPIN)
{
    chip::DeviceLayer::StackLock lock;
    AccountLoginCluster * cppCluster;

    JniUtfString * tempAccountIdentifierStr = new JniUtfString(env, tempAccountIdentifier);
    JniUtfString * setupPINStr              = new JniUtfString(env, setupPIN);

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, tempAccountIdentifierStr, setupPINStr](chip::Callback::Cancelable * success,
                                                                                            chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Login(
            success, failure, chip::CharSpan(tempAccountIdentifierStr->c_str(), strlen(tempAccountIdentifierStr->c_str())),
            chip::CharSpan(setupPINStr->c_str(), strlen(setupPINStr->c_str())));
        delete tempAccountIdentifierStr;
        delete setupPINStr;
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, AdministratorCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AdministratorCommissioningCluster * cppCluster = new AdministratorCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AdministratorCommissioningCluster, openBasicCommissioningWindow)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint commissioningTimeout)
{
    chip::DeviceLayer::StackLock lock;
    AdministratorCommissioningCluster * cppCluster;

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, commissioningTimeout](chip::Callback::Cancelable * success,
                                                                           chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->OpenBasicCommissioningWindow(success, failure, commissioningTimeout);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, AdministratorCommissioningCluster, openCommissioningWindow)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint commissioningTimeout, jbyteArray PAKEVerifier,
 jint discriminator, jlong iterations, jbyteArray salt, jint passcodeID)
{
    chip::DeviceLayer::StackLock lock;
    AdministratorCommissioningCluster * cppCluster;

    JniByteArray * PAKEVerifierArr = new JniByteArray(env, PAKEVerifier);
    JniByteArray * saltArr         = new JniByteArray(env, salt);

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, commissioningTimeout, PAKEVerifierArr, discriminator, iterations, saltArr,
                                         passcodeID](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->OpenCommissioningWindow(
            success, failure, commissioningTimeout,
            chip::ByteSpan((const uint8_t *) PAKEVerifierArr->data(), PAKEVerifierArr->size()), discriminator, iterations,
            chip::ByteSpan((const uint8_t *) saltArr->data(), saltArr->size()), passcodeID);
        delete PAKEVerifierArr;
        delete saltArr;
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, AdministratorCommissioningCluster, revokeCommissioning)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    AdministratorCommissioningCluster * cppCluster;

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->RevokeCommissioning(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, ApplicationBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ApplicationBasicCluster * cppCluster = new ApplicationBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationBasicCluster, changeStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint status)
{
    chip::DeviceLayer::StackLock lock;
    ApplicationBasicCluster * cppCluster;

    cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, status](chip::Callback::Cancelable * success,
                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ChangeStatus(success, failure, static_cast<uint8_t>(status));
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, ApplicationLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ApplicationLauncherCluster * cppCluster = new ApplicationLauncherCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationLauncherCluster, launchApp)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring data, jint catalogVendorId, jstring applicationId)
{
    chip::DeviceLayer::StackLock lock;
    ApplicationLauncherCluster * cppCluster;

    JniUtfString * dataStr          = new JniUtfString(env, data);
    JniUtfString * applicationIdStr = new JniUtfString(env, applicationId);

    cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, dataStr, catalogVendorId, applicationIdStr](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->LaunchApp(success, failure, chip::CharSpan(dataStr->c_str(), strlen(dataStr->c_str())), catalogVendorId,
                                  chip::CharSpan(applicationIdStr->c_str(), strlen(applicationIdStr->c_str())));
        delete dataStr;
        delete applicationIdStr;
        return err;
    };

    std::unique_ptr<CHIPApplicationLauncherClusterLaunchAppResponseCallback,
                    void (*)(CHIPApplicationLauncherClusterLaunchAppResponseCallback *)>
        commandCallback(Platform::New<CHIPApplicationLauncherClusterLaunchAppResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPApplicationLauncherClusterLaunchAppResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, AudioOutputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AudioOutputCluster * cppCluster = new AudioOutputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AudioOutputCluster, renameOutput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index, jstring name)
{
    chip::DeviceLayer::StackLock lock;
    AudioOutputCluster * cppCluster;

    JniUtfString * nameStr = new JniUtfString(env, name);

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, index, nameStr](chip::Callback::Cancelable * success,
                                                                     chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->RenameOutput(success, failure, index, chip::CharSpan(nameStr->c_str(), strlen(nameStr->c_str())));
        delete nameStr;
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, AudioOutputCluster, selectOutput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index)
{
    chip::DeviceLayer::StackLock lock;
    AudioOutputCluster * cppCluster;

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, index](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->SelectOutput(success, failure, index);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, BarrierControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BarrierControlCluster * cppCluster = new BarrierControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BarrierControlCluster, barrierControlGoToPercent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint percentOpen)
{
    chip::DeviceLayer::StackLock lock;
    BarrierControlCluster * cppCluster;

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, percentOpen](chip::Callback::Cancelable * success,
                                                                  chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->BarrierControlGoToPercent(success, failure, percentOpen);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BarrierControlCluster, barrierControlStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    BarrierControlCluster * cppCluster;

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->BarrierControlStop(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, BasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BasicCluster * cppCluster = new BasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BasicCluster, mfgSpecificPing)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    BasicCluster * cppCluster;

    cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MfgSpecificPing(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, BasicCluster, writeUserLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;

    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value, env](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        JniUtfString valueStr(env, value);
        return cppCluster->WriteAttributeUserLabel(success, failure, chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, BasicCluster, writeLocationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;

    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value, env](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        JniUtfString valueStr(env, value);
        return cppCluster->WriteAttributeLocation(success, failure, chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, BasicCluster, writeLocalConfigDisabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;

    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeLocalConfigDisabled(success, failure, static_cast<bool>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, BinaryInputBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BinaryInputBasicCluster * cppCluster = new BinaryInputBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BinaryInputBasicCluster, writeOutOfServiceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;

    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOutOfService(success, failure, static_cast<bool>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, writePresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;

    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributePresentValue(success, failure, static_cast<bool>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, subscribePresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributePresentValue(success, failure, static_cast<uint16_t>(minInterval),
                                                          static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, reportPresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributePresentValue(success);
    };

    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, subscribeStatusFlagsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeStatusFlags(success, failure, static_cast<uint16_t>(minInterval),
                                                         static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, reportStatusFlagsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeStatusFlags(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}
JNI_METHOD(jlong, BindingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BindingCluster * cppCluster = new BindingCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BindingCluster, bind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong nodeId, jint groupId, jint endpointId, jlong clusterId)
{
    chip::DeviceLayer::StackLock lock;
    BindingCluster * cppCluster;

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, nodeId, groupId, endpointId, clusterId](chip::Callback::Cancelable * success,
                                                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Bind(success, failure, nodeId, groupId, endpointId, clusterId);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BindingCluster, unbind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong nodeId, jint groupId, jint endpointId, jlong clusterId)
{
    chip::DeviceLayer::StackLock lock;
    BindingCluster * cppCluster;

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, nodeId, groupId, endpointId, clusterId](chip::Callback::Cancelable * success,
                                                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Unbind(success, failure, nodeId, groupId, endpointId, clusterId);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, BooleanStateCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BooleanStateCluster * cppCluster = new BooleanStateCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BooleanStateCluster, subscribeStateValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    BooleanStateCluster * cppCluster = reinterpret_cast<BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeStateValue(success, failure, static_cast<uint16_t>(minInterval),
                                                        static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, BooleanStateCluster, reportStateValueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    BooleanStateCluster * cppCluster = reinterpret_cast<BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeStateValue(success);
    };

    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}
JNI_METHOD(jlong, BridgedActionsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster = new BridgedActionsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BridgedActionsCluster, disableAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->DisableAction(success, failure, actionID, invokeID);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, disableActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID, jlong duration)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID, duration](chip::Callback::Cancelable * success,
                                                                                   chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->DisableActionWithDuration(success, failure, actionID, invokeID, duration);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, enableAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->EnableAction(success, failure, actionID, invokeID);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, enableActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID, jlong duration)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID, duration](chip::Callback::Cancelable * success,
                                                                                   chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->EnableActionWithDuration(success, failure, actionID, invokeID, duration);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, instantAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->InstantAction(success, failure, actionID, invokeID);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, instantActionWithTransition)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID, jint transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID, transitionTime](chip::Callback::Cancelable * success,
                                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->InstantActionWithTransition(success, failure, actionID, invokeID, transitionTime);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, pauseAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->PauseAction(success, failure, actionID, invokeID);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, pauseActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID, jlong duration)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID, duration](chip::Callback::Cancelable * success,
                                                                                   chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->PauseActionWithDuration(success, failure, actionID, invokeID, duration);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, resumeAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ResumeAction(success, failure, actionID, invokeID);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, startAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StartAction(success, failure, actionID, invokeID);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, startActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID, jlong duration)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID, duration](chip::Callback::Cancelable * success,
                                                                                   chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StartActionWithDuration(success, failure, actionID, invokeID, duration);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, BridgedActionsCluster, stopAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster;

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, actionID, invokeID](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StopAction(success, failure, actionID, invokeID);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, BridgedDeviceBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BridgedDeviceBasicCluster * cppCluster = new BridgedDeviceBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BridgedDeviceBasicCluster, writeUserLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;

    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value, env](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        JniUtfString valueStr(env, value);
        return cppCluster->WriteAttributeUserLabel(success, failure, chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, ColorControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster = new ColorControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ColorControlCluster, colorLoopSet)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint updateFlags, jint action, jint direction, jint time,
 jint startHue, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, updateFlags, action, direction, time, startHue, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ColorLoopSet(success, failure, updateFlags, static_cast<uint8_t>(action),
                                                  static_cast<uint8_t>(direction), time, startHue, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, moveMode, rate, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->EnhancedMoveHue(success, failure, static_cast<uint8_t>(moveMode), rate, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint enhancedHue, jint direction, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, enhancedHue, direction, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->EnhancedMoveToHue(success, failure, enhancedHue, static_cast<uint8_t>(direction),
                                                       transitionTime, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint enhancedHue, jint saturation, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, enhancedHue, saturation, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->EnhancedMoveToHueAndSaturation(success, failure, enhancedHue, saturation, transitionTime,
                                                                    optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedStepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, stepMode, stepSize, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->EnhancedStepHue(success, failure, static_cast<uint8_t>(stepMode), stepSize, transitionTime,
                                                     optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, moveColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint rateX, jint rateY, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, rateX, rateY, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MoveColor(success, failure, rateX, rateY, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, moveColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint colorTemperatureMinimum,
 jint colorTemperatureMaximum, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, moveMode, rate, colorTemperatureMinimum, colorTemperatureMaximum, optionsMask,
                                         optionsOverride](chip::Callback::Cancelable * success,
                                                          chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->MoveColorTemperature(success, failure, static_cast<uint8_t>(moveMode), rate, colorTemperatureMinimum,
                                             colorTemperatureMaximum, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, moveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, moveMode, rate, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MoveHue(success, failure, static_cast<uint8_t>(moveMode), rate, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, moveSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, moveMode, rate, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->MoveSaturation(success, failure, static_cast<uint8_t>(moveMode), rate, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, moveToColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint colorX, jint colorY, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, colorX, colorY, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MoveToColor(success, failure, colorX, colorY, transitionTime, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, moveToColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint colorTemperature, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, colorTemperature, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->MoveToColorTemperature(success, failure, colorTemperature, transitionTime, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, moveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint hue, jint direction, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, hue, direction, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MoveToHue(success, failure, hue, static_cast<uint8_t>(direction), transitionTime, optionsMask,
                                               optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, moveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint hue, jint saturation, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, hue, saturation, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->MoveToHueAndSaturation(success, failure, hue, saturation, transitionTime, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, moveToSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint saturation, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, saturation, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MoveToSaturation(success, failure, saturation, transitionTime, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, stepColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepX, jint stepY, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, stepX, stepY, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StepColor(success, failure, stepX, stepY, transitionTime, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, stepColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint colorTemperatureMinimum, jint colorTemperatureMaximum, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock =
        [cppCluster, stepMode, stepSize, transitionTime, colorTemperatureMinimum, colorTemperatureMaximum, optionsMask,
         optionsOverride](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
            CHIP_ERROR err =
                cppCluster->StepColorTemperature(success, failure, static_cast<uint8_t>(stepMode), stepSize, transitionTime,
                                                 colorTemperatureMinimum, colorTemperatureMaximum, optionsMask, optionsOverride);
            return err;
        };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, stepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, stepMode, stepSize, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StepHue(success, failure, static_cast<uint8_t>(stepMode), stepSize, transitionTime,
                                             optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, stepSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, stepMode, stepSize, transitionTime, optionsMask, optionsOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StepSaturation(success, failure, static_cast<uint8_t>(stepMode), stepSize, transitionTime,
                                                    optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ColorControlCluster, stopMoveStep)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, optionsMask, optionsOverride](chip::Callback::Cancelable * success,
                                                                                   chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StopMoveStep(success, failure, optionsMask, optionsOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentHue(success, failure, static_cast<uint16_t>(minInterval),
                                                        static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentHueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentHue(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentSaturationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentSaturation(success, failure, static_cast<uint16_t>(minInterval),
                                                               static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentSaturationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentSaturation(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentX(success, failure, static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentX(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentY(success, failure, static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentY(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeColorTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeColorTemperature(success, failure, static_cast<uint16_t>(minInterval),
                                                              static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeColorTemperature(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorControlOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeColorControlOptions(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeWhitePointX(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeWhitePointY(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeColorPointRX(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeColorPointRY(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeColorPointRIntensity(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeColorPointGX(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeColorPointGY(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeColorPointGIntensity(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeColorPointBX(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeColorPointBY(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeColorPointBIntensity(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ColorControlCluster, writeStartUpColorTemperatureMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeStartUpColorTemperatureMireds(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, ContentLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ContentLauncherCluster * cppCluster = new ContentLauncherCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ContentLauncherCluster, launchContent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean autoPlay, jstring data)
{
    chip::DeviceLayer::StackLock lock;
    ContentLauncherCluster * cppCluster;

    JniUtfString * dataStr = new JniUtfString(env, data);

    cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, autoPlay, dataStr](chip::Callback::Cancelable * success,
                                                                        chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->LaunchContent(success, failure, autoPlay, chip::CharSpan(dataStr->c_str(), strlen(dataStr->c_str())));
        delete dataStr;
        return err;
    };

    std::unique_ptr<CHIPContentLauncherClusterLaunchContentResponseCallback,
                    void (*)(CHIPContentLauncherClusterLaunchContentResponseCallback *)>
        commandCallback(Platform::New<CHIPContentLauncherClusterLaunchContentResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPContentLauncherClusterLaunchContentResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ContentLauncherCluster, launchURL)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring contentURL, jstring displayString)
{
    chip::DeviceLayer::StackLock lock;
    ContentLauncherCluster * cppCluster;

    JniUtfString * contentURLStr    = new JniUtfString(env, contentURL);
    JniUtfString * displayStringStr = new JniUtfString(env, displayString);

    cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, contentURLStr, displayStringStr](chip::Callback::Cancelable * success,
                                                                                      chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->LaunchURL(success, failure, chip::CharSpan(contentURLStr->c_str(), strlen(contentURLStr->c_str())),
                                  chip::CharSpan(displayStringStr->c_str(), strlen(displayStringStr->c_str())));
        delete contentURLStr;
        delete displayStringStr;
        return err;
    };

    std::unique_ptr<CHIPContentLauncherClusterLaunchURLResponseCallback,
                    void (*)(CHIPContentLauncherClusterLaunchURLResponseCallback *)>
        commandCallback(Platform::New<CHIPContentLauncherClusterLaunchURLResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPContentLauncherClusterLaunchURLResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, DescriptorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DescriptorCluster * cppCluster = new DescriptorCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, DiagnosticLogsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DiagnosticLogsCluster * cppCluster = new DiagnosticLogsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DiagnosticLogsCluster, retrieveLogsRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint intent, jint requestedProtocol,
 jbyteArray transferFileDesignator)
{
    chip::DeviceLayer::StackLock lock;
    DiagnosticLogsCluster * cppCluster;

    JniByteArray * transferFileDesignatorArr = new JniByteArray(env, transferFileDesignator);

    cppCluster = reinterpret_cast<DiagnosticLogsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, intent, requestedProtocol, transferFileDesignatorArr](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->RetrieveLogsRequest(
            success, failure, static_cast<uint8_t>(intent), static_cast<uint8_t>(requestedProtocol),
            chip::ByteSpan((const uint8_t *) transferFileDesignatorArr->data(), transferFileDesignatorArr->size()));
        delete transferFileDesignatorArr;
        return err;
    };

    std::unique_ptr<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback,
                    void (*)(CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback *)>
        commandCallback(Platform::New<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, DoorLockCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster = new DoorLockCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DoorLockCluster, clearAllPins)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ClearAllPins(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterClearAllPinsResponseCallback, void (*)(CHIPDoorLockClusterClearAllPinsResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterClearAllPinsResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterClearAllPinsResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, clearAllRfids)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ClearAllRfids(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterClearAllRfidsResponseCallback, void (*)(CHIPDoorLockClusterClearAllRfidsResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterClearAllRfidsResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterClearAllRfidsResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, clearHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, scheduleId](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ClearHolidaySchedule(success, failure, scheduleId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterClearHolidayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterClearHolidayScheduleResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterClearHolidayScheduleResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterClearHolidayScheduleResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, clearPin)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, userId](chip::Callback::Cancelable * success,
                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ClearPin(success, failure, userId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterClearPinResponseCallback, void (*)(CHIPDoorLockClusterClearPinResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterClearPinResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterClearPinResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, clearRfid)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, userId](chip::Callback::Cancelable * success,
                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ClearRfid(success, failure, userId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterClearRfidResponseCallback, void (*)(CHIPDoorLockClusterClearRfidResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterClearRfidResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterClearRfidResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, clearWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, scheduleId, userId](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ClearWeekdaySchedule(success, failure, scheduleId, userId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterClearWeekdayScheduleResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, clearYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, scheduleId, userId](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ClearYeardaySchedule(success, failure, scheduleId, userId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterClearYeardayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterClearYeardayScheduleResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterClearYeardayScheduleResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterClearYeardayScheduleResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, getHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, scheduleId](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetHolidaySchedule(success, failure, scheduleId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterGetHolidayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetHolidayScheduleResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterGetHolidayScheduleResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterGetHolidayScheduleResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, getLogRecord)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint logIndex)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, logIndex](chip::Callback::Cancelable * success,
                                                               chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetLogRecord(success, failure, logIndex);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterGetLogRecordResponseCallback, void (*)(CHIPDoorLockClusterGetLogRecordResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterGetLogRecordResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterGetLogRecordResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, getPin)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, userId](chip::Callback::Cancelable * success,
                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetPin(success, failure, userId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterGetPinResponseCallback, void (*)(CHIPDoorLockClusterGetPinResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterGetPinResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterGetPinResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, getRfid)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, userId](chip::Callback::Cancelable * success,
                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetRfid(success, failure, userId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterGetRfidResponseCallback, void (*)(CHIPDoorLockClusterGetRfidResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterGetRfidResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterGetRfidResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, getUserType)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, userId](chip::Callback::Cancelable * success,
                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetUserType(success, failure, userId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterGetUserTypeResponseCallback, void (*)(CHIPDoorLockClusterGetUserTypeResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterGetUserTypeResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterGetUserTypeResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, getWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, scheduleId, userId](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetWeekdaySchedule(success, failure, scheduleId, userId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetWeekdayScheduleResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, getYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, scheduleId, userId](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetYeardaySchedule(success, failure, scheduleId, userId);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterGetYeardayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetYeardayScheduleResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterGetYeardayScheduleResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterGetYeardayScheduleResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, lockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    JniByteArray * pinArr = new JniByteArray(env, pin);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, pinArr](chip::Callback::Cancelable * success,
                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->LockDoor(success, failure, chip::ByteSpan((const uint8_t *) pinArr->data(), pinArr->size()));
        delete pinArr;
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterLockDoorResponseCallback, void (*)(CHIPDoorLockClusterLockDoorResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterLockDoorResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterLockDoorResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, setHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jlong localStartTime, jlong localEndTime,
 jint operatingModeDuringHoliday)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, scheduleId, localStartTime, localEndTime, operatingModeDuringHoliday](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->SetHolidaySchedule(success, failure, scheduleId, localStartTime, localEndTime, operatingModeDuringHoliday);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterSetHolidayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterSetHolidayScheduleResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterSetHolidayScheduleResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterSetHolidayScheduleResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, setPin)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userStatus, jint userType, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    JniByteArray * pinArr = new JniByteArray(env, pin);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, userId, userStatus, userType, pinArr](chip::Callback::Cancelable * success,
                                                                                           chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->SetPin(success, failure, userId, static_cast<uint8_t>(userStatus), static_cast<uint8_t>(userType),
                               chip::ByteSpan((const uint8_t *) pinArr->data(), pinArr->size()));
        delete pinArr;
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterSetPinResponseCallback, void (*)(CHIPDoorLockClusterSetPinResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterSetPinResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterSetPinResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, setRfid)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userStatus, jint userType, jbyteArray id)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    JniByteArray * idArr = new JniByteArray(env, id);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, userId, userStatus, userType, idArr](chip::Callback::Cancelable * success,
                                                                                          chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->SetRfid(success, failure, userId, static_cast<uint8_t>(userStatus), static_cast<uint8_t>(userType),
                                chip::ByteSpan((const uint8_t *) idArr->data(), idArr->size()));
        delete idArr;
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterSetRfidResponseCallback, void (*)(CHIPDoorLockClusterSetRfidResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterSetRfidResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterSetRfidResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, setUserType)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userType)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, userId, userType](chip::Callback::Cancelable * success,
                                                                       chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->SetUserType(success, failure, userId, static_cast<uint8_t>(userType));
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterSetUserTypeResponseCallback, void (*)(CHIPDoorLockClusterSetUserTypeResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterSetUserTypeResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterSetUserTypeResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, setWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId, jint daysMask, jint startHour,
 jint startMinute, jint endHour, jint endMinute)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, scheduleId, userId, daysMask, startHour, startMinute, endHour,
                                         endMinute](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->SetWeekdaySchedule(success, failure, scheduleId, userId, daysMask, startHour, startMinute,
                                                        endHour, endMinute);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterSetWeekdayScheduleResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, setYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId, jlong localStartTime,
 jlong localEndTime)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, scheduleId, userId, localStartTime,
                                         localEndTime](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->SetYeardaySchedule(success, failure, scheduleId, userId, localStartTime, localEndTime);
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterSetYeardayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterSetYeardayScheduleResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterSetYeardayScheduleResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterSetYeardayScheduleResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, unlockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    JniByteArray * pinArr = new JniByteArray(env, pin);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, pinArr](chip::Callback::Cancelable * success,
                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->UnlockDoor(success, failure, chip::ByteSpan((const uint8_t *) pinArr->data(), pinArr->size()));
        delete pinArr;
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterUnlockDoorResponseCallback, void (*)(CHIPDoorLockClusterUnlockDoorResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterUnlockDoorResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterUnlockDoorResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, DoorLockCluster, unlockWithTimeout)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint timeoutInSeconds, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster;

    JniByteArray * pinArr = new JniByteArray(env, pin);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, timeoutInSeconds, pinArr](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->UnlockWithTimeout(success, failure, timeoutInSeconds,
                                                       chip::ByteSpan((const uint8_t *) pinArr->data(), pinArr->size()));
        delete pinArr;
        return err;
    };

    std::unique_ptr<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback,
                    void (*)(CHIPDoorLockClusterUnlockWithTimeoutResponseCallback *)>
        commandCallback(Platform::New<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, DoorLockCluster, subscribeLockStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeLockState(success, failure, static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, DoorLockCluster, reportLockStateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeLockState(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}
JNI_METHOD(jlong, ElectricalMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ElectricalMeasurementCluster * cppCluster = new ElectricalMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, EthernetNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    EthernetNetworkDiagnosticsCluster * cppCluster = new EthernetNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    EthernetNetworkDiagnosticsCluster * cppCluster;

    cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ResetCounts(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, FixedLabelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    FixedLabelCluster * cppCluster = new FixedLabelCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, FlowMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    FlowMeasurementCluster * cppCluster = new FlowMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GeneralCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GeneralCommissioningCluster * cppCluster = new GeneralCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GeneralCommissioningCluster, armFailSafe)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint expiryLengthSeconds, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    GeneralCommissioningCluster * cppCluster;

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, expiryLengthSeconds, breadcrumb,
                                         timeoutMs](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ArmFailSafe(success, failure, expiryLengthSeconds, breadcrumb, timeoutMs);
        return err;
    };

    std::unique_ptr<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterArmFailSafeResponseCallback *)>
        commandCallback(Platform::New<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, GeneralCommissioningCluster, commissioningComplete)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    GeneralCommissioningCluster * cppCluster;

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->CommissioningComplete(success, failure);
        return err;
    };

    std::unique_ptr<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback *)>
        commandCallback(Platform::New<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, GeneralCommissioningCluster, setRegulatoryConfig)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint location, jstring countryCode, jlong breadcrumb,
 jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    GeneralCommissioningCluster * cppCluster;

    JniUtfString * countryCodeStr = new JniUtfString(env, countryCode);

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, location, countryCodeStr, breadcrumb,
                                         timeoutMs](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->SetRegulatoryConfig(success, failure, static_cast<uint8_t>(location),
                                                         chip::CharSpan(countryCodeStr->c_str(), strlen(countryCodeStr->c_str())),
                                                         breadcrumb, timeoutMs);
        delete countryCodeStr;
        return err;
    };

    std::unique_ptr<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback *)>
        commandCallback(Platform::New<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, GeneralCommissioningCluster, writeBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;

    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeBreadcrumb(success, failure, static_cast<uint64_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, GeneralDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GeneralDiagnosticsCluster * cppCluster = new GeneralDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GroupKeyManagementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GroupKeyManagementCluster * cppCluster = new GroupKeyManagementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GroupsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GroupsCluster * cppCluster = new GroupsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GroupsCluster, addGroup)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jstring groupName)
{
    chip::DeviceLayer::StackLock lock;
    GroupsCluster * cppCluster;

    JniUtfString * groupNameStr = new JniUtfString(env, groupName);

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId, groupNameStr](chip::Callback::Cancelable * success,
                                                                            chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->AddGroup(success, failure, groupId, chip::CharSpan(groupNameStr->c_str(), strlen(groupNameStr->c_str())));
        delete groupNameStr;
        return err;
    };

    std::unique_ptr<CHIPGroupsClusterAddGroupResponseCallback, void (*)(CHIPGroupsClusterAddGroupResponseCallback *)>
        commandCallback(Platform::New<CHIPGroupsClusterAddGroupResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPGroupsClusterAddGroupResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, GroupsCluster, addGroupIfIdentifying)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jstring groupName)
{
    chip::DeviceLayer::StackLock lock;
    GroupsCluster * cppCluster;

    JniUtfString * groupNameStr = new JniUtfString(env, groupName);

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId, groupNameStr](chip::Callback::Cancelable * success,
                                                                            chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->AddGroupIfIdentifying(success, failure, groupId,
                                                           chip::CharSpan(groupNameStr->c_str(), strlen(groupNameStr->c_str())));
        delete groupNameStr;
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, GroupsCluster, getGroupMembership)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupCount, jint groupList)
{
    chip::DeviceLayer::StackLock lock;
    GroupsCluster * cppCluster;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupCount, groupList](chip::Callback::Cancelable * success,
                                                                            chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetGroupMembership(success, failure, groupCount, groupList);
        return err;
    };

    std::unique_ptr<CHIPGroupsClusterGetGroupMembershipResponseCallback,
                    void (*)(CHIPGroupsClusterGetGroupMembershipResponseCallback *)>
        commandCallback(Platform::New<CHIPGroupsClusterGetGroupMembershipResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPGroupsClusterGetGroupMembershipResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, GroupsCluster, removeAllGroups)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    GroupsCluster * cppCluster;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->RemoveAllGroups(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, GroupsCluster, removeGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    chip::DeviceLayer::StackLock lock;
    GroupsCluster * cppCluster;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId](chip::Callback::Cancelable * success,
                                                              chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->RemoveGroup(success, failure, groupId);
        return err;
    };

    std::unique_ptr<CHIPGroupsClusterRemoveGroupResponseCallback, void (*)(CHIPGroupsClusterRemoveGroupResponseCallback *)>
        commandCallback(Platform::New<CHIPGroupsClusterRemoveGroupResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPGroupsClusterRemoveGroupResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, GroupsCluster, viewGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    chip::DeviceLayer::StackLock lock;
    GroupsCluster * cppCluster;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId](chip::Callback::Cancelable * success,
                                                              chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ViewGroup(success, failure, groupId);
        return err;
    };

    std::unique_ptr<CHIPGroupsClusterViewGroupResponseCallback, void (*)(CHIPGroupsClusterViewGroupResponseCallback *)>
        commandCallback(Platform::New<CHIPGroupsClusterViewGroupResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPGroupsClusterViewGroupResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, IdentifyCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    IdentifyCluster * cppCluster = new IdentifyCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, IdentifyCluster, identify)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint identifyTime)
{
    chip::DeviceLayer::StackLock lock;
    IdentifyCluster * cppCluster;

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, identifyTime](chip::Callback::Cancelable * success,
                                                                   chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Identify(success, failure, identifyTime);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, IdentifyCluster, identifyQuery)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    IdentifyCluster * cppCluster;

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->IdentifyQuery(success, failure);
        return err;
    };

    std::unique_ptr<CHIPIdentifyClusterIdentifyQueryResponseCallback, void (*)(CHIPIdentifyClusterIdentifyQueryResponseCallback *)>
        commandCallback(Platform::New<CHIPIdentifyClusterIdentifyQueryResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPIdentifyClusterIdentifyQueryResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, IdentifyCluster, triggerEffect)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint effectIdentifier, jint effectVariant)
{
    chip::DeviceLayer::StackLock lock;
    IdentifyCluster * cppCluster;

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, effectIdentifier, effectVariant](chip::Callback::Cancelable * success,
                                                                                      chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->TriggerEffect(success, failure, static_cast<uint8_t>(effectIdentifier),
                                                   static_cast<uint8_t>(effectVariant));
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, IdentifyCluster, writeIdentifyTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeIdentifyTime(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, IlluminanceMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    IlluminanceMeasurementCluster * cppCluster = new IlluminanceMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, IlluminanceMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeMeasuredValue(success, failure, static_cast<uint16_t>(minInterval),
                                                           static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeMeasuredValue(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}
JNI_METHOD(jlong, KeypadInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    KeypadInputCluster * cppCluster = new KeypadInputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, KeypadInputCluster, sendKey)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint keyCode)
{
    chip::DeviceLayer::StackLock lock;
    KeypadInputCluster * cppCluster;

    cppCluster = reinterpret_cast<KeypadInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, keyCode](chip::Callback::Cancelable * success,
                                                              chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->SendKey(success, failure, static_cast<uint8_t>(keyCode));
        return err;
    };

    std::unique_ptr<CHIPKeypadInputClusterSendKeyResponseCallback, void (*)(CHIPKeypadInputClusterSendKeyResponseCallback *)>
        commandCallback(Platform::New<CHIPKeypadInputClusterSendKeyResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPKeypadInputClusterSendKeyResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, LevelControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster = new LevelControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LevelControlCluster, move)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionMask, jint optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, moveMode, rate, optionMask, optionOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Move(success, failure, static_cast<uint8_t>(moveMode), rate, optionMask, optionOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, LevelControlCluster, moveToLevel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint level, jint transitionTime, jint optionMask,
 jint optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, level, transitionTime, optionMask, optionOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MoveToLevel(success, failure, level, transitionTime, optionMask, optionOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, LevelControlCluster, moveToLevelWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint level, jint transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, level, transitionTime](chip::Callback::Cancelable * success,
                                                                            chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MoveToLevelWithOnOff(success, failure, level, transitionTime);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, LevelControlCluster, moveWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, moveMode, rate](chip::Callback::Cancelable * success,
                                                                     chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MoveWithOnOff(success, failure, static_cast<uint8_t>(moveMode), rate);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, LevelControlCluster, step)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime, jint optionMask,
 jint optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, stepMode, stepSize, transitionTime, optionMask, optionOverride](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Step(success, failure, static_cast<uint8_t>(stepMode), stepSize, transitionTime, optionMask,
                                          optionOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, LevelControlCluster, stepWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, stepMode, stepSize, transitionTime](chip::Callback::Cancelable * success,
                                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StepWithOnOff(success, failure, static_cast<uint8_t>(stepMode), stepSize, transitionTime);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, LevelControlCluster, stop)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint optionMask, jint optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, optionMask, optionOverride](chip::Callback::Cancelable * success,
                                                                                 chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Stop(success, failure, optionMask, optionOverride);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, LevelControlCluster, stopWithOnOff)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StopWithOnOff(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, LevelControlCluster, subscribeCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentLevel(success, failure, static_cast<uint16_t>(minInterval),
                                                          static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, LevelControlCluster, reportCurrentLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentLevel(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, LevelControlCluster, writeOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOptions(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOnOffTransitionTime(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOnLevel(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOnTransitionTime(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, LevelControlCluster, writeOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOffTransitionTime(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, LevelControlCluster, writeDefaultMoveRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeDefaultMoveRate(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, LevelControlCluster, writeStartUpCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeStartUpCurrentLevel(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, LowPowerCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    LowPowerCluster * cppCluster = new LowPowerCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LowPowerCluster, sleep)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    LowPowerCluster * cppCluster;

    cppCluster = reinterpret_cast<LowPowerCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Sleep(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, MediaInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    MediaInputCluster * cppCluster = new MediaInputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaInputCluster, hideInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    MediaInputCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->HideInputStatus(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaInputCluster, renameInput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index, jstring name)
{
    chip::DeviceLayer::StackLock lock;
    MediaInputCluster * cppCluster;

    JniUtfString * nameStr = new JniUtfString(env, name);

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, index, nameStr](chip::Callback::Cancelable * success,
                                                                     chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->RenameInput(success, failure, index, chip::CharSpan(nameStr->c_str(), strlen(nameStr->c_str())));
        delete nameStr;
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaInputCluster, selectInput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index)
{
    chip::DeviceLayer::StackLock lock;
    MediaInputCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, index](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->SelectInput(success, failure, index);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaInputCluster, showInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    MediaInputCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ShowInputStatus(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, MediaPlaybackCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster = new MediaPlaybackCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaPlaybackCluster, mediaFastForward)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaFastForward(success, failure);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaFastForwardResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaNext)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaNext(success, failure);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaNextResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaNextResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaNextResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaNextResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPause)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaPause(success, failure);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPauseResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPauseResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaPauseResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaPauseResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPlay)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaPlay(success, failure);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPlayResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPlayResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaPlayResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaPlayResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPrevious)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaPrevious(success, failure);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPreviousResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPreviousResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaPreviousResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaPreviousResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaRewind)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaRewind(success, failure);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaRewindResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaRewindResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaRewindResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaRewindResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSeek)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong position)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, position](chip::Callback::Cancelable * success,
                                                               chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaSeek(success, failure, position);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSeekResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSeekResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaSeekResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaSeekResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipBackward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong deltaPositionMilliseconds)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, deltaPositionMilliseconds](chip::Callback::Cancelable * success,
                                                                                chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaSkipBackward(success, failure, deltaPositionMilliseconds);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipForward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong deltaPositionMilliseconds)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, deltaPositionMilliseconds](chip::Callback::Cancelable * success,
                                                                                chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaSkipForward(success, failure, deltaPositionMilliseconds);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStartOver)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaStartOver(success, failure);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaStartOverResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaStartOverResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaStartOverResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaStartOverResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->MediaStop(success, failure);
        return err;
    };

    std::unique_ptr<CHIPMediaPlaybackClusterMediaStopResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaStopResponseCallback *)>
        commandCallback(Platform::New<CHIPMediaPlaybackClusterMediaStopResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPMediaPlaybackClusterMediaStopResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, ModeSelectCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ModeSelectCluster * cppCluster = new ModeSelectCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ModeSelectCluster, changeToMode)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint newMode)
{
    chip::DeviceLayer::StackLock lock;
    ModeSelectCluster * cppCluster;

    cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, newMode](chip::Callback::Cancelable * success,
                                                              chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ChangeToMode(success, failure, newMode);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, ModeSelectCluster, subscribeCurrentModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentMode(success, failure, static_cast<uint16_t>(minInterval),
                                                         static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, ModeSelectCluster, reportCurrentModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentMode(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, ModeSelectCluster, writeOnModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOnMode(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, NetworkCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster = new NetworkCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, NetworkCommissioningCluster, addThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray * operationalDatasetArr = new JniByteArray(env, operationalDataset);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, operationalDatasetArr, breadcrumb,
                                         timeoutMs](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->AddThreadNetwork(
            success, failure, chip::ByteSpan((const uint8_t *) operationalDatasetArr->data(), operationalDatasetArr->size()),
            breadcrumb, timeoutMs);
        delete operationalDatasetArr;
        return err;
    };

    std::unique_ptr<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback *)>
        commandCallback(Platform::New<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, addWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jlong breadcrumb,
 jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray * ssidArr        = new JniByteArray(env, ssid);
    JniByteArray * credentialsArr = new JniByteArray(env, credentials);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, ssidArr, credentialsArr, breadcrumb,
                                         timeoutMs](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->AddWiFiNetwork(
            success, failure, chip::ByteSpan((const uint8_t *) ssidArr->data(), ssidArr->size()),
            chip::ByteSpan((const uint8_t *) credentialsArr->data(), credentialsArr->size()), breadcrumb, timeoutMs);
        delete ssidArr;
        delete credentialsArr;
        return err;
    };

    std::unique_ptr<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback *)>
        commandCallback(Platform::New<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, disableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray * networkIDArr = new JniByteArray(env, networkID);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, networkIDArr, breadcrumb, timeoutMs](chip::Callback::Cancelable * success,
                                                                                          chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->DisableNetwork(
            success, failure, chip::ByteSpan((const uint8_t *) networkIDArr->data(), networkIDArr->size()), breadcrumb, timeoutMs);
        delete networkIDArr;
        return err;
    };

    std::unique_ptr<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterDisableNetworkResponseCallback *)>
        commandCallback(Platform::New<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, enableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray * networkIDArr = new JniByteArray(env, networkID);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, networkIDArr, breadcrumb, timeoutMs](chip::Callback::Cancelable * success,
                                                                                          chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->EnableNetwork(
            success, failure, chip::ByteSpan((const uint8_t *) networkIDArr->data(), networkIDArr->size()), breadcrumb, timeoutMs);
        delete networkIDArr;
        return err;
    };

    std::unique_ptr<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterEnableNetworkResponseCallback *)>
        commandCallback(Platform::New<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, removeNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray * networkIDArr = new JniByteArray(env, networkID);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, networkIDArr, breadcrumb, timeoutMs](chip::Callback::Cancelable * success,
                                                                                          chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->RemoveNetwork(
            success, failure, chip::ByteSpan((const uint8_t *) networkIDArr->data(), networkIDArr->size()), breadcrumb, timeoutMs);
        delete networkIDArr;
        return err;
    };

    std::unique_ptr<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback *)>
        commandCallback(Platform::New<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, scanNetworks)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray * ssidArr = new JniByteArray(env, ssid);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, ssidArr, breadcrumb, timeoutMs](chip::Callback::Cancelable * success,
                                                                                     chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ScanNetworks(
            success, failure, chip::ByteSpan((const uint8_t *) ssidArr->data(), ssidArr->size()), breadcrumb, timeoutMs);
        delete ssidArr;
        return err;
    };

    std::unique_ptr<CHIPNetworkCommissioningClusterScanNetworksResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterScanNetworksResponseCallback *)>
        commandCallback(Platform::New<CHIPNetworkCommissioningClusterScanNetworksResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPNetworkCommissioningClusterScanNetworksResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, updateThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray * operationalDatasetArr = new JniByteArray(env, operationalDataset);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, operationalDatasetArr, breadcrumb,
                                         timeoutMs](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->UpdateThreadNetwork(
            success, failure, chip::ByteSpan((const uint8_t *) operationalDatasetArr->data(), operationalDatasetArr->size()),
            breadcrumb, timeoutMs);
        delete operationalDatasetArr;
        return err;
    };

    std::unique_ptr<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback *)>
        commandCallback(Platform::New<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, updateWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jlong breadcrumb,
 jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray * ssidArr        = new JniByteArray(env, ssid);
    JniByteArray * credentialsArr = new JniByteArray(env, credentials);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, ssidArr, credentialsArr, breadcrumb,
                                         timeoutMs](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->UpdateWiFiNetwork(
            success, failure, chip::ByteSpan((const uint8_t *) ssidArr->data(), ssidArr->size()),
            chip::ByteSpan((const uint8_t *) credentialsArr->data(), credentialsArr->size()), breadcrumb, timeoutMs);
        delete ssidArr;
        delete credentialsArr;
        return err;
    };

    std::unique_ptr<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback *)>
        commandCallback(Platform::New<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, OtaSoftwareUpdateProviderCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateProviderCluster * cppCluster = new OtaSoftwareUpdateProviderCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, applyUpdateRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray updateToken, jlong newVersion)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    JniByteArray * updateTokenArr = new JniByteArray(env, updateToken);

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, updateTokenArr, newVersion](chip::Callback::Cancelable * success,
                                                                                 chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ApplyUpdateRequest(
            success, failure, chip::ByteSpan((const uint8_t *) updateTokenArr->data(), updateTokenArr->size()), newVersion);
        delete updateTokenArr;
        return err;
    };

    std::unique_ptr<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback,
                    void (*)(CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback *)>
        commandCallback(Platform::New<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, notifyUpdateApplied)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray updateToken, jlong softwareVersion)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    JniByteArray * updateTokenArr = new JniByteArray(env, updateToken);

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, updateTokenArr, softwareVersion](chip::Callback::Cancelable * success,
                                                                                      chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->NotifyUpdateApplied(
            success, failure, chip::ByteSpan((const uint8_t *) updateTokenArr->data(), updateTokenArr->size()), softwareVersion);
        delete updateTokenArr;
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, queryImage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint vendorId, jint productId, jlong softwareVersion,
 jint protocolsSupported, jint hardwareVersion, jstring location, jboolean requestorCanConsent, jbyteArray metadataForProvider)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    JniUtfString * locationStr            = new JniUtfString(env, location);
    JniByteArray * metadataForProviderArr = new JniByteArray(env, metadataForProvider);

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock =
        [cppCluster, vendorId, productId, softwareVersion, protocolsSupported, hardwareVersion, locationStr, requestorCanConsent,
         metadataForProviderArr](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
            CHIP_ERROR err = cppCluster->QueryImage(
                success, failure, static_cast<chip::VendorId>(vendorId), productId, softwareVersion,
                static_cast<uint8_t>(protocolsSupported), hardwareVersion,
                chip::CharSpan(locationStr->c_str(), strlen(locationStr->c_str())), requestorCanConsent,
                chip::ByteSpan((const uint8_t *) metadataForProviderArr->data(), metadataForProviderArr->size()));
            delete locationStr;
            delete metadataForProviderArr;
            return err;
        };

    std::unique_ptr<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback,
                    void (*)(CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback *)>
        commandCallback(Platform::New<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, OtaSoftwareUpdateRequestorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateRequestorCluster * cppCluster = new OtaSoftwareUpdateRequestorCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, announceOtaProvider)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong providerLocation, jint vendorId, jint announcementReason,
 jbyteArray metadataForNode)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateRequestorCluster * cppCluster;

    JniByteArray * metadataForNodeArr = new JniByteArray(env, metadataForNode);

    cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, providerLocation, vendorId, announcementReason, metadataForNodeArr](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->AnnounceOtaProvider(
            success, failure, providerLocation, static_cast<chip::VendorId>(vendorId), static_cast<uint8_t>(announcementReason),
            chip::ByteSpan((const uint8_t *) metadataForNodeArr->data(), metadataForNodeArr->size()));
        delete metadataForNodeArr;
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, writeDefaultOtaProviderAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;

    OtaSoftwareUpdateRequestorCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value, env](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        JniByteArray valueJniArr(env, value);
        return cppCluster->WriteAttributeDefaultOtaProvider(
            success, failure, chip::ByteSpan((const uint8_t *) valueJniArr.data(), valueJniArr.size()));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, OccupancySensingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OccupancySensingCluster * cppCluster = new OccupancySensingCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OccupancySensingCluster, subscribeOccupancyAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeOccupancy(success, failure, static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, OccupancySensingCluster, reportOccupancyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeOccupancy(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}
JNI_METHOD(jlong, OnOffCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OnOffCluster * cppCluster = new OnOffCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffCluster, off)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    OnOffCluster * cppCluster;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Off(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OnOffCluster, offWithEffect)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint effectId, jint effectVariant)
{
    chip::DeviceLayer::StackLock lock;
    OnOffCluster * cppCluster;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, effectId, effectVariant](chip::Callback::Cancelable * success,
                                                                              chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->OffWithEffect(success, failure, static_cast<uint8_t>(effectId), static_cast<uint8_t>(effectVariant));
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OnOffCluster, on)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    OnOffCluster * cppCluster;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->On(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OnOffCluster, onWithRecallGlobalScene)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    OnOffCluster * cppCluster;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->OnWithRecallGlobalScene(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OnOffCluster, onWithTimedOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint onOffControl, jint onTime, jint offWaitTime)
{
    chip::DeviceLayer::StackLock lock;
    OnOffCluster * cppCluster;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, onOffControl, onTime, offWaitTime](chip::Callback::Cancelable * success,
                                                                                        chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->OnWithTimedOff(success, failure, onOffControl, onTime, offWaitTime);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OnOffCluster, toggle)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    OnOffCluster * cppCluster;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Toggle(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, OnOffCluster, subscribeOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeOnOff(success, failure, static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, OnOffCluster, reportOnOffAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeOnOff(success);
    };

    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, OnOffCluster, writeOnTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOnTime(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, OnOffCluster, writeOffWaitTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOffWaitTime(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, OnOffCluster, writeStartUpOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeStartUpOnOff(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, OnOffSwitchConfigurationCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OnOffSwitchConfigurationCluster * cppCluster = new OnOffSwitchConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, writeSwitchActionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeSwitchActions(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, OperationalCredentialsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster = new OperationalCredentialsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OperationalCredentialsCluster, addNOC)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray NOCValue, jbyteArray ICACValue, jbyteArray IPKValue,
 jlong caseAdminNode, jint adminVendorId)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray * NOCValueArr  = new JniByteArray(env, NOCValue);
    JniByteArray * ICACValueArr = new JniByteArray(env, ICACValue);
    JniByteArray * IPKValueArr  = new JniByteArray(env, IPKValue);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, NOCValueArr, ICACValueArr, IPKValueArr, caseAdminNode, adminVendorId](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->AddNOC(
            success, failure, chip::ByteSpan((const uint8_t *) NOCValueArr->data(), NOCValueArr->size()),
            chip::ByteSpan((const uint8_t *) ICACValueArr->data(), ICACValueArr->size()),
            chip::ByteSpan((const uint8_t *) IPKValueArr->data(), IPKValueArr->size()), caseAdminNode, adminVendorId);
        delete NOCValueArr;
        delete ICACValueArr;
        delete IPKValueArr;
        return err;
    };

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        commandCallback(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, addTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray rootCertificate)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray * rootCertificateArr = new JniByteArray(env, rootCertificate);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, rootCertificateArr](chip::Callback::Cancelable * success,
                                                                         chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->AddTrustedRootCertificate(
            success, failure, chip::ByteSpan((const uint8_t *) rootCertificateArr->data(), rootCertificateArr->size()));
        delete rootCertificateArr;
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, attestationRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray attestationNonce)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray * attestationNonceArr = new JniByteArray(env, attestationNonce);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, attestationNonceArr](chip::Callback::Cancelable * success,
                                                                          chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->AttestationRequest(
            success, failure, chip::ByteSpan((const uint8_t *) attestationNonceArr->data(), attestationNonceArr->size()));
        delete attestationNonceArr;
        return err;
    };

    std::unique_ptr<CHIPOperationalCredentialsClusterAttestationResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterAttestationResponseCallback *)>
        commandCallback(Platform::New<CHIPOperationalCredentialsClusterAttestationResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPOperationalCredentialsClusterAttestationResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, certificateChainRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint certificateType)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, certificateType](chip::Callback::Cancelable * success,
                                                                      chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->CertificateChainRequest(success, failure, certificateType);
        return err;
    };

    std::unique_ptr<CHIPOperationalCredentialsClusterCertificateChainResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterCertificateChainResponseCallback *)>
        commandCallback(Platform::New<CHIPOperationalCredentialsClusterCertificateChainResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPOperationalCredentialsClusterCertificateChainResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, opCSRRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray CSRNonce)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray * CSRNonceArr = new JniByteArray(env, CSRNonce);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, CSRNonceArr](chip::Callback::Cancelable * success,
                                                                  chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->OpCSRRequest(success, failure, chip::ByteSpan((const uint8_t *) CSRNonceArr->data(), CSRNonceArr->size()));
        delete CSRNonceArr;
        return err;
    };

    std::unique_ptr<CHIPOperationalCredentialsClusterOpCSRResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterOpCSRResponseCallback *)>
        commandCallback(Platform::New<CHIPOperationalCredentialsClusterOpCSRResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPOperationalCredentialsClusterOpCSRResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, removeFabric)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint fabricIndex)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, fabricIndex](chip::Callback::Cancelable * success,
                                                                  chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->RemoveFabric(success, failure, fabricIndex);
        return err;
    };

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        commandCallback(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, removeTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray trustedRootIdentifier)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray * trustedRootIdentifierArr = new JniByteArray(env, trustedRootIdentifier);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, trustedRootIdentifierArr](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->RemoveTrustedRootCertificate(
            success, failure, chip::ByteSpan((const uint8_t *) trustedRootIdentifierArr->data(), trustedRootIdentifierArr->size()));
        delete trustedRootIdentifierArr;
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, updateFabricLabel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring label)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster;

    JniUtfString * labelStr = new JniUtfString(env, label);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, labelStr](chip::Callback::Cancelable * success,
                                                               chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->UpdateFabricLabel(success, failure, chip::CharSpan(labelStr->c_str(), strlen(labelStr->c_str())));
        delete labelStr;
        return err;
    };

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        commandCallback(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, updateNOC)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray NOCValue, jbyteArray ICACValue)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray * NOCValueArr  = new JniByteArray(env, NOCValue);
    JniByteArray * ICACValueArr = new JniByteArray(env, ICACValue);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, NOCValueArr, ICACValueArr](chip::Callback::Cancelable * success,
                                                                                chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->UpdateNOC(success, failure, chip::ByteSpan((const uint8_t *) NOCValueArr->data(), NOCValueArr->size()),
                                  chip::ByteSpan((const uint8_t *) ICACValueArr->data(), ICACValueArr->size()));
        delete NOCValueArr;
        delete ICACValueArr;
        return err;
    };

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        commandCallback(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, PowerSourceCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PowerSourceCluster * cppCluster = new PowerSourceCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, PressureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PressureMeasurementCluster * cppCluster = new PressureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PressureMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeMeasuredValue(success, failure, static_cast<uint16_t>(minInterval),
                                                           static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, PressureMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeMeasuredValue(success);
    };

    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}
JNI_METHOD(jlong, PumpConfigurationAndControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PumpConfigurationAndControlCluster * cppCluster = new PumpConfigurationAndControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribePumpStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributePumpStatus(success, failure, static_cast<uint16_t>(minInterval),
                                                        static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportPumpStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributePumpStatus(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeCapacityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCapacity(success, failure, static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportCapacityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCapacity(success);
    };

    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOperationMode(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeControlMode(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, RelativeHumidityMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    RelativeHumidityMeasurementCluster * cppCluster = new RelativeHumidityMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeMeasuredValue(success, failure, static_cast<uint16_t>(minInterval),
                                                           static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeMeasuredValue(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeTolerance(success, failure, static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeTolerance(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}
JNI_METHOD(jlong, ScenesCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster = new ScenesCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ScenesCluster, addScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId, jint transitionTime, jstring sceneName,
 jlong clusterId, jint length, jint value)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster;

    JniUtfString * sceneNameStr = new JniUtfString(env, sceneName);

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId, sceneId, transitionTime, sceneNameStr, clusterId, length,
                                         value](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->AddScene(success, failure, groupId, sceneId, transitionTime,
                                 chip::CharSpan(sceneNameStr->c_str(), strlen(sceneNameStr->c_str())), clusterId, length, value);
        delete sceneNameStr;
        return err;
    };

    std::unique_ptr<CHIPScenesClusterAddSceneResponseCallback, void (*)(CHIPScenesClusterAddSceneResponseCallback *)>
        commandCallback(Platform::New<CHIPScenesClusterAddSceneResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPScenesClusterAddSceneResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ScenesCluster, getSceneMembership)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId](chip::Callback::Cancelable * success,
                                                              chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetSceneMembership(success, failure, groupId);
        return err;
    };

    std::unique_ptr<CHIPScenesClusterGetSceneMembershipResponseCallback,
                    void (*)(CHIPScenesClusterGetSceneMembershipResponseCallback *)>
        commandCallback(Platform::New<CHIPScenesClusterGetSceneMembershipResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPScenesClusterGetSceneMembershipResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ScenesCluster, recallScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId, jint transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId, sceneId, transitionTime](chip::Callback::Cancelable * success,
                                                                                       chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->RecallScene(success, failure, groupId, sceneId, transitionTime);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ScenesCluster, removeAllScenes)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId](chip::Callback::Cancelable * success,
                                                              chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->RemoveAllScenes(success, failure, groupId);
        return err;
    };

    std::unique_ptr<CHIPScenesClusterRemoveAllScenesResponseCallback, void (*)(CHIPScenesClusterRemoveAllScenesResponseCallback *)>
        commandCallback(Platform::New<CHIPScenesClusterRemoveAllScenesResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPScenesClusterRemoveAllScenesResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ScenesCluster, removeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId, sceneId](chip::Callback::Cancelable * success,
                                                                       chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->RemoveScene(success, failure, groupId, sceneId);
        return err;
    };

    std::unique_ptr<CHIPScenesClusterRemoveSceneResponseCallback, void (*)(CHIPScenesClusterRemoveSceneResponseCallback *)>
        commandCallback(Platform::New<CHIPScenesClusterRemoveSceneResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPScenesClusterRemoveSceneResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ScenesCluster, storeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId, sceneId](chip::Callback::Cancelable * success,
                                                                       chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StoreScene(success, failure, groupId, sceneId);
        return err;
    };

    std::unique_ptr<CHIPScenesClusterStoreSceneResponseCallback, void (*)(CHIPScenesClusterStoreSceneResponseCallback *)>
        commandCallback(Platform::New<CHIPScenesClusterStoreSceneResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPScenesClusterStoreSceneResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ScenesCluster, viewScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, groupId, sceneId](chip::Callback::Cancelable * success,
                                                                       chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ViewScene(success, failure, groupId, sceneId);
        return err;
    };

    std::unique_ptr<CHIPScenesClusterViewSceneResponseCallback, void (*)(CHIPScenesClusterViewSceneResponseCallback *)>
        commandCallback(Platform::New<CHIPScenesClusterViewSceneResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPScenesClusterViewSceneResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, SoftwareDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    SoftwareDiagnosticsCluster * cppCluster = new SoftwareDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, resetWatermarks)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    SoftwareDiagnosticsCluster * cppCluster;

    cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ResetWatermarks(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, SwitchCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    SwitchCluster * cppCluster = new SwitchCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SwitchCluster, subscribeCurrentPositionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentPosition(success, failure, static_cast<uint16_t>(minInterval),
                                                             static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, SwitchCluster, reportCurrentPositionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentPosition(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}
JNI_METHOD(jlong, TvChannelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TvChannelCluster * cppCluster = new TvChannelCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TvChannelCluster, changeChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring match)
{
    chip::DeviceLayer::StackLock lock;
    TvChannelCluster * cppCluster;

    JniUtfString * matchStr = new JniUtfString(env, match);

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, matchStr](chip::Callback::Cancelable * success,
                                                               chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ChangeChannel(success, failure, chip::CharSpan(matchStr->c_str(), strlen(matchStr->c_str())));
        delete matchStr;
        return err;
    };

    std::unique_ptr<CHIPTvChannelClusterChangeChannelResponseCallback,
                    void (*)(CHIPTvChannelClusterChangeChannelResponseCallback *)>
        commandCallback(Platform::New<CHIPTvChannelClusterChangeChannelResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPTvChannelClusterChangeChannelResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TvChannelCluster, changeChannelByNumber)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint majorNumber, jint minorNumber)
{
    chip::DeviceLayer::StackLock lock;
    TvChannelCluster * cppCluster;

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, majorNumber, minorNumber](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ChangeChannelByNumber(success, failure, majorNumber, minorNumber);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TvChannelCluster, skipChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint count)
{
    chip::DeviceLayer::StackLock lock;
    TvChannelCluster * cppCluster;

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, count](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->SkipChannel(success, failure, count);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, TargetNavigatorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TargetNavigatorCluster * cppCluster = new TargetNavigatorCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TargetNavigatorCluster, navigateTarget)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint target, jstring data)
{
    chip::DeviceLayer::StackLock lock;
    TargetNavigatorCluster * cppCluster;

    JniUtfString * dataStr = new JniUtfString(env, data);

    cppCluster = reinterpret_cast<TargetNavigatorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, target, dataStr](chip::Callback::Cancelable * success,
                                                                      chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->NavigateTarget(success, failure, target, chip::CharSpan(dataStr->c_str(), strlen(dataStr->c_str())));
        delete dataStr;
        return err;
    };

    std::unique_ptr<CHIPTargetNavigatorClusterNavigateTargetResponseCallback,
                    void (*)(CHIPTargetNavigatorClusterNavigateTargetResponseCallback *)>
        commandCallback(Platform::New<CHIPTargetNavigatorClusterNavigateTargetResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPTargetNavigatorClusterNavigateTargetResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, TemperatureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TemperatureMeasurementCluster * cppCluster = new TemperatureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TemperatureMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeMeasuredValue(success, failure, static_cast<uint16_t>(minInterval),
                                                           static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeMeasuredValue(success);
    };

    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, subscribeToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeTolerance(success, failure, static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeTolerance(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}
JNI_METHOD(jlong, TestClusterCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster = new TestClusterCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TestClusterCluster, test)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->Test(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TestClusterCluster, testAddArguments)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1, jint arg2)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, arg1, arg2](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->TestAddArguments(success, failure, arg1, arg2);
        return err;
    };

    std::unique_ptr<CHIPTestClusterClusterTestAddArgumentsResponseCallback,
                    void (*)(CHIPTestClusterClusterTestAddArgumentsResponseCallback *)>
        commandCallback(Platform::New<CHIPTestClusterClusterTestAddArgumentsResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPTestClusterClusterTestAddArgumentsResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TestClusterCluster, testEnumsRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1, jint arg2)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, arg1, arg2](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        CHIP_ERROR err =
            cppCluster->TestEnumsRequest(success, failure, static_cast<chip::VendorId>(arg1), static_cast<uint8_t>(arg2));
        return err;
    };

    std::unique_ptr<CHIPTestClusterClusterTestEnumsResponseCallback, void (*)(CHIPTestClusterClusterTestEnumsResponseCallback *)>
        commandCallback(Platform::New<CHIPTestClusterClusterTestEnumsResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPTestClusterClusterTestEnumsResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TestClusterCluster, testListInt8UArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, arg1](chip::Callback::Cancelable * success,
                                                           chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->TestListInt8UArgumentRequest(success, failure, arg1);
        return err;
    };

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        commandCallback(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TestClusterCluster, testListInt8UReverseRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, arg1](chip::Callback::Cancelable * success,
                                                           chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->TestListInt8UReverseRequest(success, failure, arg1);
        return err;
    };

    std::unique_ptr<CHIPTestClusterClusterTestListInt8UReverseResponseCallback,
                    void (*)(CHIPTestClusterClusterTestListInt8UReverseResponseCallback *)>
        commandCallback(Platform::New<CHIPTestClusterClusterTestListInt8UReverseResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPTestClusterClusterTestListInt8UReverseResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TestClusterCluster, testListStructArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint a, jboolean b, jint c, jbyteArray d, jstring e, jint f)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    JniByteArray * dArr = new JniByteArray(env, d);
    JniUtfString * eStr = new JniUtfString(env, e);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, a, b, c, dArr, eStr, f](chip::Callback::Cancelable * success,
                                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->TestListStructArgumentRequest(success, failure, a, b, static_cast<uint8_t>(c),
                                                                   chip::ByteSpan((const uint8_t *) dArr->data(), dArr->size()),
                                                                   chip::CharSpan(eStr->c_str(), strlen(eStr->c_str())), f);
        delete dArr;
        delete eStr;
        return err;
    };

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        commandCallback(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TestClusterCluster, testNotHandled)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->TestNotHandled(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TestClusterCluster, testNullableOptionalRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, arg1](chip::Callback::Cancelable * success,
                                                           chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->TestNullableOptionalRequest(success, failure, arg1);
        return err;
    };

    std::unique_ptr<CHIPTestClusterClusterTestNullableOptionalResponseCallback,
                    void (*)(CHIPTestClusterClusterTestNullableOptionalResponseCallback *)>
        commandCallback(Platform::New<CHIPTestClusterClusterTestNullableOptionalResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPTestClusterClusterTestNullableOptionalResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TestClusterCluster, testSpecific)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->TestSpecific(success, failure);
        return err;
    };

    std::unique_ptr<CHIPTestClusterClusterTestSpecificResponseCallback,
                    void (*)(CHIPTestClusterClusterTestSpecificResponseCallback *)>
        commandCallback(Platform::New<CHIPTestClusterClusterTestSpecificResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPTestClusterClusterTestSpecificResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TestClusterCluster, testStructArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint a, jboolean b, jint c, jbyteArray d, jstring e, jint f)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    JniByteArray * dArr = new JniByteArray(env, d);
    JniUtfString * eStr = new JniUtfString(env, e);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, a, b, c, dArr, eStr, f](chip::Callback::Cancelable * success,
                                                                             chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->TestStructArgumentRequest(success, failure, a, b, static_cast<uint8_t>(c),
                                                               chip::ByteSpan((const uint8_t *) dArr->data(), dArr->size()),
                                                               chip::CharSpan(eStr->c_str(), strlen(eStr->c_str())), f);
        delete dArr;
        delete eStr;
        return err;
    };

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        commandCallback(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback, actionBlock),
                        Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, TestClusterCluster, testUnknownCommand)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->TestUnknownCommand(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeBoolean(success, failure, static_cast<bool>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeBitmap8(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeBitmap16(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeBitmap32(success, failure, static_cast<uint32_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeBitmap64(success, failure, static_cast<uint64_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeInt8u(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeInt16u(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeInt32u(success, failure, static_cast<uint32_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeInt64u(success, failure, static_cast<uint64_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeInt8s(success, failure, static_cast<int8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeInt16s(success, failure, static_cast<int16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeInt32s(success, failure, static_cast<int32_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeInt64s(success, failure, static_cast<int64_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeEnum8(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeEnum16(success, failure, static_cast<uint16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value, env](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        JniByteArray valueJniArr(env, value);
        return cppCluster->WriteAttributeOctetString(success, failure,
                                                     chip::ByteSpan((const uint8_t *) valueJniArr.data(), valueJniArr.size()));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeLongOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value, env](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        JniByteArray valueJniArr(env, value);
        return cppCluster->WriteAttributeLongOctetString(success, failure,
                                                         chip::ByteSpan((const uint8_t *) valueJniArr.data(), valueJniArr.size()));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value, env](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        JniUtfString valueStr(env, value);
        return cppCluster->WriteAttributeCharString(success, failure, chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeLongCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value, env](chip::Callback::Cancelable * success,
                                                                 chip::Callback::Cancelable * failure) {
        JniUtfString valueStr(env, value);
        return cppCluster->WriteAttributeLongCharString(success, failure,
                                                        chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeEpochUsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeEpochUs(success, failure, static_cast<uint64_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeEpochSAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeEpochS(success, failure, static_cast<uint32_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeVendorId(success, failure, static_cast<chip::VendorId>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, TestClusterCluster, writeUnsupportedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;

    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeUnsupported(success, failure, static_cast<bool>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, ThermostatCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatCluster * cppCluster = new ThermostatCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatCluster, clearWeeklySchedule)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatCluster * cppCluster;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ClearWeeklySchedule(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ThermostatCluster, getRelayStatusLog)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatCluster * cppCluster;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetRelayStatusLog(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ThermostatCluster, getWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint daysToReturn, jint modeToReturn)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatCluster * cppCluster;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, daysToReturn, modeToReturn](chip::Callback::Cancelable * success,
                                                                                 chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GetWeeklySchedule(success, failure, daysToReturn, modeToReturn);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ThermostatCluster, setWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint numberOfTransitionsForSequence, jint dayOfWeekForSequence,
 jint modeForSequence, jint payload)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatCluster * cppCluster;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, numberOfTransitionsForSequence, dayOfWeekForSequence, modeForSequence,
                                         payload](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->SetWeeklySchedule(success, failure, numberOfTransitionsForSequence, dayOfWeekForSequence,
                                                       modeForSequence, payload);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, ThermostatCluster, setpointRaiseLower)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint mode, jint amount)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatCluster * cppCluster;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, mode, amount](chip::Callback::Cancelable * success,
                                                                   chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->SetpointRaiseLower(success, failure, static_cast<uint8_t>(mode), amount);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, ThermostatCluster, subscribeLocalTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeLocalTemperature(success, failure, static_cast<uint16_t>(minInterval),
                                                              static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, ThermostatCluster, reportLocalTemperatureAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeLocalTemperature(success);
    };

    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedCoolingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOccupiedCoolingSetpoint(success, failure, static_cast<int16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedHeatingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeOccupiedHeatingSetpoint(success, failure, static_cast<int16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeMinHeatSetpointLimit(success, failure, static_cast<int16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ThermostatCluster, writeMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeMaxHeatSetpointLimit(success, failure, static_cast<int16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeMinCoolSetpointLimit(success, failure, static_cast<int16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ThermostatCluster, writeMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeMaxCoolSetpointLimit(success, failure, static_cast<int16_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinSetpointDeadBandAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeMinSetpointDeadBand(success, failure, static_cast<int8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ThermostatCluster, writeControlSequenceOfOperationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeControlSequenceOfOperation(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ThermostatCluster, writeSystemModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeSystemMode(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, ThermostatUserInterfaceConfigurationCluster, initWithDevice)
(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatUserInterfaceConfigurationCluster * cppCluster = new ThermostatUserInterfaceConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeTemperatureDisplayModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeTemperatureDisplayMode(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeKeypadLockoutAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeKeypadLockout(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeScheduleProgrammingVisibilityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeScheduleProgrammingVisibility(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}
JNI_METHOD(jlong, ThreadNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThreadNetworkDiagnosticsCluster * cppCluster = new ThreadNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    ThreadNetworkDiagnosticsCluster * cppCluster;

    cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ResetCounts(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, WakeOnLanCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WakeOnLanCluster * cppCluster = new WakeOnLanCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, WiFiNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WiFiNetworkDiagnosticsCluster * cppCluster = new WiFiNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    WiFiNetworkDiagnosticsCluster * cppCluster;

    cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->ResetCounts(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(jlong, WindowCoveringCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster = new WindowCoveringCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WindowCoveringCluster, downOrClose)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->DownOrClose(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToLiftPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint liftPercentageValue, jint liftPercent100thsValue)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, liftPercentageValue, liftPercent100thsValue](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GoToLiftPercentage(success, failure, liftPercentageValue, liftPercent100thsValue);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToLiftValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint liftValue)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, liftValue](chip::Callback::Cancelable * success,
                                                                chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GoToLiftValue(success, failure, liftValue);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToTiltPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint tiltPercentageValue, jint tiltPercent100thsValue)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, tiltPercentageValue, tiltPercent100thsValue](
                                            chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GoToTiltPercentage(success, failure, tiltPercentageValue, tiltPercent100thsValue);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToTiltValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint tiltValue)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, tiltValue](chip::Callback::Cancelable * success,
                                                                chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->GoToTiltValue(success, failure, tiltValue);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, WindowCoveringCluster, stopMotion)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->StopMotion(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}
JNI_METHOD(void, WindowCoveringCluster, upOrOpen)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not obtain native cluster object", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        CHIP_ERROR err = cppCluster->UpOrOpen(success, failure);
        return err;
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> commandCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(commandCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    commandCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionLiftPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentPositionLiftPercentage(success, failure, static_cast<uint16_t>(minInterval),
                                                                           static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionLiftPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentPositionLiftPercentage(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionTiltPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentPositionTiltPercentage(success, failure, static_cast<uint16_t>(minInterval),
                                                                           static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionTiltPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentPositionTiltPercentage(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeOperationalStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeOperationalStatus(success, failure, static_cast<uint16_t>(minInterval),
                                                               static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportOperationalStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeOperationalStatus(success);
    };

    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeTargetPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeTargetPositionLiftPercent100ths(success, failure, static_cast<uint16_t>(minInterval),
                                                                             static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportTargetPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeTargetPositionLiftPercent100ths(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeTargetPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeTargetPositionTiltPercent100ths(success, failure, static_cast<uint16_t>(minInterval),
                                                                             static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportTargetPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeTargetPositionTiltPercent100ths(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentPositionLiftPercent100ths(success, failure, static_cast<uint16_t>(minInterval),
                                                                              static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentPositionLiftPercent100ths(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeCurrentPositionTiltPercent100ths(success, failure, static_cast<uint16_t>(minInterval),
                                                                              static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeCurrentPositionTiltPercent100ths(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, writeModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, value](chip::Callback::Cancelable * success,
                                                            chip::Callback::Cancelable * failure) {
        return cppCluster->WriteAttributeMode(success, failure, static_cast<uint8_t>(value));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> writeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(writeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    writeCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeSafetyStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster, minInterval, maxInterval](chip::Callback::Cancelable * success,
                                                                               chip::Callback::Cancelable * failure) {
        return cppCluster->SubscribeAttributeSafetyStatus(success, failure, static_cast<uint16_t>(minInterval),
                                                          static_cast<uint16_t>(maxInterval));
    };

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> subscribeCallback(
        Platform::New<CHIPDefaultSuccessCallback>(callback, actionBlock), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(subscribeCallback.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    subscribeCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportSafetyStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReportAttributeSafetyStatus(success);
    };

    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, actionBlock, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    onReport.release();
}
