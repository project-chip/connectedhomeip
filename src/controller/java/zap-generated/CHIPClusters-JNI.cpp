/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#include "CHIPCallbackTypes.h"
#include "CHIPInvokeCallbacks.h"
#include "CHIPReadCallbacks.h"

#include <app-common/zap-generated/cluster-objects.h>
#include <zap-generated/CHIPClientCallbacks.h>
#include <zap-generated/CHIPClusters.h>

#include <controller/java/AndroidClusterExceptions.h>
#include <controller/java/CHIPDefaultCallbacks.h>
#include <jni.h>
#include <lib/support/CodeUtils.h>
#include <lib/support/JniReferences.h>
#include <lib/support/JniTypeWrappers.h>
#include <lib/support/Span.h>
#include <platform/PlatformManager.h>

#define JNI_METHOD(RETURN, CLASS_NAME, METHOD_NAME)                                                                                \
    extern "C" JNIEXPORT RETURN JNICALL Java_chip_devicecontroller_ChipClusters_00024##CLASS_NAME##_##METHOD_NAME

using namespace chip;
using namespace chip::Controller;

JNI_METHOD(void, BaseChipCluster, deleteCluster)(JNIEnv * env, jobject self, jlong clusterPtr)
{
    chip::DeviceLayer::StackLock lock;
    ClusterBase * cluster = reinterpret_cast<ClusterBase *>(clusterPtr);
    if (cluster != nullptr)
    {
        delete cluster;
    }
}

JNI_METHOD(jlong, AccountLoginCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AccountLoginCluster * cppCluster = new AccountLoginCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AccountLoginCluster, getSetupPIN)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster;

    chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type request;

    request.tempAccountIdentifier = chip::JniUtfString(env, static_cast<jstring>(tempAccountIdentifier)).charSpan();

    std::unique_ptr<CHIPAccountLoginClusterGetSetupPINResponseCallback,
                    void (*)(CHIPAccountLoginClusterGetSetupPINResponseCallback *)>
        onSuccess(Platform::New<CHIPAccountLoginClusterGetSetupPINResponseCallback>(callback),
                  Platform::Delete<CHIPAccountLoginClusterGetSetupPINResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPAccountLoginClusterGetSetupPINResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AccountLoginCluster, login)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier, jstring setupPIN)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster;

    chip::app::Clusters::AccountLogin::Commands::Login::Type request;

    request.tempAccountIdentifier = chip::JniUtfString(env, static_cast<jstring>(tempAccountIdentifier)).charSpan();
    request.setupPIN              = chip::JniUtfString(env, static_cast<jstring>(setupPIN)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, AdministratorCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AdministratorCommissioningCluster * cppCluster = new AdministratorCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AdministratorCommissioningCluster, openBasicCommissioningWindow)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject commissioningTimeout)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type request;

    request.commissioningTimeout = static_cast<decltype(request.commissioningTimeout)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(commissioningTimeout));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AdministratorCommissioningCluster, openCommissioningWindow)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject commissioningTimeout, jbyteArray PAKEVerifier,
 jobject discriminator, jobject iterations, jbyteArray salt, jobject passcodeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type request;

    request.commissioningTimeout = static_cast<decltype(request.commissioningTimeout)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(commissioningTimeout));
    request.PAKEVerifier = chip::JniByteArray(env, static_cast<jbyteArray>(PAKEVerifier)).byteSpan();
    request.discriminator =
        static_cast<decltype(request.discriminator)>(chip::JniReferences::GetInstance().IntegerToPrimitive(discriminator));
    request.iterations = static_cast<decltype(request.iterations)>(chip::JniReferences::GetInstance().LongToPrimitive(iterations));
    request.salt       = chip::JniByteArray(env, static_cast<jbyteArray>(salt)).byteSpan();
    request.passcodeID =
        static_cast<decltype(request.passcodeID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(passcodeID));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AdministratorCommissioningCluster, revokeCommissioning)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    chip::app::Clusters::AdministratorCommissioning::Commands::RevokeCommissioning::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ApplicationBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ApplicationBasicCluster * cppCluster = new ApplicationBasicCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationBasicCluster, changeStatus)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject status)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster;

    chip::app::Clusters::ApplicationBasic::Commands::ChangeStatus::Type request;

    request.status = static_cast<decltype(request.status)>(chip::JniReferences::GetInstance().IntegerToPrimitive(status));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ApplicationLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ApplicationLauncherCluster * cppCluster = new ApplicationLauncherCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationLauncherCluster, launchApp)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring data, jobject catalogVendorId, jstring applicationId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster;

    chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type request;

    request.data = chip::JniUtfString(env, static_cast<jstring>(data)).charSpan();
    request.catalogVendorId =
        static_cast<decltype(request.catalogVendorId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(catalogVendorId));
    request.applicationId = chip::JniUtfString(env, static_cast<jstring>(applicationId)).charSpan();

    std::unique_ptr<CHIPApplicationLauncherClusterLaunchAppResponseCallback,
                    void (*)(CHIPApplicationLauncherClusterLaunchAppResponseCallback *)>
        onSuccess(Platform::New<CHIPApplicationLauncherClusterLaunchAppResponseCallback>(callback),
                  Platform::Delete<CHIPApplicationLauncherClusterLaunchAppResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPApplicationLauncherClusterLaunchAppResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, AudioOutputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AudioOutputCluster * cppCluster = new AudioOutputCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AudioOutputCluster, renameOutput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject index, jstring name)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster;

    chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type request;

    request.index = static_cast<decltype(request.index)>(chip::JniReferences::GetInstance().IntegerToPrimitive(index));
    request.name  = chip::JniUtfString(env, static_cast<jstring>(name)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AudioOutputCluster, selectOutput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject index)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster;

    chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type request;

    request.index = static_cast<decltype(request.index)>(chip::JniReferences::GetInstance().IntegerToPrimitive(index));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, BarrierControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BarrierControlCluster * cppCluster = new BarrierControlCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BarrierControlCluster, barrierControlGoToPercent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject percentOpen)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster;

    chip::app::Clusters::BarrierControl::Commands::BarrierControlGoToPercent::Type request;

    request.percentOpen =
        static_cast<decltype(request.percentOpen)>(chip::JniReferences::GetInstance().IntegerToPrimitive(percentOpen));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BarrierControlCluster, barrierControlStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster;

    chip::app::Clusters::BarrierControl::Commands::BarrierControlStop::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, BasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BasicCluster * cppCluster = new BasicCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BasicCluster, mfgSpecificPing)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BasicCluster * cppCluster;

    chip::app::Clusters::Basic::Commands::MfgSpecificPing::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, writeUserLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeUserLabel(onSuccess->Cancel(), onFailure->Cancel(),
                                              chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, writeLocationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeLocation(onSuccess->Cancel(), onFailure->Cancel(),
                                             chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, writeLocalConfigDisabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeLocalConfigDisabled(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, BinaryInputBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BinaryInputBasicCluster * cppCluster = new BinaryInputBasicCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BinaryInputBasicCluster, writeOutOfServiceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOutOfService(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, writePresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributePresentValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, subscribePresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePresentValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, reportPresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePresentValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, subscribeStatusFlagsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStatusFlags(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, reportStatusFlagsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStatusFlags(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BindingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BindingCluster * cppCluster = new BindingCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BindingCluster, bind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject nodeId, jobject groupId, jobject endpointId,
 jobject clusterId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BindingCluster * cppCluster;

    chip::app::Clusters::Binding::Commands::Bind::Type request;

    request.nodeId  = static_cast<decltype(request.nodeId)>(chip::JniReferences::GetInstance().LongToPrimitive(nodeId));
    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.endpointId =
        static_cast<decltype(request.endpointId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(endpointId));
    request.clusterId = static_cast<decltype(request.clusterId)>(chip::JniReferences::GetInstance().LongToPrimitive(clusterId));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BindingCluster, unbind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject nodeId, jobject groupId, jobject endpointId,
 jobject clusterId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BindingCluster * cppCluster;

    chip::app::Clusters::Binding::Commands::Unbind::Type request;

    request.nodeId  = static_cast<decltype(request.nodeId)>(chip::JniReferences::GetInstance().LongToPrimitive(nodeId));
    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.endpointId =
        static_cast<decltype(request.endpointId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(endpointId));
    request.clusterId = static_cast<decltype(request.clusterId)>(chip::JniReferences::GetInstance().LongToPrimitive(clusterId));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, BooleanStateCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BooleanStateCluster * cppCluster = new BooleanStateCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BooleanStateCluster, subscribeStateValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    BooleanStateCluster * cppCluster = reinterpret_cast<BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStateValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BooleanStateCluster, reportStateValueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    BooleanStateCluster * cppCluster = reinterpret_cast<BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStateValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BridgedActionsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster = new BridgedActionsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BridgedActionsCluster, disableAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::DisableAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, disableActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID, jobject duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::DisableActionWithDuration::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));
    request.duration = static_cast<decltype(request.duration)>(chip::JniReferences::GetInstance().LongToPrimitive(duration));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, enableAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::EnableAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, enableActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID, jobject duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::EnableActionWithDuration::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));
    request.duration = static_cast<decltype(request.duration)>(chip::JniReferences::GetInstance().LongToPrimitive(duration));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, instantAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::InstantAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, instantActionWithTransition)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID, jobject transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::InstantActionWithTransition::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, pauseAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::PauseAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, pauseActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID, jobject duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::PauseActionWithDuration::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));
    request.duration = static_cast<decltype(request.duration)>(chip::JniReferences::GetInstance().LongToPrimitive(duration));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, resumeAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::ResumeAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, startAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::StartAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, startActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID, jobject duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::StartActionWithDuration::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));
    request.duration = static_cast<decltype(request.duration)>(chip::JniReferences::GetInstance().LongToPrimitive(duration));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, stopAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::StopAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, BridgedDeviceBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BridgedDeviceBasicCluster * cppCluster = new BridgedDeviceBasicCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BridgedDeviceBasicCluster, writeUserLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeUserLabel(onSuccess->Cancel(), onFailure->Cancel(),
                                              chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ColorControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster = new ColorControlCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ColorControlCluster, colorLoopSet)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject updateFlags, jobject action, jobject direction,
 jobject time, jobject startHue, jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;

    request.updateFlags =
        static_cast<decltype(request.updateFlags)>(chip::JniReferences::GetInstance().IntegerToPrimitive(updateFlags));
    request.action    = static_cast<decltype(request.action)>(chip::JniReferences::GetInstance().IntegerToPrimitive(action));
    request.direction = static_cast<decltype(request.direction)>(chip::JniReferences::GetInstance().IntegerToPrimitive(direction));
    request.time      = static_cast<decltype(request.time)>(chip::JniReferences::GetInstance().IntegerToPrimitive(time));
    request.startHue  = static_cast<decltype(request.startHue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(startHue));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate, jobject optionsMask,
 jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject enhancedHue, jobject direction, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type request;

    request.enhancedHue =
        static_cast<decltype(request.enhancedHue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(enhancedHue));
    request.direction = static_cast<decltype(request.direction)>(chip::JniReferences::GetInstance().IntegerToPrimitive(direction));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject enhancedHue, jobject saturation, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type request;

    request.enhancedHue =
        static_cast<decltype(request.enhancedHue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(enhancedHue));
    request.saturation =
        static_cast<decltype(request.saturation)>(chip::JniReferences::GetInstance().IntegerToPrimitive(saturation));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedStepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject rateX, jobject rateY, jobject optionsMask,
 jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveColor::Type request;

    request.rateX = static_cast<decltype(request.rateX)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rateX));
    request.rateY = static_cast<decltype(request.rateY)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rateY));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate, jobject colorTemperatureMinimum,
 jobject colorTemperatureMaximum, jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));
    request.colorTemperatureMinimum = static_cast<decltype(request.colorTemperatureMinimum)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(colorTemperatureMinimum));
    request.colorTemperatureMaximum = static_cast<decltype(request.colorTemperatureMaximum)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(colorTemperatureMaximum));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate, jobject optionsMask,
 jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveHue::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate, jobject optionsMask,
 jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveToColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject colorX, jobject colorY, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveToColor::Type request;

    request.colorX = static_cast<decltype(request.colorX)>(chip::JniReferences::GetInstance().IntegerToPrimitive(colorX));
    request.colorY = static_cast<decltype(request.colorY)>(chip::JniReferences::GetInstance().IntegerToPrimitive(colorY));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveToColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject colorTemperature, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type request;

    request.colorTemperature =
        static_cast<decltype(request.colorTemperature)>(chip::JniReferences::GetInstance().IntegerToPrimitive(colorTemperature));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject hue, jobject direction, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveToHue::Type request;

    request.hue       = static_cast<decltype(request.hue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(hue));
    request.direction = static_cast<decltype(request.direction)>(chip::JniReferences::GetInstance().IntegerToPrimitive(direction));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject hue, jobject saturation, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type request;

    request.hue = static_cast<decltype(request.hue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(hue));
    request.saturation =
        static_cast<decltype(request.saturation)>(chip::JniReferences::GetInstance().IntegerToPrimitive(saturation));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveToSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject saturation, jobject transitionTime, jobject optionsMask,
 jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type request;

    request.saturation =
        static_cast<decltype(request.saturation)>(chip::JniReferences::GetInstance().IntegerToPrimitive(saturation));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, stepColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepX, jobject stepY, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::StepColor::Type request;

    request.stepX = static_cast<decltype(request.stepX)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepX));
    request.stepY = static_cast<decltype(request.stepY)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepY));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, stepColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime,
 jobject colorTemperatureMinimum, jobject colorTemperatureMaximum, jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.colorTemperatureMinimum = static_cast<decltype(request.colorTemperatureMinimum)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(colorTemperatureMinimum));
    request.colorTemperatureMaximum = static_cast<decltype(request.colorTemperatureMaximum)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(colorTemperatureMaximum));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, stepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::StepHue::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, stepSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::StepSaturation::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, stopMoveStep)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type request;

    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentHue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentHueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentHue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentSaturationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentSaturation(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentSaturationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentSaturation(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentX(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentY(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeColorTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorTemperature(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorTemperature(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorControlOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorControlOptions(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeWhitePointX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeWhitePointY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointRX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointRY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointRIntensity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointGX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointGY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointGIntensity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointBX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointBY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointBIntensity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeStartUpColorTemperatureMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeStartUpColorTemperatureMireds(onSuccess->Cancel(), onFailure->Cancel(),
                                                                  static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ContentLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ContentLauncherCluster * cppCluster = new ContentLauncherCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ContentLauncherCluster, launchContent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject autoPlay, jstring data)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster;

    chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type request;

    request.autoPlay = static_cast<decltype(request.autoPlay)>(chip::JniReferences::GetInstance().BooleanToPrimitive(autoPlay));
    request.data     = chip::JniUtfString(env, static_cast<jstring>(data)).charSpan();

    std::unique_ptr<CHIPContentLauncherClusterLaunchContentResponseCallback,
                    void (*)(CHIPContentLauncherClusterLaunchContentResponseCallback *)>
        onSuccess(Platform::New<CHIPContentLauncherClusterLaunchContentResponseCallback>(callback),
                  Platform::Delete<CHIPContentLauncherClusterLaunchContentResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPContentLauncherClusterLaunchContentResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ContentLauncherCluster, launchURL)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring contentURL, jstring displayString)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster;

    chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type request;

    request.contentURL    = chip::JniUtfString(env, static_cast<jstring>(contentURL)).charSpan();
    request.displayString = chip::JniUtfString(env, static_cast<jstring>(displayString)).charSpan();

    std::unique_ptr<CHIPContentLauncherClusterLaunchURLResponseCallback,
                    void (*)(CHIPContentLauncherClusterLaunchURLResponseCallback *)>
        onSuccess(Platform::New<CHIPContentLauncherClusterLaunchURLResponseCallback>(callback),
                  Platform::Delete<CHIPContentLauncherClusterLaunchURLResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPContentLauncherClusterLaunchURLResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, DescriptorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DescriptorCluster * cppCluster = new DescriptorCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, DiagnosticLogsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DiagnosticLogsCluster * cppCluster = new DiagnosticLogsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DiagnosticLogsCluster, retrieveLogsRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject intent, jobject requestedProtocol,
 jbyteArray transferFileDesignator)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DiagnosticLogsCluster * cppCluster;

    chip::app::Clusters::DiagnosticLogs::Commands::RetrieveLogsRequest::Type request;

    request.intent = static_cast<decltype(request.intent)>(chip::JniReferences::GetInstance().IntegerToPrimitive(intent));
    request.requestedProtocol =
        static_cast<decltype(request.requestedProtocol)>(chip::JniReferences::GetInstance().IntegerToPrimitive(requestedProtocol));
    request.transferFileDesignator = chip::JniByteArray(env, static_cast<jbyteArray>(transferFileDesignator)).byteSpan();

    std::unique_ptr<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback,
                    void (*)(CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback *)>
        onSuccess(Platform::New<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback>(callback),
                  Platform::Delete<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DiagnosticLogsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, DoorLockCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster = new DoorLockCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DoorLockCluster, clearAllPins)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearAllPins::Type request;

    std::unique_ptr<CHIPDoorLockClusterClearAllPinsResponseCallback, void (*)(CHIPDoorLockClusterClearAllPinsResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearAllPinsResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearAllPinsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterClearAllPinsResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearAllRfids)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearAllRfids::Type request;

    std::unique_ptr<CHIPDoorLockClusterClearAllRfidsResponseCallback, void (*)(CHIPDoorLockClusterClearAllRfidsResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearAllRfidsResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearAllRfidsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterClearAllRfidsResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject scheduleId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearHolidaySchedule::Type request;

    request.scheduleId =
        static_cast<decltype(request.scheduleId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(scheduleId));

    std::unique_ptr<CHIPDoorLockClusterClearHolidayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterClearHolidayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearHolidayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearHolidayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterClearHolidayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearPin)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearPin::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterClearPinResponseCallback, void (*)(CHIPDoorLockClusterClearPinResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterClearPinResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterClearPinResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDoorLockClusterClearPinResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearRfid)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearRfid::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterClearRfidResponseCallback, void (*)(CHIPDoorLockClusterClearRfidResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearRfidResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearRfidResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterClearRfidResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject scheduleId, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearWeekdaySchedule::Type request;

    request.scheduleId =
        static_cast<decltype(request.scheduleId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(scheduleId));
    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterClearWeekdayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterClearWeekdayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject scheduleId, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearYeardaySchedule::Type request;

    request.scheduleId =
        static_cast<decltype(request.scheduleId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(scheduleId));
    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterClearYeardayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterClearYeardayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearYeardayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearYeardayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterClearYeardayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject scheduleId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetHolidaySchedule::Type request;

    request.scheduleId =
        static_cast<decltype(request.scheduleId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(scheduleId));

    std::unique_ptr<CHIPDoorLockClusterGetHolidayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetHolidayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetHolidayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetHolidayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetHolidayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getLogRecord)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject logIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetLogRecord::Type request;

    request.logIndex = static_cast<decltype(request.logIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(logIndex));

    std::unique_ptr<CHIPDoorLockClusterGetLogRecordResponseCallback, void (*)(CHIPDoorLockClusterGetLogRecordResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetLogRecordResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetLogRecordResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetLogRecordResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getPin)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetPin::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterGetPinResponseCallback, void (*)(CHIPDoorLockClusterGetPinResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterGetPinResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterGetPinResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDoorLockClusterGetPinResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getRfid)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetRfid::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterGetRfidResponseCallback, void (*)(CHIPDoorLockClusterGetRfidResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterGetRfidResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterGetRfidResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDoorLockClusterGetRfidResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getUserType)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetUserType::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterGetUserTypeResponseCallback, void (*)(CHIPDoorLockClusterGetUserTypeResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetUserTypeResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetUserTypeResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetUserTypeResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject scheduleId, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetWeekdaySchedule::Type request;

    request.scheduleId =
        static_cast<decltype(request.scheduleId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(scheduleId));
    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetWeekdayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetWeekdayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject scheduleId, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetYeardaySchedule::Type request;

    request.scheduleId =
        static_cast<decltype(request.scheduleId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(scheduleId));
    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterGetYeardayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetYeardayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetYeardayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetYeardayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetYeardayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, lockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::LockDoor::Type request;

    request.pin = chip::JniByteArray(env, static_cast<jbyteArray>(pin)).byteSpan();

    std::unique_ptr<CHIPDoorLockClusterLockDoorResponseCallback, void (*)(CHIPDoorLockClusterLockDoorResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterLockDoorResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterLockDoorResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDoorLockClusterLockDoorResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject scheduleId, jobject localStartTime, jobject localEndTime,
 jobject operatingModeDuringHoliday)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetHolidaySchedule::Type request;

    request.scheduleId =
        static_cast<decltype(request.scheduleId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(scheduleId));
    request.localStartTime =
        static_cast<decltype(request.localStartTime)>(chip::JniReferences::GetInstance().LongToPrimitive(localStartTime));
    request.localEndTime =
        static_cast<decltype(request.localEndTime)>(chip::JniReferences::GetInstance().LongToPrimitive(localEndTime));
    request.operatingModeDuringHoliday = static_cast<decltype(request.operatingModeDuringHoliday)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(operatingModeDuringHoliday));

    std::unique_ptr<CHIPDoorLockClusterSetHolidayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterSetHolidayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterSetHolidayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterSetHolidayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterSetHolidayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setPin)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId, jobject userStatus, jobject userType,
 jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetPin::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));
    request.userStatus =
        static_cast<decltype(request.userStatus)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userStatus));
    request.userType = static_cast<decltype(request.userType)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userType));
    request.pin      = chip::JniByteArray(env, static_cast<jbyteArray>(pin)).byteSpan();

    std::unique_ptr<CHIPDoorLockClusterSetPinResponseCallback, void (*)(CHIPDoorLockClusterSetPinResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterSetPinResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterSetPinResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDoorLockClusterSetPinResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setRfid)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId, jobject userStatus, jobject userType,
 jbyteArray id)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetRfid::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));
    request.userStatus =
        static_cast<decltype(request.userStatus)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userStatus));
    request.userType = static_cast<decltype(request.userType)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userType));
    request.id       = chip::JniByteArray(env, static_cast<jbyteArray>(id)).byteSpan();

    std::unique_ptr<CHIPDoorLockClusterSetRfidResponseCallback, void (*)(CHIPDoorLockClusterSetRfidResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterSetRfidResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterSetRfidResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDoorLockClusterSetRfidResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setUserType)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId, jobject userType)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetUserType::Type request;

    request.userId   = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));
    request.userType = static_cast<decltype(request.userType)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userType));

    std::unique_ptr<CHIPDoorLockClusterSetUserTypeResponseCallback, void (*)(CHIPDoorLockClusterSetUserTypeResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterSetUserTypeResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterSetUserTypeResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterSetUserTypeResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject scheduleId, jobject userId, jobject daysMask,
 jobject startHour, jobject startMinute, jobject endHour, jobject endMinute)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetWeekdaySchedule::Type request;

    request.scheduleId =
        static_cast<decltype(request.scheduleId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(scheduleId));
    request.userId    = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));
    request.daysMask  = static_cast<decltype(request.daysMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(daysMask));
    request.startHour = static_cast<decltype(request.startHour)>(chip::JniReferences::GetInstance().IntegerToPrimitive(startHour));
    request.startMinute =
        static_cast<decltype(request.startMinute)>(chip::JniReferences::GetInstance().IntegerToPrimitive(startMinute));
    request.endHour   = static_cast<decltype(request.endHour)>(chip::JniReferences::GetInstance().IntegerToPrimitive(endHour));
    request.endMinute = static_cast<decltype(request.endMinute)>(chip::JniReferences::GetInstance().IntegerToPrimitive(endMinute));

    std::unique_ptr<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterSetWeekdayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterSetWeekdayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject scheduleId, jobject userId, jobject localStartTime,
 jobject localEndTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetYeardaySchedule::Type request;

    request.scheduleId =
        static_cast<decltype(request.scheduleId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(scheduleId));
    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));
    request.localStartTime =
        static_cast<decltype(request.localStartTime)>(chip::JniReferences::GetInstance().LongToPrimitive(localStartTime));
    request.localEndTime =
        static_cast<decltype(request.localEndTime)>(chip::JniReferences::GetInstance().LongToPrimitive(localEndTime));

    std::unique_ptr<CHIPDoorLockClusterSetYeardayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterSetYeardayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterSetYeardayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterSetYeardayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterSetYeardayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, unlockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type request;

    request.pin = chip::JniByteArray(env, static_cast<jbyteArray>(pin)).byteSpan();

    std::unique_ptr<CHIPDoorLockClusterUnlockDoorResponseCallback, void (*)(CHIPDoorLockClusterUnlockDoorResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterUnlockDoorResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterUnlockDoorResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterUnlockDoorResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, unlockWithTimeout)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject timeoutInSeconds, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::UnlockWithTimeout::Type request;

    request.timeoutInSeconds =
        static_cast<decltype(request.timeoutInSeconds)>(chip::JniReferences::GetInstance().IntegerToPrimitive(timeoutInSeconds));
    request.pin = chip::JniByteArray(env, static_cast<jbyteArray>(pin)).byteSpan();

    std::unique_ptr<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback,
                    void (*)(CHIPDoorLockClusterUnlockWithTimeoutResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterUnlockWithTimeoutResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, subscribeLockStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLockState(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, reportLockStateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLockState(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ElectricalMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ElectricalMeasurementCluster * cppCluster = new ElectricalMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, EthernetNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    EthernetNetworkDiagnosticsCluster * cppCluster = new EthernetNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster;

    chip::app::Clusters::EthernetNetworkDiagnostics::Commands::ResetCounts::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, FixedLabelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    FixedLabelCluster * cppCluster = new FixedLabelCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, FlowMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    FlowMeasurementCluster * cppCluster = new FlowMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GeneralCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GeneralCommissioningCluster * cppCluster = new GeneralCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GeneralCommissioningCluster, armFailSafe)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject expiryLengthSeconds, jobject breadcrumb, jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafe::Type request;

    request.expiryLengthSeconds = static_cast<decltype(request.expiryLengthSeconds)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(expiryLengthSeconds));
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterArmFailSafeResponseCallback *)>
        onSuccess(Platform::New<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback>(callback),
                  Platform::Delete<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPGeneralCommissioningClusterArmFailSafeResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GeneralCommissioningCluster, commissioningComplete)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    chip::app::Clusters::GeneralCommissioning::Commands::CommissioningComplete::Type request;

    std::unique_ptr<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback *)>
        onSuccess(Platform::New<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback>(callback),
                  Platform::Delete<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallbackType>::FromCancelable(
            onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GeneralCommissioningCluster, setRegulatoryConfig)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject location, jstring countryCode, jobject breadcrumb,
 jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    chip::app::Clusters::GeneralCommissioning::Commands::SetRegulatoryConfig::Type request;

    request.location    = static_cast<decltype(request.location)>(chip::JniReferences::GetInstance().IntegerToPrimitive(location));
    request.countryCode = chip::JniUtfString(env, static_cast<jstring>(countryCode)).charSpan();
    request.breadcrumb  = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs   = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback *)>
        onSuccess(Platform::New<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback>(callback),
                  Platform::Delete<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallbackType>::FromCancelable(
            onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralCommissioningCluster, writeBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBreadcrumb(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, GeneralDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GeneralDiagnosticsCluster * cppCluster = new GeneralDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GroupKeyManagementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GroupKeyManagementCluster * cppCluster = new GroupKeyManagementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GroupsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GroupsCluster * cppCluster = new GroupsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GroupsCluster, addGroup)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jstring groupName)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::AddGroup::Type request;

    request.groupId   = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.groupName = chip::JniUtfString(env, static_cast<jstring>(groupName)).charSpan();

    std::unique_ptr<CHIPGroupsClusterAddGroupResponseCallback, void (*)(CHIPGroupsClusterAddGroupResponseCallback *)> onSuccess(
        Platform::New<CHIPGroupsClusterAddGroupResponseCallback>(callback),
        Platform::Delete<CHIPGroupsClusterAddGroupResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPGroupsClusterAddGroupResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, addGroupIfIdentifying)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jstring groupName)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::AddGroupIfIdentifying::Type request;

    request.groupId   = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.groupName = chip::JniUtfString(env, static_cast<jstring>(groupName)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, getGroupMembership)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupCount, jobject groupList)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::GetGroupMembership::Type request;

    request.groupCount =
        static_cast<decltype(request.groupCount)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupCount));
    request.groupList = chip::app::DataModel::List<const uint16_t>();

    std::unique_ptr<CHIPGroupsClusterGetGroupMembershipResponseCallback,
                    void (*)(CHIPGroupsClusterGetGroupMembershipResponseCallback *)>
        onSuccess(Platform::New<CHIPGroupsClusterGetGroupMembershipResponseCallback>(callback),
                  Platform::Delete<CHIPGroupsClusterGetGroupMembershipResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPGroupsClusterGetGroupMembershipResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, removeAllGroups)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, removeGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::RemoveGroup::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));

    std::unique_ptr<CHIPGroupsClusterRemoveGroupResponseCallback, void (*)(CHIPGroupsClusterRemoveGroupResponseCallback *)>
        onSuccess(Platform::New<CHIPGroupsClusterRemoveGroupResponseCallback>(callback),
                  Platform::Delete<CHIPGroupsClusterRemoveGroupResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPGroupsClusterRemoveGroupResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, viewGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::ViewGroup::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));

    std::unique_ptr<CHIPGroupsClusterViewGroupResponseCallback, void (*)(CHIPGroupsClusterViewGroupResponseCallback *)> onSuccess(
        Platform::New<CHIPGroupsClusterViewGroupResponseCallback>(callback),
        Platform::Delete<CHIPGroupsClusterViewGroupResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPGroupsClusterViewGroupResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, IdentifyCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    IdentifyCluster * cppCluster = new IdentifyCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, IdentifyCluster, identify)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject identifyTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    chip::app::Clusters::Identify::Commands::Identify::Type request;

    request.identifyTime =
        static_cast<decltype(request.identifyTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(identifyTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, IdentifyCluster, identifyQuery)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    chip::app::Clusters::Identify::Commands::IdentifyQuery::Type request;

    std::unique_ptr<CHIPIdentifyClusterIdentifyQueryResponseCallback, void (*)(CHIPIdentifyClusterIdentifyQueryResponseCallback *)>
        onSuccess(Platform::New<CHIPIdentifyClusterIdentifyQueryResponseCallback>(callback),
                  Platform::Delete<CHIPIdentifyClusterIdentifyQueryResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPIdentifyClusterIdentifyQueryResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, IdentifyCluster, triggerEffect)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject effectIdentifier, jobject effectVariant)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    chip::app::Clusters::Identify::Commands::TriggerEffect::Type request;

    request.effectIdentifier =
        static_cast<decltype(request.effectIdentifier)>(chip::JniReferences::GetInstance().IntegerToPrimitive(effectIdentifier));
    request.effectVariant =
        static_cast<decltype(request.effectVariant)>(chip::JniReferences::GetInstance().IntegerToPrimitive(effectVariant));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IdentifyCluster, writeIdentifyTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeIdentifyTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, IlluminanceMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    IlluminanceMeasurementCluster * cppCluster = new IlluminanceMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, IlluminanceMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, KeypadInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    KeypadInputCluster * cppCluster = new KeypadInputCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, KeypadInputCluster, sendKey)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject keyCode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    KeypadInputCluster * cppCluster;

    chip::app::Clusters::KeypadInput::Commands::SendKey::Type request;

    request.keyCode = static_cast<decltype(request.keyCode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(keyCode));

    std::unique_ptr<CHIPKeypadInputClusterSendKeyResponseCallback, void (*)(CHIPKeypadInputClusterSendKeyResponseCallback *)>
        onSuccess(Platform::New<CHIPKeypadInputClusterSendKeyResponseCallback>(callback),
                  Platform::Delete<CHIPKeypadInputClusterSendKeyResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<KeypadInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPKeypadInputClusterSendKeyResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, LevelControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster = new LevelControlCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LevelControlCluster, move)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate, jobject optionMask,
 jobject optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::Move::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));
    request.optionMask =
        static_cast<decltype(request.optionMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionMask));
    request.optionOverride =
        static_cast<decltype(request.optionOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, moveToLevel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject level, jobject transitionTime, jobject optionMask,
 jobject optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type request;

    request.level = static_cast<decltype(request.level)>(chip::JniReferences::GetInstance().IntegerToPrimitive(level));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionMask =
        static_cast<decltype(request.optionMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionMask));
    request.optionOverride =
        static_cast<decltype(request.optionOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, moveToLevelWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject level, jobject transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::MoveToLevelWithOnOff::Type request;

    request.level = static_cast<decltype(request.level)>(chip::JniReferences::GetInstance().IntegerToPrimitive(level));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, moveWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::MoveWithOnOff::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, step)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime,
 jobject optionMask, jobject optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::Step::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionMask =
        static_cast<decltype(request.optionMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionMask));
    request.optionOverride =
        static_cast<decltype(request.optionOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, stepWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::StepWithOnOff::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, stop)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject optionMask, jobject optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::Stop::Type request;

    request.optionMask =
        static_cast<decltype(request.optionMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionMask));
    request.optionOverride =
        static_cast<decltype(request.optionOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, stopWithOnOff)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::StopWithOnOff::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, subscribeCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentLevel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportCurrentLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentLevel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, LevelControlCluster, writeOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOptions(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOnOffTransitionTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOnLevel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOnTransitionTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOffTransitionTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeDefaultMoveRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeDefaultMoveRate(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeStartUpCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeStartUpCurrentLevel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, LowPowerCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    LowPowerCluster * cppCluster = new LowPowerCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LowPowerCluster, sleep)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LowPowerCluster * cppCluster;

    chip::app::Clusters::LowPower::Commands::Sleep::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LowPowerCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, MediaInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    MediaInputCluster * cppCluster = new MediaInputCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaInputCluster, hideInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaInputCluster, renameInput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject index, jstring name)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    chip::app::Clusters::MediaInput::Commands::RenameInput::Type request;

    request.index = static_cast<decltype(request.index)>(chip::JniReferences::GetInstance().IntegerToPrimitive(index));
    request.name  = chip::JniUtfString(env, static_cast<jstring>(name)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaInputCluster, selectInput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject index)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    chip::app::Clusters::MediaInput::Commands::SelectInput::Type request;

    request.index = static_cast<decltype(request.index)>(chip::JniReferences::GetInstance().IntegerToPrimitive(index));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaInputCluster, showInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, MediaPlaybackCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster = new MediaPlaybackCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaPlaybackCluster, mediaFastForward)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaFastForward::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaFastForwardResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaFastForwardResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaNext)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaNext::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaNextResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaNextResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaNextResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaNextResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaNextResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPause)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaPause::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPauseResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPauseResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaPauseResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaPauseResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaPauseResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPlay)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaPlay::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPlayResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPlayResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaPlayResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaPlayResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaPlayResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPrevious)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaPrevious::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPreviousResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPreviousResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaPreviousResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaPreviousResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaPreviousResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaRewind)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaRewind::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaRewindResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaRewindResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaRewindResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaRewindResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaRewindResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSeek)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject position)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaSeek::Type request;

    request.position = static_cast<decltype(request.position)>(chip::JniReferences::GetInstance().LongToPrimitive(position));

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSeekResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSeekResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaSeekResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaSeekResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaSeekResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipBackward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject deltaPositionMilliseconds)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackward::Type request;

    request.deltaPositionMilliseconds = static_cast<decltype(request.deltaPositionMilliseconds)>(
        chip::JniReferences::GetInstance().LongToPrimitive(deltaPositionMilliseconds));

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipForward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject deltaPositionMilliseconds)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaSkipForward::Type request;

    request.deltaPositionMilliseconds = static_cast<decltype(request.deltaPositionMilliseconds)>(
        chip::JniReferences::GetInstance().LongToPrimitive(deltaPositionMilliseconds));

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStartOver)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaStartOver::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaStartOverResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaStartOverResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaStartOverResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaStartOverResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaStartOverResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaStop::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaStopResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaStopResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaStopResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaStopResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaStopResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ModeSelectCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ModeSelectCluster * cppCluster = new ModeSelectCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ModeSelectCluster, changeToMode)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject newMode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster;

    chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type request;

    request.newMode = static_cast<decltype(request.newMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(newMode));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ModeSelectCluster, subscribeCurrentModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ModeSelectCluster, reportCurrentModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ModeSelectCluster, writeOnModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOnMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, NetworkCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster = new NetworkCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, NetworkCommissioningCluster, addThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jobject breadcrumb,
 jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::AddThreadNetwork::Type request;

    request.operationalDataset = chip::JniByteArray(env, static_cast<jbyteArray>(operationalDataset)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, addWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jobject breadcrumb,
 jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::AddWiFiNetwork::Type request;

    request.ssid        = chip::JniByteArray(env, static_cast<jbyteArray>(ssid)).byteSpan();
    request.credentials = chip::JniByteArray(env, static_cast<jbyteArray>(credentials)).byteSpan();
    request.breadcrumb  = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs   = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, disableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jobject breadcrumb, jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::DisableNetwork::Type request;

    request.networkID  = chip::JniByteArray(env, static_cast<jbyteArray>(networkID)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterDisableNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterDisableNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, enableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jobject breadcrumb, jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::EnableNetwork::Type request;

    request.networkID  = chip::JniByteArray(env, static_cast<jbyteArray>(networkID)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterEnableNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterEnableNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, removeNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jobject breadcrumb, jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::RemoveNetwork::Type request;

    request.networkID  = chip::JniByteArray(env, static_cast<jbyteArray>(networkID)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, scanNetworks)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jobject breadcrumb, jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::ScanNetworks::Type request;

    request.ssid       = chip::JniByteArray(env, static_cast<jbyteArray>(ssid)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterScanNetworksResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterScanNetworksResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterScanNetworksResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterScanNetworksResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterScanNetworksResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, updateThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jobject breadcrumb,
 jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::UpdateThreadNetwork::Type request;

    request.operationalDataset = chip::JniByteArray(env, static_cast<jbyteArray>(operationalDataset)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallbackType>::FromCancelable(
            onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, updateWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jobject breadcrumb,
 jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::UpdateWiFiNetwork::Type request;

    request.ssid        = chip::JniByteArray(env, static_cast<jbyteArray>(ssid)).byteSpan();
    request.credentials = chip::JniByteArray(env, static_cast<jbyteArray>(credentials)).byteSpan();
    request.breadcrumb  = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs   = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, OtaSoftwareUpdateProviderCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateProviderCluster * cppCluster = new OtaSoftwareUpdateProviderCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, applyUpdateRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray updateToken, jobject newVersion)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::ApplyUpdateRequest::Type request;

    request.updateToken = chip::JniByteArray(env, static_cast<jbyteArray>(updateToken)).byteSpan();
    request.newVersion  = static_cast<decltype(request.newVersion)>(chip::JniReferences::GetInstance().LongToPrimitive(newVersion));

    std::unique_ptr<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback,
                    void (*)(CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback *)>
        onSuccess(Platform::New<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>(callback),
                  Platform::Delete<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, notifyUpdateApplied)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray updateToken, jobject softwareVersion)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::NotifyUpdateApplied::Type request;

    request.updateToken = chip::JniByteArray(env, static_cast<jbyteArray>(updateToken)).byteSpan();
    request.softwareVersion =
        static_cast<decltype(request.softwareVersion)>(chip::JniReferences::GetInstance().LongToPrimitive(softwareVersion));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, queryImage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject vendorId, jobject productId, jobject softwareVersion,
 jobject protocolsSupported, jobject hardwareVersion, jobject location, jobject requestorCanConsent, jobject metadataForProvider)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::QueryImage::Type request;

    request.vendorId  = static_cast<decltype(request.vendorId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(vendorId));
    request.productId = static_cast<decltype(request.productId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(productId));
    request.softwareVersion =
        static_cast<decltype(request.softwareVersion)>(chip::JniReferences::GetInstance().LongToPrimitive(softwareVersion));
    request.protocolsSupported =
        chip::app::DataModel::List<const chip::app::Clusters::OtaSoftwareUpdateProvider::OTADownloadProtocol>();
    chip::JniReferences::GetInstance().GetOptionalValue(hardwareVersion, hardwareVersion);
    request.hardwareVersion = chip::Optional<uint16_t>(
        static_cast<decltype(request.hardwareVersion)>(chip::JniReferences::GetInstance().IntegerToPrimitive(hardwareVersion)));
    chip::JniReferences::GetInstance().GetOptionalValue(location, location);
    request.location = chip::Optional<chip::CharSpan>(chip::JniUtfString(env, static_cast<jstring>(location)).charSpan());
    chip::JniReferences::GetInstance().GetOptionalValue(requestorCanConsent, requestorCanConsent);
    request.requestorCanConsent = chip::Optional<bool>(static_cast<decltype(request.requestorCanConsent)>(
        chip::JniReferences::GetInstance().BooleanToPrimitive(requestorCanConsent)));
    chip::JniReferences::GetInstance().GetOptionalValue(metadataForProvider, metadataForProvider);
    request.metadataForProvider =
        chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(metadataForProvider)).byteSpan());

    std::unique_ptr<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback,
                    void (*)(CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback *)>
        onSuccess(Platform::New<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback>(callback),
                  Platform::Delete<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, OtaSoftwareUpdateRequestorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateRequestorCluster * cppCluster = new OtaSoftwareUpdateRequestorCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, announceOtaProvider)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject providerLocation, jobject vendorId,
 jobject announcementReason, jobject metadataForNode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster;

    chip::app::Clusters::OtaSoftwareUpdateRequestor::Commands::AnnounceOtaProvider::Type request;

    request.providerLocation =
        static_cast<decltype(request.providerLocation)>(chip::JniReferences::GetInstance().LongToPrimitive(providerLocation));
    request.vendorId = static_cast<decltype(request.vendorId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(vendorId));
    request.announcementReason = static_cast<decltype(request.announcementReason)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(announcementReason));
    chip::JniReferences::GetInstance().GetOptionalValue(metadataForNode, metadataForNode);
    request.metadataForNode =
        chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(metadataForNode)).byteSpan());

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, writeDefaultOtaProviderAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniByteArray jniArr(env, value);
    err = cppCluster->WriteAttributeDefaultOtaProvider(onSuccess->Cancel(), onFailure->Cancel(),
                                                       chip::ByteSpan((const uint8_t *) jniArr.data(), jniArr.size()));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, OccupancySensingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OccupancySensingCluster * cppCluster = new OccupancySensingCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OccupancySensingCluster, subscribeOccupancyAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOccupancy(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OccupancySensingCluster, reportOccupancyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOccupancy(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, OnOffCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OnOffCluster * cppCluster = new OnOffCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffCluster, off)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::Off::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, offWithEffect)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject effectId, jobject effectVariant)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::OffWithEffect::Type request;

    request.effectId = static_cast<decltype(request.effectId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(effectId));
    request.effectVariant =
        static_cast<decltype(request.effectVariant)>(chip::JniReferences::GetInstance().IntegerToPrimitive(effectVariant));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, on)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::On::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, onWithRecallGlobalScene)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::OnWithRecallGlobalScene::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, onWithTimedOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject onOffControl, jobject onTime, jobject offWaitTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::OnWithTimedOff::Type request;

    request.onOffControl =
        static_cast<decltype(request.onOffControl)>(chip::JniReferences::GetInstance().IntegerToPrimitive(onOffControl));
    request.onTime = static_cast<decltype(request.onTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(onTime));
    request.offWaitTime =
        static_cast<decltype(request.offWaitTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(offWaitTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, toggle)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::Toggle::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, subscribeOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOnOff(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, reportOnOffAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOnOff(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, OnOffCluster, writeOnTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOnTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, writeOffWaitTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOffWaitTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, writeStartUpOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeStartUpOnOff(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, OnOffSwitchConfigurationCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OnOffSwitchConfigurationCluster * cppCluster = new OnOffSwitchConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, writeSwitchActionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeSwitchActions(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, OperationalCredentialsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster = new OperationalCredentialsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OperationalCredentialsCluster, addNOC)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray NOCValue, jobject ICACValue, jbyteArray IPKValue,
 jobject caseAdminNode, jobject adminVendorId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::AddNOC::Type request;

    request.NOCValue = chip::JniByteArray(env, static_cast<jbyteArray>(NOCValue)).byteSpan();
    chip::JniReferences::GetInstance().GetOptionalValue(ICACValue, ICACValue);
    request.ICACValue = chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(ICACValue)).byteSpan());
    request.IPKValue  = chip::JniByteArray(env, static_cast<jbyteArray>(IPKValue)).byteSpan();
    request.caseAdminNode =
        static_cast<decltype(request.caseAdminNode)>(chip::JniReferences::GetInstance().LongToPrimitive(caseAdminNode));
    request.adminVendorId =
        static_cast<decltype(request.adminVendorId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(adminVendorId));

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, addTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray rootCertificate)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::AddTrustedRootCertificate::Type request;

    request.rootCertificate = chip::JniByteArray(env, static_cast<jbyteArray>(rootCertificate)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, attestationRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray attestationNonce)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::AttestationRequest::Type request;

    request.attestationNonce = chip::JniByteArray(env, static_cast<jbyteArray>(attestationNonce)).byteSpan();

    std::unique_ptr<CHIPOperationalCredentialsClusterAttestationResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterAttestationResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterAttestationResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterAttestationResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPOperationalCredentialsClusterAttestationResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, certificateChainRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject certificateType)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::CertificateChainRequest::Type request;

    request.certificateType =
        static_cast<decltype(request.certificateType)>(chip::JniReferences::GetInstance().IntegerToPrimitive(certificateType));

    std::unique_ptr<CHIPOperationalCredentialsClusterCertificateChainResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterCertificateChainResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterCertificateChainResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterCertificateChainResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterCertificateChainResponseCallbackType>::FromCancelable(
            onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, opCSRRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray CSRNonce)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::OpCSRRequest::Type request;

    request.CSRNonce = chip::JniByteArray(env, static_cast<jbyteArray>(CSRNonce)).byteSpan();

    std::unique_ptr<CHIPOperationalCredentialsClusterOpCSRResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterOpCSRResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterOpCSRResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterOpCSRResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterOpCSRResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, removeFabric)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject fabricIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::RemoveFabric::Type request;

    request.fabricIndex =
        static_cast<decltype(request.fabricIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(fabricIndex));

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, removeTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray trustedRootIdentifier)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::RemoveTrustedRootCertificate::Type request;

    request.trustedRootIdentifier = chip::JniByteArray(env, static_cast<jbyteArray>(trustedRootIdentifier)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, updateFabricLabel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring label)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::UpdateFabricLabel::Type request;

    request.label = chip::JniUtfString(env, static_cast<jstring>(label)).charSpan();

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, updateNOC)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray NOCValue, jobject ICACValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::UpdateNOC::Type request;

    request.NOCValue = chip::JniByteArray(env, static_cast<jbyteArray>(NOCValue)).byteSpan();
    chip::JniReferences::GetInstance().GetOptionalValue(ICACValue, ICACValue);
    request.ICACValue = chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(ICACValue)).byteSpan());

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, PowerSourceCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PowerSourceCluster * cppCluster = new PowerSourceCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, PressureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PressureMeasurementCluster * cppCluster = new PressureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PressureMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PressureMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, PumpConfigurationAndControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PumpConfigurationAndControlCluster * cppCluster = new PumpConfigurationAndControlCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribePumpStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePumpStatus(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportPumpStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePumpStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeCapacityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCapacity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportCapacityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCapacity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOperationMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeControlMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, RelativeHumidityMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    RelativeHumidityMeasurementCluster * cppCluster = new RelativeHumidityMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTolerance(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTolerance(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ScenesCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster = new ScenesCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ScenesCluster, addScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jobject sceneId, jobject transitionTime,
 jstring sceneName, jobject clusterId, jobject length, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::AddScene::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.sceneId = static_cast<decltype(request.sceneId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(sceneId));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.sceneName = chip::JniUtfString(env, static_cast<jstring>(sceneName)).charSpan();
    request.extensionFieldSets =
        chip::app::DataModel::List<const chip::app::Clusters::Scenes::Structs::SceneExtensionFieldSet::Type>();

    std::unique_ptr<CHIPScenesClusterAddSceneResponseCallback, void (*)(CHIPScenesClusterAddSceneResponseCallback *)> onSuccess(
        Platform::New<CHIPScenesClusterAddSceneResponseCallback>(callback),
        Platform::Delete<CHIPScenesClusterAddSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPScenesClusterAddSceneResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, getSceneMembership)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::GetSceneMembership::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));

    std::unique_ptr<CHIPScenesClusterGetSceneMembershipResponseCallback,
                    void (*)(CHIPScenesClusterGetSceneMembershipResponseCallback *)>
        onSuccess(Platform::New<CHIPScenesClusterGetSceneMembershipResponseCallback>(callback),
                  Platform::Delete<CHIPScenesClusterGetSceneMembershipResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPScenesClusterGetSceneMembershipResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, recallScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jobject sceneId, jobject transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::RecallScene::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.sceneId = static_cast<decltype(request.sceneId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(sceneId));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, removeAllScenes)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::RemoveAllScenes::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));

    std::unique_ptr<CHIPScenesClusterRemoveAllScenesResponseCallback, void (*)(CHIPScenesClusterRemoveAllScenesResponseCallback *)>
        onSuccess(Platform::New<CHIPScenesClusterRemoveAllScenesResponseCallback>(callback),
                  Platform::Delete<CHIPScenesClusterRemoveAllScenesResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPScenesClusterRemoveAllScenesResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, removeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jobject sceneId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::RemoveScene::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.sceneId = static_cast<decltype(request.sceneId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(sceneId));

    std::unique_ptr<CHIPScenesClusterRemoveSceneResponseCallback, void (*)(CHIPScenesClusterRemoveSceneResponseCallback *)>
        onSuccess(Platform::New<CHIPScenesClusterRemoveSceneResponseCallback>(callback),
                  Platform::Delete<CHIPScenesClusterRemoveSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPScenesClusterRemoveSceneResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, storeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jobject sceneId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::StoreScene::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.sceneId = static_cast<decltype(request.sceneId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(sceneId));

    std::unique_ptr<CHIPScenesClusterStoreSceneResponseCallback, void (*)(CHIPScenesClusterStoreSceneResponseCallback *)> onSuccess(
        Platform::New<CHIPScenesClusterStoreSceneResponseCallback>(callback),
        Platform::Delete<CHIPScenesClusterStoreSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPScenesClusterStoreSceneResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, viewScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jobject sceneId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::ViewScene::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.sceneId = static_cast<decltype(request.sceneId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(sceneId));

    std::unique_ptr<CHIPScenesClusterViewSceneResponseCallback, void (*)(CHIPScenesClusterViewSceneResponseCallback *)> onSuccess(
        Platform::New<CHIPScenesClusterViewSceneResponseCallback>(callback),
        Platform::Delete<CHIPScenesClusterViewSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPScenesClusterViewSceneResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, SoftwareDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    SoftwareDiagnosticsCluster * cppCluster = new SoftwareDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, resetWatermarks)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster;

    chip::app::Clusters::SoftwareDiagnostics::Commands::ResetWatermarks::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, SwitchCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    SwitchCluster * cppCluster = new SwitchCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SwitchCluster, subscribeCurrentPositionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPosition(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SwitchCluster, reportCurrentPositionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPosition(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, TvChannelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TvChannelCluster * cppCluster = new TvChannelCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TvChannelCluster, changeChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring match)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    chip::app::Clusters::TvChannel::Commands::ChangeChannel::Type request;

    request.match = chip::JniUtfString(env, static_cast<jstring>(match)).charSpan();

    std::unique_ptr<CHIPTvChannelClusterChangeChannelResponseCallback,
                    void (*)(CHIPTvChannelClusterChangeChannelResponseCallback *)>
        onSuccess(Platform::New<CHIPTvChannelClusterChangeChannelResponseCallback>(callback),
                  Platform::Delete<CHIPTvChannelClusterChangeChannelResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTvChannelClusterChangeChannelResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TvChannelCluster, changeChannelByNumber)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject majorNumber, jobject minorNumber)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    chip::app::Clusters::TvChannel::Commands::ChangeChannelByNumber::Type request;

    request.majorNumber =
        static_cast<decltype(request.majorNumber)>(chip::JniReferences::GetInstance().IntegerToPrimitive(majorNumber));
    request.minorNumber =
        static_cast<decltype(request.minorNumber)>(chip::JniReferences::GetInstance().IntegerToPrimitive(minorNumber));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TvChannelCluster, skipChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject count)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    chip::app::Clusters::TvChannel::Commands::SkipChannel::Type request;

    request.count = static_cast<decltype(request.count)>(chip::JniReferences::GetInstance().IntegerToPrimitive(count));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, TargetNavigatorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TargetNavigatorCluster * cppCluster = new TargetNavigatorCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TargetNavigatorCluster, navigateTarget)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject target, jstring data)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TargetNavigatorCluster * cppCluster;

    chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type request;

    request.target = static_cast<decltype(request.target)>(chip::JniReferences::GetInstance().IntegerToPrimitive(target));
    request.data   = chip::JniUtfString(env, static_cast<jstring>(data)).charSpan();

    std::unique_ptr<CHIPTargetNavigatorClusterNavigateTargetResponseCallback,
                    void (*)(CHIPTargetNavigatorClusterNavigateTargetResponseCallback *)>
        onSuccess(Platform::New<CHIPTargetNavigatorClusterNavigateTargetResponseCallback>(callback),
                  Platform::Delete<CHIPTargetNavigatorClusterNavigateTargetResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TargetNavigatorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTargetNavigatorClusterNavigateTargetResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, TemperatureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TemperatureMeasurementCluster * cppCluster = new TemperatureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TemperatureMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, subscribeToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTolerance(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTolerance(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, TestClusterCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster = new TestClusterCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TestClusterCluster, test)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::Test::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testAddArguments)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1, jobject arg2)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type request;

    request.arg1 = static_cast<decltype(request.arg1)>(chip::JniReferences::GetInstance().IntegerToPrimitive(arg1));
    request.arg2 = static_cast<decltype(request.arg2)>(chip::JniReferences::GetInstance().IntegerToPrimitive(arg2));

    std::unique_ptr<CHIPTestClusterClusterTestAddArgumentsResponseCallback,
                    void (*)(CHIPTestClusterClusterTestAddArgumentsResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestAddArgumentsResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestAddArgumentsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterTestAddArgumentsResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testEnumsRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1, jobject arg2)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type request;

    request.arg1 = static_cast<decltype(request.arg1)>(chip::JniReferences::GetInstance().IntegerToPrimitive(arg1));
    request.arg2 = static_cast<decltype(request.arg2)>(chip::JniReferences::GetInstance().IntegerToPrimitive(arg2));

    std::unique_ptr<CHIPTestClusterClusterTestEnumsResponseCallback, void (*)(CHIPTestClusterClusterTestEnumsResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestEnumsResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestEnumsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterTestEnumsResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testListInt8UArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type request;

    request.arg1 = chip::app::DataModel::List<const uint8_t>();

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testListInt8UReverseRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type request;

    request.arg1 = chip::app::DataModel::List<const uint8_t>();

    std::unique_ptr<CHIPTestClusterClusterTestListInt8UReverseResponseCallback,
                    void (*)(CHIPTestClusterClusterTestListInt8UReverseResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestListInt8UReverseResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestListInt8UReverseResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPTestClusterClusterTestListInt8UReverseResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testListStructArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject a, jobject b, jobject c, jbyteArray d, jstring e,
 jobject f)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type request;

    request.arg1 = chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>();

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testNotHandled)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testNullableOptionalRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type request;

    chip::JniReferences::GetInstance().GetOptionalValue(arg1, arg1);
    uint8_t arg1Value;
    if (arg1 != nullptr)
    {
        arg1Value = chip::JniReferences::GetInstance().IntegerToPrimitive(arg1);
    }
    request.arg1 = chip::Optional<chip::app::DataModel::Nullable<uint8_t>>(
        arg1 == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(arg1Value));

    std::unique_ptr<CHIPTestClusterClusterTestNullableOptionalResponseCallback,
                    void (*)(CHIPTestClusterClusterTestNullableOptionalResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestNullableOptionalResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestNullableOptionalResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPTestClusterClusterTestNullableOptionalResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testSpecific)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestSpecific::Type request;

    std::unique_ptr<CHIPTestClusterClusterTestSpecificResponseCallback,
                    void (*)(CHIPTestClusterClusterTestSpecificResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestSpecificResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestSpecificResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterTestSpecificResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testStructArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject a, jobject b, jobject c, jbyteArray d, jstring e,
 jobject f)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type request;

    request.arg1 = chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type();

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testUnknownCommand)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestUnknownCommand::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBoolean(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBitmap8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBitmap16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBitmap32(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBitmap64(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt8u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt16u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt32u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt64u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt8s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt16s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt32s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt64s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeEnum8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeEnum16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniByteArray jniArr(env, value);
    err = cppCluster->WriteAttributeOctetString(onSuccess->Cancel(), onFailure->Cancel(),
                                                chip::ByteSpan((const uint8_t *) jniArr.data(), jniArr.size()));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeLongOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniByteArray jniArr(env, value);
    err = cppCluster->WriteAttributeLongOctetString(onSuccess->Cancel(), onFailure->Cancel(),
                                                    chip::ByteSpan((const uint8_t *) jniArr.data(), jniArr.size()));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeCharString(onSuccess->Cancel(), onFailure->Cancel(),
                                               chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeLongCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeLongCharString(onSuccess->Cancel(), onFailure->Cancel(),
                                                   chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEpochUsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeEpochUs(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEpochSAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeEpochS(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeVendorId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<chip::VendorId>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeUnsupportedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeUnsupported(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableBoolean(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableBitmap8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableBitmap16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableBitmap32(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableBitmap64(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableInt8u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableInt16u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableInt32u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableInt64u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableInt8s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableInt16s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableInt32s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableInt64s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableEnum8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeNullableEnum16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniByteArray jniArr(env, value);
    err = cppCluster->WriteAttributeNullableOctetString(onSuccess->Cancel(), onFailure->Cancel(),
                                                        chip::ByteSpan((const uint8_t *) jniArr.data(), jniArr.size()));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeNullableCharString(onSuccess->Cancel(), onFailure->Cancel(),
                                                       chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ThermostatCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatCluster * cppCluster = new ThermostatCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatCluster, clearWeeklySchedule)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    chip::app::Clusters::Thermostat::Commands::ClearWeeklySchedule::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, getRelayStatusLog)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    chip::app::Clusters::Thermostat::Commands::GetRelayStatusLog::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, getWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject daysToReturn, jobject modeToReturn)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    chip::app::Clusters::Thermostat::Commands::GetWeeklySchedule::Type request;

    request.daysToReturn =
        static_cast<decltype(request.daysToReturn)>(chip::JniReferences::GetInstance().IntegerToPrimitive(daysToReturn));
    request.modeToReturn =
        static_cast<decltype(request.modeToReturn)>(chip::JniReferences::GetInstance().IntegerToPrimitive(modeToReturn));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, setWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject numberOfTransitionsForSequence,
 jobject dayOfWeekForSequence, jobject modeForSequence, jobject payload)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    chip::app::Clusters::Thermostat::Commands::SetWeeklySchedule::Type request;

    request.numberOfTransitionsForSequence = static_cast<decltype(request.numberOfTransitionsForSequence)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(numberOfTransitionsForSequence));
    request.dayOfWeekForSequence = static_cast<decltype(request.dayOfWeekForSequence)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(dayOfWeekForSequence));
    request.modeForSequence =
        static_cast<decltype(request.modeForSequence)>(chip::JniReferences::GetInstance().IntegerToPrimitive(modeForSequence));
    request.payload = chip::app::DataModel::List<const uint8_t>();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, setpointRaiseLower)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject mode, jobject amount)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    chip::app::Clusters::Thermostat::Commands::SetpointRaiseLower::Type request;

    request.mode   = static_cast<decltype(request.mode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(mode));
    request.amount = static_cast<decltype(request.amount)>(chip::JniReferences::GetInstance().IntegerToPrimitive(amount));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, subscribeLocalTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLocalTemperature(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportLocalTemperatureAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLocalTemperature(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedCoolingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOccupiedCoolingSetpoint(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedHeatingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOccupiedHeatingSetpoint(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMinHeatSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMaxHeatSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMinCoolSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMaxCoolSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinSetpointDeadBandAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMinSetpointDeadBand(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeControlSequenceOfOperationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err =
        cppCluster->WriteAttributeControlSequenceOfOperation(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeSystemModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeSystemMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ThermostatUserInterfaceConfigurationCluster, initWithDevice)
(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatUserInterfaceConfigurationCluster * cppCluster = new ThermostatUserInterfaceConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeTemperatureDisplayModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeTemperatureDisplayMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeKeypadLockoutAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeKeypadLockout(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeScheduleProgrammingVisibilityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeScheduleProgrammingVisibility(onSuccess->Cancel(), onFailure->Cancel(),
                                                                  static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ThreadNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThreadNetworkDiagnosticsCluster * cppCluster = new ThreadNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster;

    chip::app::Clusters::ThreadNetworkDiagnostics::Commands::ResetCounts::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, WakeOnLanCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WakeOnLanCluster * cppCluster = new WakeOnLanCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, WiFiNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WiFiNetworkDiagnosticsCluster * cppCluster = new WiFiNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster;

    chip::app::Clusters::WiFiNetworkDiagnostics::Commands::ResetCounts::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, WindowCoveringCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster = new WindowCoveringCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WindowCoveringCluster, downOrClose)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToLiftPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject liftPercentageValue, jobject liftPercent100thsValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type request;

    request.liftPercentageValue = static_cast<decltype(request.liftPercentageValue)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(liftPercentageValue));
    request.liftPercent100thsValue = static_cast<decltype(request.liftPercent100thsValue)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(liftPercent100thsValue));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToLiftValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject liftValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::GoToLiftValue::Type request;

    request.liftValue = static_cast<decltype(request.liftValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(liftValue));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToTiltPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject tiltPercentageValue, jobject tiltPercent100thsValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type request;

    request.tiltPercentageValue = static_cast<decltype(request.tiltPercentageValue)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(tiltPercentageValue));
    request.tiltPercent100thsValue = static_cast<decltype(request.tiltPercent100thsValue)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(tiltPercent100thsValue));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToTiltValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject tiltValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::GoToTiltValue::Type request;

    request.tiltValue = static_cast<decltype(request.tiltValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(tiltValue));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, stopMotion)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::StopMotion::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, upOrOpen)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionLiftPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionLiftPercentage(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionLiftPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionLiftPercentage(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionTiltPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionTiltPercentage(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionTiltPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionTiltPercentage(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeOperationalStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOperationalStatus(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportOperationalStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOperationalStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeTargetPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTargetPositionLiftPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportTargetPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTargetPositionLiftPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeTargetPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTargetPositionTiltPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportTargetPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTargetPositionTiltPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionLiftPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionLiftPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionTiltPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionTiltPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, writeModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeSafetyStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSafetyStatus(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportSafetyStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSafetyStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
