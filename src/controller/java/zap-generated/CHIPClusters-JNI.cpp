/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#include "CHIPCallbackTypes.h"
#include "CHIPInvokeCallbacks.h"
#include "CHIPReadCallbacks.h"

#include <app-common/zap-generated/cluster-objects.h>
#include <zap-generated/CHIPClientCallbacks.h>
#include <zap-generated/CHIPClusters.h>

#include <controller/java/AndroidClusterExceptions.h>
#include <controller/java/CHIPDefaultCallbacks.h>
#include <jni.h>
#include <lib/support/CodeUtils.h>
#include <lib/support/JniReferences.h>
#include <lib/support/JniTypeWrappers.h>
#include <lib/support/Span.h>
#include <platform/PlatformManager.h>

#define JNI_METHOD(RETURN, CLASS_NAME, METHOD_NAME)                                                                                \
    extern "C" JNIEXPORT RETURN JNICALL Java_chip_devicecontroller_ChipClusters_00024##CLASS_NAME##_##METHOD_NAME

using namespace chip;
using namespace chip::Controller;

JNI_METHOD(void, BaseChipCluster, deleteCluster)(JNIEnv * env, jobject self, jlong clusterPtr)
{
    chip::DeviceLayer::StackLock lock;
    ClusterBase * cluster = reinterpret_cast<ClusterBase *>(clusterPtr);
    if (cluster != nullptr)
    {
        delete cluster;
    }
}

JNI_METHOD(jlong, AccessControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AccessControlCluster * cppCluster = new AccessControlCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, AccountLoginCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AccountLoginCluster * cppCluster = new AccountLoginCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AccountLoginCluster, getSetupPIN)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster;

    chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type request;

    request.tempAccountIdentifier = chip::JniUtfString(env, static_cast<jstring>(tempAccountIdentifier)).charSpan();

    std::unique_ptr<CHIPAccountLoginClusterGetSetupPINResponseCallback,
                    void (*)(CHIPAccountLoginClusterGetSetupPINResponseCallback *)>
        onSuccess(Platform::New<CHIPAccountLoginClusterGetSetupPINResponseCallback>(callback),
                  Platform::Delete<CHIPAccountLoginClusterGetSetupPINResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPAccountLoginClusterGetSetupPINResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AccountLoginCluster, login)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier, jstring setupPIN)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster;

    chip::app::Clusters::AccountLogin::Commands::Login::Type request;

    request.tempAccountIdentifier = chip::JniUtfString(env, static_cast<jstring>(tempAccountIdentifier)).charSpan();
    request.setupPIN              = chip::JniUtfString(env, static_cast<jstring>(setupPIN)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AccountLoginCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, AccountLoginCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, AdministratorCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AdministratorCommissioningCluster * cppCluster = new AdministratorCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AdministratorCommissioningCluster, openBasicCommissioningWindow)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject commissioningTimeout)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type request;

    request.commissioningTimeout = static_cast<decltype(request.commissioningTimeout)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(commissioningTimeout));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AdministratorCommissioningCluster, openCommissioningWindow)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject commissioningTimeout, jbyteArray PAKEVerifier,
 jobject discriminator, jobject iterations, jbyteArray salt, jobject passcodeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type request;

    request.commissioningTimeout = static_cast<decltype(request.commissioningTimeout)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(commissioningTimeout));
    request.PAKEVerifier = chip::JniByteArray(env, static_cast<jbyteArray>(PAKEVerifier)).byteSpan();
    request.discriminator =
        static_cast<decltype(request.discriminator)>(chip::JniReferences::GetInstance().IntegerToPrimitive(discriminator));
    request.iterations = static_cast<decltype(request.iterations)>(chip::JniReferences::GetInstance().LongToPrimitive(iterations));
    request.salt       = chip::JniByteArray(env, static_cast<jbyteArray>(salt)).byteSpan();
    request.passcodeID =
        static_cast<decltype(request.passcodeID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(passcodeID));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AdministratorCommissioningCluster, revokeCommissioning)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    chip::app::Clusters::AdministratorCommissioning::Commands::RevokeCommissioning::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AdministratorCommissioningCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, AdministratorCommissioningCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ApplicationBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ApplicationBasicCluster * cppCluster = new ApplicationBasicCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationBasicCluster, changeStatus)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject status)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster;

    chip::app::Clusters::ApplicationBasic::Commands::ChangeStatus::Type request;

    request.status = static_cast<decltype(request.status)>(chip::JniReferences::GetInstance().IntegerToPrimitive(status));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ApplicationBasicCluster, subscribeVendorNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeVendorName(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationBasicCluster, reportVendorNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeVendorName(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ApplicationBasicCluster, subscribeVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeVendorId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationBasicCluster, reportVendorIdAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeVendorId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ApplicationBasicCluster, subscribeApplicationNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeApplicationName(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationBasicCluster, reportApplicationNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeApplicationName(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ApplicationBasicCluster, subscribeProductIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeProductId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationBasicCluster, reportProductIdAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeProductId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ApplicationBasicCluster, subscribeApplicationIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeApplicationId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationBasicCluster, reportApplicationIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeApplicationId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ApplicationBasicCluster, subscribeCatalogVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCatalogVendorId(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationBasicCluster, reportCatalogVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCatalogVendorId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ApplicationBasicCluster, subscribeApplicationStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeApplicationStatus(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationBasicCluster, reportApplicationStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeApplicationStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ApplicationBasicCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationBasicCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ApplicationLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ApplicationLauncherCluster * cppCluster = new ApplicationLauncherCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationLauncherCluster, launchApp)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring data, jobject catalogVendorId, jstring applicationId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster;

    chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type request;

    request.data = chip::JniUtfString(env, static_cast<jstring>(data)).charSpan();
    request.catalogVendorId =
        static_cast<decltype(request.catalogVendorId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(catalogVendorId));
    request.applicationId = chip::JniUtfString(env, static_cast<jstring>(applicationId)).charSpan();

    std::unique_ptr<CHIPApplicationLauncherClusterLaunchAppResponseCallback,
                    void (*)(CHIPApplicationLauncherClusterLaunchAppResponseCallback *)>
        onSuccess(Platform::New<CHIPApplicationLauncherClusterLaunchAppResponseCallback>(callback),
                  Platform::Delete<CHIPApplicationLauncherClusterLaunchAppResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPApplicationLauncherClusterLaunchAppResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ApplicationLauncherCluster, subscribeCatalogVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCatalogVendorId(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationLauncherCluster, reportCatalogVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCatalogVendorId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ApplicationLauncherCluster, subscribeApplicationIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeApplicationId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationLauncherCluster, reportApplicationIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeApplicationId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ApplicationLauncherCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ApplicationLauncherCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, AudioOutputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AudioOutputCluster * cppCluster = new AudioOutputCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AudioOutputCluster, renameOutput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject index, jstring name)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster;

    chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type request;

    request.index = static_cast<decltype(request.index)>(chip::JniReferences::GetInstance().IntegerToPrimitive(index));
    request.name  = chip::JniUtfString(env, static_cast<jstring>(name)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AudioOutputCluster, selectOutput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject index)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster;

    chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type request;

    request.index = static_cast<decltype(request.index)>(chip::JniReferences::GetInstance().IntegerToPrimitive(index));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, AudioOutputCluster, subscribeCurrentAudioOutputAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentAudioOutput(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, AudioOutputCluster, reportCurrentAudioOutputAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentAudioOutput(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, AudioOutputCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, AudioOutputCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BarrierControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BarrierControlCluster * cppCluster = new BarrierControlCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BarrierControlCluster, barrierControlGoToPercent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject percentOpen)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster;

    chip::app::Clusters::BarrierControl::Commands::BarrierControlGoToPercent::Type request;

    request.percentOpen =
        static_cast<decltype(request.percentOpen)>(chip::JniReferences::GetInstance().IntegerToPrimitive(percentOpen));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BarrierControlCluster, barrierControlStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster;

    chip::app::Clusters::BarrierControl::Commands::BarrierControlStop::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BarrierControlCluster, subscribeBarrierMovingStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBarrierMovingState(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BarrierControlCluster, reportBarrierMovingStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBarrierMovingState(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BarrierControlCluster, subscribeBarrierSafetyStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBarrierSafetyStatus(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BarrierControlCluster, reportBarrierSafetyStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBarrierSafetyStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BarrierControlCluster, subscribeBarrierCapabilitiesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBarrierCapabilities(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BarrierControlCluster, reportBarrierCapabilitiesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBarrierCapabilities(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BarrierControlCluster, subscribeBarrierPositionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBarrierPosition(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BarrierControlCluster, reportBarrierPositionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBarrierPosition(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BarrierControlCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BarrierControlCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BasicCluster * cppCluster = new BasicCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BasicCluster, mfgSpecificPing)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BasicCluster * cppCluster;

    chip::app::Clusters::Basic::Commands::MfgSpecificPing::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BasicCluster, subscribeInteractionModelVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInteractionModelVersion(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportInteractionModelVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInteractionModelVersion(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeVendorNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeVendorName(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportVendorNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeVendorName(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeVendorIDAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeVendorID(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportVendorIDAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeVendorID(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeProductNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeProductName(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportProductNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeProductName(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeProductIDAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeProductID(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportProductIDAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeProductID(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, BasicCluster, writeNodeLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Basic::Attributes::NodeLabel::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BasicCluster, subscribeNodeLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNodeLabel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportNodeLabelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNodeLabel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, BasicCluster, writeLocationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Basic::Attributes::Location::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BasicCluster, subscribeLocationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLocation(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportLocationAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLocation(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeHardwareVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeHardwareVersion(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportHardwareVersionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeHardwareVersion(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeHardwareVersionStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeHardwareVersionString(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportHardwareVersionStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeHardwareVersionString(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeSoftwareVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSoftwareVersion(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportSoftwareVersionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSoftwareVersion(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeSoftwareVersionStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSoftwareVersionString(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportSoftwareVersionStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSoftwareVersionString(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeManufacturingDateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeManufacturingDate(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportManufacturingDateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeManufacturingDate(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribePartNumberAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePartNumber(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportPartNumberAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePartNumber(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeProductURLAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeProductURL(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportProductURLAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeProductURL(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeProductLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeProductLabel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportProductLabelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeProductLabel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeSerialNumberAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSerialNumber(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportSerialNumberAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSerialNumber(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, BasicCluster, writeLocalConfigDisabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Basic::Attributes::LocalConfigDisabled::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BasicCluster, subscribeLocalConfigDisabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLocalConfigDisabled(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportLocalConfigDisabledAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLocalConfigDisabled(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeReachableAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeReachable(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportReachableAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeReachable(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BasicCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BinaryInputBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BinaryInputBasicCluster * cppCluster = new BinaryInputBasicCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BinaryInputBasicCluster, writeOutOfServiceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BinaryInputBasicCluster, subscribeOutOfServiceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOutOfService(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, reportOutOfServiceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOutOfService(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, writePresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BinaryInputBasicCluster, subscribePresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePresentValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, reportPresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePresentValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BinaryInputBasicCluster, subscribeStatusFlagsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStatusFlags(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, reportStatusFlagsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStatusFlags(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BinaryInputBasicCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BindingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BindingCluster * cppCluster = new BindingCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BindingCluster, bind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject nodeId, jobject groupId, jobject endpointId,
 jobject clusterId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BindingCluster * cppCluster;

    chip::app::Clusters::Binding::Commands::Bind::Type request;

    request.nodeId  = static_cast<decltype(request.nodeId)>(chip::JniReferences::GetInstance().LongToPrimitive(nodeId));
    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.endpointId =
        static_cast<decltype(request.endpointId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(endpointId));
    request.clusterId = static_cast<decltype(request.clusterId)>(chip::JniReferences::GetInstance().LongToPrimitive(clusterId));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BindingCluster, unbind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject nodeId, jobject groupId, jobject endpointId,
 jobject clusterId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BindingCluster * cppCluster;

    chip::app::Clusters::Binding::Commands::Unbind::Type request;

    request.nodeId  = static_cast<decltype(request.nodeId)>(chip::JniReferences::GetInstance().LongToPrimitive(nodeId));
    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.endpointId =
        static_cast<decltype(request.endpointId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(endpointId));
    request.clusterId = static_cast<decltype(request.clusterId)>(chip::JniReferences::GetInstance().LongToPrimitive(clusterId));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BindingCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err              = CHIP_NO_ERROR;
    BindingCluster * cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BindingCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err              = CHIP_NO_ERROR;
    BindingCluster * cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BooleanStateCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BooleanStateCluster * cppCluster = new BooleanStateCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BooleanStateCluster, subscribeStateValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    BooleanStateCluster * cppCluster = reinterpret_cast<BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStateValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BooleanStateCluster, reportStateValueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    BooleanStateCluster * cppCluster = reinterpret_cast<BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStateValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BooleanStateCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    BooleanStateCluster * cppCluster = reinterpret_cast<BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BooleanStateCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    BooleanStateCluster * cppCluster = reinterpret_cast<BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BridgedActionsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster = new BridgedActionsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BridgedActionsCluster, disableAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::DisableAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, disableActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID, jobject duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::DisableActionWithDuration::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));
    request.duration = static_cast<decltype(request.duration)>(chip::JniReferences::GetInstance().LongToPrimitive(duration));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, enableAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::EnableAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, enableActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID, jobject duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::EnableActionWithDuration::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));
    request.duration = static_cast<decltype(request.duration)>(chip::JniReferences::GetInstance().LongToPrimitive(duration));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, instantAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::InstantAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, instantActionWithTransition)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID, jobject transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::InstantActionWithTransition::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, pauseAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::PauseAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, pauseActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID, jobject duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::PauseActionWithDuration::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));
    request.duration = static_cast<decltype(request.duration)>(chip::JniReferences::GetInstance().LongToPrimitive(duration));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, resumeAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::ResumeAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, startAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::StartAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, startActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID, jobject duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::StartActionWithDuration::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));
    request.duration = static_cast<decltype(request.duration)>(chip::JniReferences::GetInstance().LongToPrimitive(duration));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, stopAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject actionID, jobject invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    chip::app::Clusters::BridgedActions::Commands::StopAction::Type request;

    request.actionID = static_cast<decltype(request.actionID)>(chip::JniReferences::GetInstance().IntegerToPrimitive(actionID));
    chip::JniReferences::GetInstance().GetOptionalValue(invokeID, invokeID);
    request.invokeID = chip::Optional<uint32_t>(
        static_cast<decltype(request.invokeID)>(chip::JniReferences::GetInstance().LongToPrimitive(invokeID)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, BridgedActionsCluster, subscribeSetupUrlAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSetupUrl(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BridgedActionsCluster, reportSetupUrlAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSetupUrl(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, BridgedActionsCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BridgedActionsCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BridgedDeviceBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BridgedDeviceBasicCluster * cppCluster = new BridgedDeviceBasicCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BridgedDeviceBasicCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ColorControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster = new ColorControlCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ColorControlCluster, colorLoopSet)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject updateFlags, jobject action, jobject direction,
 jobject time, jobject startHue, jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;

    request.updateFlags =
        static_cast<decltype(request.updateFlags)>(chip::JniReferences::GetInstance().IntegerToPrimitive(updateFlags));
    request.action    = static_cast<decltype(request.action)>(chip::JniReferences::GetInstance().IntegerToPrimitive(action));
    request.direction = static_cast<decltype(request.direction)>(chip::JniReferences::GetInstance().IntegerToPrimitive(direction));
    request.time      = static_cast<decltype(request.time)>(chip::JniReferences::GetInstance().IntegerToPrimitive(time));
    request.startHue  = static_cast<decltype(request.startHue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(startHue));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate, jobject optionsMask,
 jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject enhancedHue, jobject direction, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type request;

    request.enhancedHue =
        static_cast<decltype(request.enhancedHue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(enhancedHue));
    request.direction = static_cast<decltype(request.direction)>(chip::JniReferences::GetInstance().IntegerToPrimitive(direction));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject enhancedHue, jobject saturation, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type request;

    request.enhancedHue =
        static_cast<decltype(request.enhancedHue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(enhancedHue));
    request.saturation =
        static_cast<decltype(request.saturation)>(chip::JniReferences::GetInstance().IntegerToPrimitive(saturation));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, enhancedStepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject rateX, jobject rateY, jobject optionsMask,
 jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveColor::Type request;

    request.rateX = static_cast<decltype(request.rateX)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rateX));
    request.rateY = static_cast<decltype(request.rateY)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rateY));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate, jobject colorTemperatureMinimum,
 jobject colorTemperatureMaximum, jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));
    request.colorTemperatureMinimum = static_cast<decltype(request.colorTemperatureMinimum)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(colorTemperatureMinimum));
    request.colorTemperatureMaximum = static_cast<decltype(request.colorTemperatureMaximum)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(colorTemperatureMaximum));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate, jobject optionsMask,
 jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveHue::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate, jobject optionsMask,
 jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveToColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject colorX, jobject colorY, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveToColor::Type request;

    request.colorX = static_cast<decltype(request.colorX)>(chip::JniReferences::GetInstance().IntegerToPrimitive(colorX));
    request.colorY = static_cast<decltype(request.colorY)>(chip::JniReferences::GetInstance().IntegerToPrimitive(colorY));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveToColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject colorTemperature, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type request;

    request.colorTemperature =
        static_cast<decltype(request.colorTemperature)>(chip::JniReferences::GetInstance().IntegerToPrimitive(colorTemperature));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject hue, jobject direction, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveToHue::Type request;

    request.hue       = static_cast<decltype(request.hue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(hue));
    request.direction = static_cast<decltype(request.direction)>(chip::JniReferences::GetInstance().IntegerToPrimitive(direction));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject hue, jobject saturation, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type request;

    request.hue = static_cast<decltype(request.hue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(hue));
    request.saturation =
        static_cast<decltype(request.saturation)>(chip::JniReferences::GetInstance().IntegerToPrimitive(saturation));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, moveToSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject saturation, jobject transitionTime, jobject optionsMask,
 jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type request;

    request.saturation =
        static_cast<decltype(request.saturation)>(chip::JniReferences::GetInstance().IntegerToPrimitive(saturation));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, stepColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepX, jobject stepY, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::StepColor::Type request;

    request.stepX = static_cast<decltype(request.stepX)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepX));
    request.stepY = static_cast<decltype(request.stepY)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepY));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, stepColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime,
 jobject colorTemperatureMinimum, jobject colorTemperatureMaximum, jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.colorTemperatureMinimum = static_cast<decltype(request.colorTemperatureMinimum)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(colorTemperatureMinimum));
    request.colorTemperatureMaximum = static_cast<decltype(request.colorTemperatureMaximum)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(colorTemperatureMaximum));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, stepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::StepHue::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, stepSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime,
 jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::StepSaturation::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, stopMoveStep)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject optionsMask, jobject optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type request;

    request.optionsMask =
        static_cast<decltype(request.optionsMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsMask));
    request.optionsOverride =
        static_cast<decltype(request.optionsOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionsOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeCurrentHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentHue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentHueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentHue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeCurrentSaturationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentSaturation(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentSaturationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentSaturation(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeRemainingTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRemainingTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportRemainingTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRemainingTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeCurrentXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentX(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeCurrentYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentY(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeDriftCompensationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeDriftCompensation(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportDriftCompensationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeDriftCompensation(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeCompensationTextAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCompensationText(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCompensationTextAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCompensationText(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorTemperature(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorTemperature(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorControlOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorControlOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorControlOptions(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorControlOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorControlOptions(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeNumberOfPrimariesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNumberOfPrimaries(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportNumberOfPrimariesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNumberOfPrimaries(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary1XAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary1X(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary1XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary1X(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary1YAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary1Y(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary1YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary1Y(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary1IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary1Intensity(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary1IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary1Intensity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary2XAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary2X(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary2XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary2X(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary2YAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary2Y(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary2YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary2Y(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary2IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary2Intensity(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary2IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary2Intensity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary3XAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary3X(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary3XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary3X(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary3YAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary3Y(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary3YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary3Y(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary3IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary3Intensity(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary3IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary3Intensity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary4XAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary4X(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary4XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary4X(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary4YAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary4Y(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary4YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary4Y(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary4IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary4Intensity(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary4IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary4Intensity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary5XAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary5X(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary5XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary5X(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary5YAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary5Y(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary5YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary5Y(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary5IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary5Intensity(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary5IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary5Intensity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary6XAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary6X(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary6XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary6X(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary6YAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary6Y(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary6YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary6Y(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribePrimary6IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePrimary6Intensity(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportPrimary6IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePrimary6Intensity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeWhitePointXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeWhitePointX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportWhitePointXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeWhitePointX(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeWhitePointYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeWhitePointY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportWhitePointYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeWhitePointY(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorPointRXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorPointRX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorPointRXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorPointRX(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorPointRYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorPointRY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorPointRYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorPointRY(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointRIntensity::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorPointRIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorPointRIntensity(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorPointRIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorPointRIntensity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorPointGXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorPointGX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorPointGXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorPointGX(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorPointGYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorPointGY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorPointGYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorPointGY(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointGIntensity::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorPointGIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorPointGIntensity(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorPointGIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorPointGIntensity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorPointBXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorPointBX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorPointBXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorPointBX(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorPointBYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorPointBY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorPointBYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorPointBY(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointBIntensity::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorPointBIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorPointBIntensity(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorPointBIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorPointBIntensity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeEnhancedCurrentHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeEnhancedCurrentHue(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportEnhancedCurrentHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeEnhancedCurrentHue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeEnhancedColorModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeEnhancedColorMode(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportEnhancedColorModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeEnhancedColorMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorLoopActiveAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorLoopActive(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorLoopActiveAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorLoopActive(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorLoopDirectionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorLoopDirection(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorLoopDirectionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorLoopDirection(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorLoopTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorLoopTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorLoopTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorLoopTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorLoopStartEnhancedHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorLoopStartEnhancedHue(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorLoopStartEnhancedHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorLoopStartEnhancedHue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorLoopStoredEnhancedHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorLoopStoredEnhancedHue(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorLoopStoredEnhancedHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorLoopStoredEnhancedHue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorCapabilitiesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorCapabilities(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorCapabilitiesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorCapabilities(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorTempPhysicalMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorTempPhysicalMin(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorTempPhysicalMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorTempPhysicalMin(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeColorTempPhysicalMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorTempPhysicalMax(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorTempPhysicalMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorTempPhysicalMax(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeCoupleColorTempToLevelMinMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCoupleColorTempToLevelMinMireds(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCoupleColorTempToLevelMinMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCoupleColorTempToLevelMinMireds(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeStartUpColorTemperatureMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeStartUpColorTemperatureMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStartUpColorTemperatureMireds(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportStartUpColorTemperatureMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStartUpColorTemperatureMireds(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ColorControlCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ContentLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ContentLauncherCluster * cppCluster = new ContentLauncherCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ContentLauncherCluster, launchContent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject autoPlay, jstring data)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster;

    chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type request;

    request.autoPlay = static_cast<decltype(request.autoPlay)>(chip::JniReferences::GetInstance().BooleanToPrimitive(autoPlay));
    request.data     = chip::JniUtfString(env, static_cast<jstring>(data)).charSpan();

    std::unique_ptr<CHIPContentLauncherClusterLaunchContentResponseCallback,
                    void (*)(CHIPContentLauncherClusterLaunchContentResponseCallback *)>
        onSuccess(Platform::New<CHIPContentLauncherClusterLaunchContentResponseCallback>(callback),
                  Platform::Delete<CHIPContentLauncherClusterLaunchContentResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPContentLauncherClusterLaunchContentResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ContentLauncherCluster, launchURL)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring contentURL, jstring displayString)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster;

    chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type request;

    request.contentURL    = chip::JniUtfString(env, static_cast<jstring>(contentURL)).charSpan();
    request.displayString = chip::JniUtfString(env, static_cast<jstring>(displayString)).charSpan();

    std::unique_ptr<CHIPContentLauncherClusterLaunchURLResponseCallback,
                    void (*)(CHIPContentLauncherClusterLaunchURLResponseCallback *)>
        onSuccess(Platform::New<CHIPContentLauncherClusterLaunchURLResponseCallback>(callback),
                  Platform::Delete<CHIPContentLauncherClusterLaunchURLResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPContentLauncherClusterLaunchURLResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ContentLauncherCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ContentLauncherCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, DescriptorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DescriptorCluster * cppCluster = new DescriptorCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DescriptorCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    DescriptorCluster * cppCluster = reinterpret_cast<DescriptorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DescriptorCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    DescriptorCluster * cppCluster = reinterpret_cast<DescriptorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, DiagnosticLogsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DiagnosticLogsCluster * cppCluster = new DiagnosticLogsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DiagnosticLogsCluster, retrieveLogsRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject intent, jobject requestedProtocol,
 jbyteArray transferFileDesignator)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DiagnosticLogsCluster * cppCluster;

    chip::app::Clusters::DiagnosticLogs::Commands::RetrieveLogsRequest::Type request;

    request.intent = static_cast<decltype(request.intent)>(chip::JniReferences::GetInstance().IntegerToPrimitive(intent));
    request.requestedProtocol =
        static_cast<decltype(request.requestedProtocol)>(chip::JniReferences::GetInstance().IntegerToPrimitive(requestedProtocol));
    request.transferFileDesignator = chip::JniByteArray(env, static_cast<jbyteArray>(transferFileDesignator)).byteSpan();

    std::unique_ptr<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback,
                    void (*)(CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback *)>
        onSuccess(Platform::New<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback>(callback),
                  Platform::Delete<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DiagnosticLogsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, DoorLockCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster = new DoorLockCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DoorLockCluster, clearAllPINCodes)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearAllPINCodes::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearAllRFIDCodes)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearAllRFIDCodes::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject holidayIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearHolidaySchedule::Type request;

    request.holidayIndex =
        static_cast<decltype(request.holidayIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(holidayIndex));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearPINCode)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject pinSlotIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearPINCode::Type request;

    request.pinSlotIndex =
        static_cast<decltype(request.pinSlotIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(pinSlotIndex));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearRFIDCode)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject rfidSlotIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearRFIDCode::Type request;

    request.rfidSlotIndex =
        static_cast<decltype(request.rfidSlotIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rfidSlotIndex));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearWeekDaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject weekDayIndex, jobject userIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type request;

    request.weekDayIndex =
        static_cast<decltype(request.weekDayIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(weekDayIndex));
    request.userIndex = static_cast<decltype(request.userIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userIndex));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, clearYearDaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject yearDayIndex, jobject userIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type request;

    request.yearDayIndex =
        static_cast<decltype(request.yearDayIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(yearDayIndex));
    request.userIndex = static_cast<decltype(request.userIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userIndex));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject holidayIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetHolidaySchedule::Type request;

    request.holidayIndex =
        static_cast<decltype(request.holidayIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(holidayIndex));

    std::unique_ptr<CHIPDoorLockClusterGetHolidayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetHolidayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetHolidayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetHolidayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetHolidayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getLogRecord)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject logIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetLogRecord::Type request;

    request.logIndex = static_cast<decltype(request.logIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(logIndex));

    std::unique_ptr<CHIPDoorLockClusterGetLogRecordResponseCallback, void (*)(CHIPDoorLockClusterGetLogRecordResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetLogRecordResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetLogRecordResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetLogRecordResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getPINCode)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetPINCode::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterGetPINCodeResponseCallback, void (*)(CHIPDoorLockClusterGetPINCodeResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetPINCodeResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetPINCodeResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetPINCodeResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getRFIDCode)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetRFIDCode::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterGetRFIDCodeResponseCallback, void (*)(CHIPDoorLockClusterGetRFIDCodeResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetRFIDCodeResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetRFIDCodeResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetRFIDCodeResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getUserType)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetUserType::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));

    std::unique_ptr<CHIPDoorLockClusterGetUserTypeResponseCallback, void (*)(CHIPDoorLockClusterGetUserTypeResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetUserTypeResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetUserTypeResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetUserTypeResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getWeekDaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject weekDayIndex, jobject userIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type request;

    request.weekDayIndex =
        static_cast<decltype(request.weekDayIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(weekDayIndex));
    request.userIndex = static_cast<decltype(request.userIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userIndex));

    std::unique_ptr<CHIPDoorLockClusterGetWeekDayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetWeekDayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetWeekDayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetWeekDayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetWeekDayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, getYearDaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject yearDayIndex, jobject userIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type request;

    request.yearDayIndex =
        static_cast<decltype(request.yearDayIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(yearDayIndex));
    request.userIndex = static_cast<decltype(request.userIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userIndex));

    std::unique_ptr<CHIPDoorLockClusterGetYearDayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetYearDayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetYearDayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetYearDayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPDoorLockClusterGetYearDayScheduleResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, lockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject pinCode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::LockDoor::Type request;

    chip::JniReferences::GetInstance().GetOptionalValue(pinCode, pinCode);
    request.pinCode = chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(pinCode)).byteSpan());

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject holidayIndex, jobject localStartTime, jobject localEndTime,
 jobject operatingMode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetHolidaySchedule::Type request;

    request.holidayIndex =
        static_cast<decltype(request.holidayIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(holidayIndex));
    request.localStartTime =
        static_cast<decltype(request.localStartTime)>(chip::JniReferences::GetInstance().LongToPrimitive(localStartTime));
    request.localEndTime =
        static_cast<decltype(request.localEndTime)>(chip::JniReferences::GetInstance().LongToPrimitive(localEndTime));
    request.operatingMode =
        static_cast<decltype(request.operatingMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(operatingMode));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setPINCode)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId, jobject userStatus, jobject userType,
 jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetPINCode::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));
    request.userStatus =
        static_cast<decltype(request.userStatus)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userStatus));
    request.userType = static_cast<decltype(request.userType)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userType));
    request.pin      = chip::JniByteArray(env, static_cast<jbyteArray>(pin)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setRFIDCode)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId, jobject userStatus, jobject userType,
 jbyteArray rfidCode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetRFIDCode::Type request;

    request.userId = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));
    request.userStatus =
        static_cast<decltype(request.userStatus)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userStatus));
    request.userType = static_cast<decltype(request.userType)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userType));
    request.rfidCode = chip::JniByteArray(env, static_cast<jbyteArray>(rfidCode)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setUserType)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject userId, jobject userType)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetUserType::Type request;

    request.userId   = static_cast<decltype(request.userId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userId));
    request.userType = static_cast<decltype(request.userType)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userType));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setWeekDaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject weekDayIndex, jobject userIndex, jobject daysMask,
 jobject startHour, jobject startMinute, jobject endHour, jobject endMinute)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type request;

    request.weekDayIndex =
        static_cast<decltype(request.weekDayIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(weekDayIndex));
    request.userIndex = static_cast<decltype(request.userIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userIndex));
    request.daysMask  = static_cast<decltype(request.daysMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(daysMask));
    request.startHour = static_cast<decltype(request.startHour)>(chip::JniReferences::GetInstance().IntegerToPrimitive(startHour));
    request.startMinute =
        static_cast<decltype(request.startMinute)>(chip::JniReferences::GetInstance().IntegerToPrimitive(startMinute));
    request.endHour   = static_cast<decltype(request.endHour)>(chip::JniReferences::GetInstance().IntegerToPrimitive(endHour));
    request.endMinute = static_cast<decltype(request.endMinute)>(chip::JniReferences::GetInstance().IntegerToPrimitive(endMinute));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, setYearDaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject yearDayIndex, jobject userIndex, jobject localStartTime,
 jobject localEndTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type request;

    request.yearDayIndex =
        static_cast<decltype(request.yearDayIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(yearDayIndex));
    request.userIndex = static_cast<decltype(request.userIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(userIndex));
    request.localStartTime =
        static_cast<decltype(request.localStartTime)>(chip::JniReferences::GetInstance().LongToPrimitive(localStartTime));
    request.localEndTime =
        static_cast<decltype(request.localEndTime)>(chip::JniReferences::GetInstance().LongToPrimitive(localEndTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, unlockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject pinCode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type request;

    chip::JniReferences::GetInstance().GetOptionalValue(pinCode, pinCode);
    request.pinCode = chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(pinCode)).byteSpan());

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, unlockWithTimeout)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject timeout, jobject pinCode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    chip::app::Clusters::DoorLock::Commands::UnlockWithTimeout::Type request;

    request.timeout = static_cast<decltype(request.timeout)>(chip::JniReferences::GetInstance().IntegerToPrimitive(timeout));
    chip::JniReferences::GetInstance().GetOptionalValue(pinCode, pinCode);
    request.pinCode = chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(pinCode)).byteSpan());

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, DoorLockCluster, subscribeActuatorEnabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeActuatorEnabled(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, reportActuatorEnabledAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeActuatorEnabled(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, DoorLockCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ElectricalMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ElectricalMeasurementCluster * cppCluster = new ElectricalMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ElectricalMeasurementCluster, subscribeMeasurementTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasurementType(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportMeasurementTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasurementType(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeTotalActivePowerAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTotalActivePower(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportTotalActivePowerAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32sAttributeCallback, void (*)(CHIPInt32sAttributeCallback *)> onReport(
        Platform::New<CHIPInt32sAttributeCallback>(callback, true), Platform::Delete<CHIPInt32sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTotalActivePower(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeRmsVoltageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRmsVoltage(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportRmsVoltageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRmsVoltage(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeRmsVoltageMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRmsVoltageMin(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportRmsVoltageMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRmsVoltageMin(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeRmsVoltageMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRmsVoltageMax(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportRmsVoltageMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRmsVoltageMax(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeRmsCurrentAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRmsCurrent(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportRmsCurrentAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRmsCurrent(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeRmsCurrentMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRmsCurrentMin(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportRmsCurrentMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRmsCurrentMin(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeRmsCurrentMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRmsCurrentMax(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportRmsCurrentMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRmsCurrentMax(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeActivePowerAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeActivePower(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportActivePowerAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeActivePower(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeActivePowerMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeActivePowerMin(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportActivePowerMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeActivePowerMin(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeActivePowerMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeActivePowerMax(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportActivePowerMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeActivePowerMax(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ElectricalMeasurementCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                            = CHIP_NO_ERROR;
    ElectricalMeasurementCluster * cppCluster = reinterpret_cast<ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, EthernetNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    EthernetNetworkDiagnosticsCluster * cppCluster = new EthernetNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster;

    chip::app::Clusters::EthernetNetworkDiagnostics::Commands::ResetCounts::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, subscribePHYRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePHYRate(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, reportPHYRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePHYRate(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, subscribeFullDuplexAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeFullDuplex(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, reportFullDuplexAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeFullDuplex(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, subscribePacketRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePacketRxCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, reportPacketRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePacketRxCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, subscribePacketTxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePacketTxCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, reportPacketTxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePacketTxCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, subscribeTxErrCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxErrCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, reportTxErrCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxErrCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, subscribeCollisionCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCollisionCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, reportCollisionCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCollisionCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, subscribeOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOverrunCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, reportOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOverrunCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, subscribeCarrierDetectAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCarrierDetect(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, reportCarrierDetectAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCarrierDetect(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, subscribeTimeSinceResetAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTimeSinceReset(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, reportTimeSinceResetAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTimeSinceReset(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, FixedLabelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    FixedLabelCluster * cppCluster = new FixedLabelCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, FixedLabelCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    FixedLabelCluster * cppCluster = reinterpret_cast<FixedLabelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, FixedLabelCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    FixedLabelCluster * cppCluster = reinterpret_cast<FixedLabelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, FlowMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    FlowMeasurementCluster * cppCluster = new FlowMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, FlowMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, FlowMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, FlowMeasurementCluster, subscribeMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, FlowMeasurementCluster, reportMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, FlowMeasurementCluster, subscribeMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, FlowMeasurementCluster, reportMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, FlowMeasurementCluster, subscribeToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTolerance(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, FlowMeasurementCluster, reportToleranceAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTolerance(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, FlowMeasurementCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, FlowMeasurementCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    FlowMeasurementCluster * cppCluster = reinterpret_cast<FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, GeneralCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GeneralCommissioningCluster * cppCluster = new GeneralCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GeneralCommissioningCluster, armFailSafe)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject expiryLengthSeconds, jobject breadcrumb, jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafe::Type request;

    request.expiryLengthSeconds = static_cast<decltype(request.expiryLengthSeconds)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(expiryLengthSeconds));
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterArmFailSafeResponseCallback *)>
        onSuccess(Platform::New<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback>(callback),
                  Platform::Delete<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPGeneralCommissioningClusterArmFailSafeResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GeneralCommissioningCluster, commissioningComplete)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    chip::app::Clusters::GeneralCommissioning::Commands::CommissioningComplete::Type request;

    std::unique_ptr<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback *)>
        onSuccess(Platform::New<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback>(callback),
                  Platform::Delete<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallbackType>::FromCancelable(
            onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GeneralCommissioningCluster, setRegulatoryConfig)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject location, jstring countryCode, jobject breadcrumb,
 jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    chip::app::Clusters::GeneralCommissioning::Commands::SetRegulatoryConfig::Type request;

    request.location    = static_cast<decltype(request.location)>(chip::JniReferences::GetInstance().IntegerToPrimitive(location));
    request.countryCode = chip::JniUtfString(env, static_cast<jstring>(countryCode)).charSpan();
    request.breadcrumb  = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs   = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback *)>
        onSuccess(Platform::New<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback>(callback),
                  Platform::Delete<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallbackType>::FromCancelable(
            onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralCommissioningCluster, writeBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::GeneralCommissioning::Attributes::Breadcrumb::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GeneralCommissioningCluster, subscribeBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBreadcrumb(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralCommissioningCluster, reportBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBreadcrumb(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, GeneralCommissioningCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralCommissioningCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, GeneralDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GeneralDiagnosticsCluster * cppCluster = new GeneralDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GeneralDiagnosticsCluster, subscribeRebootCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRebootCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, reportRebootCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRebootCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, GeneralDiagnosticsCluster, subscribeUpTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeUpTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, reportUpTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeUpTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, GeneralDiagnosticsCluster, subscribeTotalOperationalHoursAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTotalOperationalHours(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, reportTotalOperationalHoursAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTotalOperationalHours(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, GeneralDiagnosticsCluster, subscribeBootReasonsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBootReasons(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, reportBootReasonsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBootReasons(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, GeneralDiagnosticsCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GeneralDiagnosticsCluster * cppCluster = reinterpret_cast<GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, GroupKeyManagementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GroupKeyManagementCluster * cppCluster = new GroupKeyManagementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GroupKeyManagementCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GroupKeyManagementCluster * cppCluster = reinterpret_cast<GroupKeyManagementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GroupKeyManagementCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    GroupKeyManagementCluster * cppCluster = reinterpret_cast<GroupKeyManagementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, GroupsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GroupsCluster * cppCluster = new GroupsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GroupsCluster, addGroup)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jstring groupName)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::AddGroup::Type request;

    request.groupId   = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.groupName = chip::JniUtfString(env, static_cast<jstring>(groupName)).charSpan();

    std::unique_ptr<CHIPGroupsClusterAddGroupResponseCallback, void (*)(CHIPGroupsClusterAddGroupResponseCallback *)> onSuccess(
        Platform::New<CHIPGroupsClusterAddGroupResponseCallback>(callback),
        Platform::Delete<CHIPGroupsClusterAddGroupResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPGroupsClusterAddGroupResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, addGroupIfIdentifying)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jstring groupName)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::AddGroupIfIdentifying::Type request;

    request.groupId   = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.groupName = chip::JniUtfString(env, static_cast<jstring>(groupName)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, getGroupMembership)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupList)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::GetGroupMembership::Type request;

    request.groupList = chip::app::DataModel::List<const uint16_t>();

    std::unique_ptr<CHIPGroupsClusterGetGroupMembershipResponseCallback,
                    void (*)(CHIPGroupsClusterGetGroupMembershipResponseCallback *)>
        onSuccess(Platform::New<CHIPGroupsClusterGetGroupMembershipResponseCallback>(callback),
                  Platform::Delete<CHIPGroupsClusterGetGroupMembershipResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPGroupsClusterGetGroupMembershipResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, removeAllGroups)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, removeGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::RemoveGroup::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));

    std::unique_ptr<CHIPGroupsClusterRemoveGroupResponseCallback, void (*)(CHIPGroupsClusterRemoveGroupResponseCallback *)>
        onSuccess(Platform::New<CHIPGroupsClusterRemoveGroupResponseCallback>(callback),
                  Platform::Delete<CHIPGroupsClusterRemoveGroupResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPGroupsClusterRemoveGroupResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, viewGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    chip::app::Clusters::Groups::Commands::ViewGroup::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));

    std::unique_ptr<CHIPGroupsClusterViewGroupResponseCallback, void (*)(CHIPGroupsClusterViewGroupResponseCallback *)> onSuccess(
        Platform::New<CHIPGroupsClusterViewGroupResponseCallback>(callback),
        Platform::Delete<CHIPGroupsClusterViewGroupResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPGroupsClusterViewGroupResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, GroupsCluster, subscribeNameSupportAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    GroupsCluster * cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNameSupport(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GroupsCluster, reportNameSupportAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    GroupsCluster * cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNameSupport(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, GroupsCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    GroupsCluster * cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GroupsCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    GroupsCluster * cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, IdentifyCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    IdentifyCluster * cppCluster = new IdentifyCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, IdentifyCluster, identify)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject identifyTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    chip::app::Clusters::Identify::Commands::Identify::Type request;

    request.identifyTime =
        static_cast<decltype(request.identifyTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(identifyTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, IdentifyCluster, identifyQuery)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    chip::app::Clusters::Identify::Commands::IdentifyQuery::Type request;

    std::unique_ptr<CHIPIdentifyClusterIdentifyQueryResponseCallback, void (*)(CHIPIdentifyClusterIdentifyQueryResponseCallback *)>
        onSuccess(Platform::New<CHIPIdentifyClusterIdentifyQueryResponseCallback>(callback),
                  Platform::Delete<CHIPIdentifyClusterIdentifyQueryResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPIdentifyClusterIdentifyQueryResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, IdentifyCluster, triggerEffect)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject effectIdentifier, jobject effectVariant)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    chip::app::Clusters::Identify::Commands::TriggerEffect::Type request;

    request.effectIdentifier =
        static_cast<decltype(request.effectIdentifier)>(chip::JniReferences::GetInstance().IntegerToPrimitive(effectIdentifier));
    request.effectVariant =
        static_cast<decltype(request.effectVariant)>(chip::JniReferences::GetInstance().IntegerToPrimitive(effectVariant));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IdentifyCluster, writeIdentifyTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Identify::Attributes::IdentifyTime::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, IdentifyCluster, subscribeIdentifyTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeIdentifyTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IdentifyCluster, reportIdentifyTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeIdentifyTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, IdentifyCluster, subscribeIdentifyTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeIdentifyType(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IdentifyCluster, reportIdentifyTypeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeIdentifyType(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, IdentifyCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IdentifyCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, IlluminanceMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    IlluminanceMeasurementCluster * cppCluster = new IlluminanceMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, IlluminanceMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, IlluminanceMeasurementCluster, subscribeMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, reportMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, IlluminanceMeasurementCluster, subscribeMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, reportMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, IlluminanceMeasurementCluster, subscribeToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTolerance(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, reportToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTolerance(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, IlluminanceMeasurementCluster, subscribeLightSensorTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLightSensorType(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, reportLightSensorTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLightSensorType(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, IlluminanceMeasurementCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, KeypadInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    KeypadInputCluster * cppCluster = new KeypadInputCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, KeypadInputCluster, sendKey)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject keyCode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    KeypadInputCluster * cppCluster;

    chip::app::Clusters::KeypadInput::Commands::SendKey::Type request;

    request.keyCode = static_cast<decltype(request.keyCode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(keyCode));

    std::unique_ptr<CHIPKeypadInputClusterSendKeyResponseCallback, void (*)(CHIPKeypadInputClusterSendKeyResponseCallback *)>
        onSuccess(Platform::New<CHIPKeypadInputClusterSendKeyResponseCallback>(callback),
                  Platform::Delete<CHIPKeypadInputClusterSendKeyResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<KeypadInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPKeypadInputClusterSendKeyResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, KeypadInputCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    KeypadInputCluster * cppCluster = reinterpret_cast<KeypadInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, KeypadInputCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    KeypadInputCluster * cppCluster = reinterpret_cast<KeypadInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, LevelControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster = new LevelControlCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LevelControlCluster, move)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate, jobject optionMask,
 jobject optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::Move::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));
    request.optionMask =
        static_cast<decltype(request.optionMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionMask));
    request.optionOverride =
        static_cast<decltype(request.optionOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, moveToLevel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject level, jobject transitionTime, jobject optionMask,
 jobject optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type request;

    request.level = static_cast<decltype(request.level)>(chip::JniReferences::GetInstance().IntegerToPrimitive(level));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionMask =
        static_cast<decltype(request.optionMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionMask));
    request.optionOverride =
        static_cast<decltype(request.optionOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, moveToLevelWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject level, jobject transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::MoveToLevelWithOnOff::Type request;

    request.level = static_cast<decltype(request.level)>(chip::JniReferences::GetInstance().IntegerToPrimitive(level));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, moveWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject moveMode, jobject rate)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::MoveWithOnOff::Type request;

    request.moveMode = static_cast<decltype(request.moveMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(moveMode));
    request.rate     = static_cast<decltype(request.rate)>(chip::JniReferences::GetInstance().IntegerToPrimitive(rate));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, step)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime,
 jobject optionMask, jobject optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::Step::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.optionMask =
        static_cast<decltype(request.optionMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionMask));
    request.optionOverride =
        static_cast<decltype(request.optionOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, stepWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject stepMode, jobject stepSize, jobject transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::StepWithOnOff::Type request;

    request.stepMode = static_cast<decltype(request.stepMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepMode));
    request.stepSize = static_cast<decltype(request.stepSize)>(chip::JniReferences::GetInstance().IntegerToPrimitive(stepSize));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, stop)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject optionMask, jobject optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::Stop::Type request;

    request.optionMask =
        static_cast<decltype(request.optionMask)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionMask));
    request.optionOverride =
        static_cast<decltype(request.optionOverride)>(chip::JniReferences::GetInstance().IntegerToPrimitive(optionOverride));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, stopWithOnOff)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    chip::app::Clusters::LevelControl::Commands::StopWithOnOff::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentLevel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportCurrentLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentLevel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeRemainingTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRemainingTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportRemainingTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRemainingTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeMinLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinLevel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportMinLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinLevel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeMaxLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxLevel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportMaxLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxLevel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeCurrentFrequencyAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentFrequency(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportCurrentFrequencyAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentFrequency(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeMinFrequencyAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinFrequency(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportMinFrequencyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinFrequency(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeMaxFrequencyAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxFrequency(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportMaxFrequencyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxFrequency(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, LevelControlCluster, writeOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOptions(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportOptionsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOptions(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeOnOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOnOffTransitionTime(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportOnOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOnOffTransitionTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeOnLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOnLevel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportOnLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOnLevel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeOnTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOnTransitionTime(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportOnTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOnTransitionTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, LevelControlCluster, writeOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOffTransitionTime(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOffTransitionTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, LevelControlCluster, writeDefaultMoveRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeDefaultMoveRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeDefaultMoveRate(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportDefaultMoveRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeDefaultMoveRate(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, LevelControlCluster, writeStartUpCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeStartUpCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStartUpCurrentLevel(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportStartUpCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStartUpCurrentLevel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, LevelControlCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, LowPowerCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    LowPowerCluster * cppCluster = new LowPowerCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LowPowerCluster, sleep)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LowPowerCluster * cppCluster;

    chip::app::Clusters::LowPower::Commands::Sleep::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<LowPowerCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, LowPowerCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    LowPowerCluster * cppCluster = reinterpret_cast<LowPowerCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LowPowerCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    LowPowerCluster * cppCluster = reinterpret_cast<LowPowerCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, MediaInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    MediaInputCluster * cppCluster = new MediaInputCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaInputCluster, hideInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaInputCluster, renameInput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject index, jstring name)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    chip::app::Clusters::MediaInput::Commands::RenameInput::Type request;

    request.index = static_cast<decltype(request.index)>(chip::JniReferences::GetInstance().IntegerToPrimitive(index));
    request.name  = chip::JniUtfString(env, static_cast<jstring>(name)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaInputCluster, selectInput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject index)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    chip::app::Clusters::MediaInput::Commands::SelectInput::Type request;

    request.index = static_cast<decltype(request.index)>(chip::JniReferences::GetInstance().IntegerToPrimitive(index));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaInputCluster, showInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaInputCluster, subscribeCurrentMediaInputAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentMediaInput(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaInputCluster, reportCurrentMediaInputAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentMediaInput(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, MediaInputCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaInputCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, MediaPlaybackCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster = new MediaPlaybackCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaPlaybackCluster, mediaFastForward)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaFastForward::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaFastForwardResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaFastForwardResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaNext)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaNext::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaNextResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaNextResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaNextResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaNextResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaNextResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPause)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaPause::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPauseResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPauseResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaPauseResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaPauseResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaPauseResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPlay)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaPlay::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPlayResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPlayResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaPlayResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaPlayResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaPlayResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPrevious)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaPrevious::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPreviousResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPreviousResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaPreviousResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaPreviousResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaPreviousResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaRewind)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaRewind::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaRewindResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaRewindResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaRewindResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaRewindResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaRewindResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSeek)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject position)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaSeek::Type request;

    request.position = static_cast<decltype(request.position)>(chip::JniReferences::GetInstance().LongToPrimitive(position));

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSeekResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSeekResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaSeekResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaSeekResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaSeekResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipBackward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject deltaPositionMilliseconds)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackward::Type request;

    request.deltaPositionMilliseconds = static_cast<decltype(request.deltaPositionMilliseconds)>(
        chip::JniReferences::GetInstance().LongToPrimitive(deltaPositionMilliseconds));

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipForward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject deltaPositionMilliseconds)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaSkipForward::Type request;

    request.deltaPositionMilliseconds = static_cast<decltype(request.deltaPositionMilliseconds)>(
        chip::JniReferences::GetInstance().LongToPrimitive(deltaPositionMilliseconds));

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStartOver)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaStartOver::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaStartOverResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaStartOverResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaStartOverResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaStartOverResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaStartOverResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    chip::app::Clusters::MediaPlayback::Commands::MediaStop::Type request;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaStopResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaStopResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaStopResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaStopResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPMediaPlaybackClusterMediaStopResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, MediaPlaybackCluster, subscribePlaybackStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePlaybackState(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaPlaybackCluster, reportPlaybackStateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePlaybackState(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, MediaPlaybackCluster, subscribeStartTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStartTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaPlaybackCluster, reportStartTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStartTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, MediaPlaybackCluster, subscribeDurationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeDuration(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaPlaybackCluster, reportDurationAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeDuration(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, MediaPlaybackCluster, subscribePositionUpdatedAtAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePositionUpdatedAt(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaPlaybackCluster, reportPositionUpdatedAtAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePositionUpdatedAt(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, MediaPlaybackCluster, subscribePositionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePosition(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaPlaybackCluster, reportPositionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePosition(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, MediaPlaybackCluster, subscribePlaybackSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePlaybackSpeed(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaPlaybackCluster, reportPlaybackSpeedAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePlaybackSpeed(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, MediaPlaybackCluster, subscribeSeekRangeEndAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSeekRangeEnd(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaPlaybackCluster, reportSeekRangeEndAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSeekRangeEnd(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, MediaPlaybackCluster, subscribeSeekRangeStartAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSeekRangeStart(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaPlaybackCluster, reportSeekRangeStartAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSeekRangeStart(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, MediaPlaybackCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, MediaPlaybackCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ModeSelectCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ModeSelectCluster * cppCluster = new ModeSelectCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ModeSelectCluster, changeToMode)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject newMode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster;

    chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type request;

    request.newMode = static_cast<decltype(request.newMode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(newMode));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ModeSelectCluster, subscribeCurrentModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ModeSelectCluster, reportCurrentModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ModeSelectCluster, writeOnModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ModeSelect::Attributes::OnMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ModeSelectCluster, subscribeOnModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOnMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ModeSelectCluster, reportOnModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOnMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ModeSelectCluster, subscribeStartUpModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStartUpMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ModeSelectCluster, reportStartUpModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStartUpMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ModeSelectCluster, subscribeDescriptionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeDescription(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ModeSelectCluster, reportDescriptionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeDescription(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ModeSelectCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ModeSelectCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, NetworkCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster = new NetworkCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, NetworkCommissioningCluster, addThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jobject breadcrumb,
 jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::AddThreadNetwork::Type request;

    request.operationalDataset = chip::JniByteArray(env, static_cast<jbyteArray>(operationalDataset)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, addWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jobject breadcrumb,
 jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::AddWiFiNetwork::Type request;

    request.ssid        = chip::JniByteArray(env, static_cast<jbyteArray>(ssid)).byteSpan();
    request.credentials = chip::JniByteArray(env, static_cast<jbyteArray>(credentials)).byteSpan();
    request.breadcrumb  = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs   = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, disableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jobject breadcrumb, jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::DisableNetwork::Type request;

    request.networkID  = chip::JniByteArray(env, static_cast<jbyteArray>(networkID)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterDisableNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterDisableNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, enableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jobject breadcrumb, jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::EnableNetwork::Type request;

    request.networkID  = chip::JniByteArray(env, static_cast<jbyteArray>(networkID)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterEnableNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterEnableNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, removeNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jobject breadcrumb, jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::RemoveNetwork::Type request;

    request.networkID  = chip::JniByteArray(env, static_cast<jbyteArray>(networkID)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, scanNetworks)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jobject breadcrumb, jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::ScanNetworks::Type request;

    request.ssid       = chip::JniByteArray(env, static_cast<jbyteArray>(ssid)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterScanNetworksResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterScanNetworksResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterScanNetworksResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterScanNetworksResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterScanNetworksResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, updateThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jobject breadcrumb,
 jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::UpdateThreadNetwork::Type request;

    request.operationalDataset = chip::JniByteArray(env, static_cast<jbyteArray>(operationalDataset)).byteSpan();
    request.breadcrumb = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs  = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallbackType>::FromCancelable(
            onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, updateWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jobject breadcrumb,
 jobject timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    chip::app::Clusters::NetworkCommissioning::Commands::UpdateWiFiNetwork::Type request;

    request.ssid        = chip::JniByteArray(env, static_cast<jbyteArray>(ssid)).byteSpan();
    request.credentials = chip::JniByteArray(env, static_cast<jbyteArray>(credentials)).byteSpan();
    request.breadcrumb  = static_cast<decltype(request.breadcrumb)>(chip::JniReferences::GetInstance().LongToPrimitive(breadcrumb));
    request.timeoutMs   = static_cast<decltype(request.timeoutMs)>(chip::JniReferences::GetInstance().LongToPrimitive(timeoutMs));

    std::unique_ptr<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, subscribeFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeFeatureMap(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, NetworkCommissioningCluster, reportFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeFeatureMap(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, NetworkCommissioningCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, NetworkCommissioningCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, OtaSoftwareUpdateProviderCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateProviderCluster * cppCluster = new OtaSoftwareUpdateProviderCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, applyUpdateRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray updateToken, jobject newVersion)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::ApplyUpdateRequest::Type request;

    request.updateToken = chip::JniByteArray(env, static_cast<jbyteArray>(updateToken)).byteSpan();
    request.newVersion  = static_cast<decltype(request.newVersion)>(chip::JniReferences::GetInstance().LongToPrimitive(newVersion));

    std::unique_ptr<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback,
                    void (*)(CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback *)>
        onSuccess(Platform::New<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>(callback),
                  Platform::Delete<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, notifyUpdateApplied)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray updateToken, jobject softwareVersion)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::NotifyUpdateApplied::Type request;

    request.updateToken = chip::JniByteArray(env, static_cast<jbyteArray>(updateToken)).byteSpan();
    request.softwareVersion =
        static_cast<decltype(request.softwareVersion)>(chip::JniReferences::GetInstance().LongToPrimitive(softwareVersion));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, queryImage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject vendorId, jobject productId, jobject softwareVersion,
 jobject protocolsSupported, jobject hardwareVersion, jobject location, jobject requestorCanConsent, jobject metadataForProvider)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::QueryImage::Type request;

    request.vendorId  = static_cast<decltype(request.vendorId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(vendorId));
    request.productId = static_cast<decltype(request.productId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(productId));
    request.softwareVersion =
        static_cast<decltype(request.softwareVersion)>(chip::JniReferences::GetInstance().LongToPrimitive(softwareVersion));
    request.protocolsSupported =
        chip::app::DataModel::List<const chip::app::Clusters::OtaSoftwareUpdateProvider::OTADownloadProtocol>();
    chip::JniReferences::GetInstance().GetOptionalValue(hardwareVersion, hardwareVersion);
    request.hardwareVersion = chip::Optional<uint16_t>(
        static_cast<decltype(request.hardwareVersion)>(chip::JniReferences::GetInstance().IntegerToPrimitive(hardwareVersion)));
    chip::JniReferences::GetInstance().GetOptionalValue(location, location);
    request.location = chip::Optional<chip::CharSpan>(chip::JniUtfString(env, static_cast<jstring>(location)).charSpan());
    chip::JniReferences::GetInstance().GetOptionalValue(requestorCanConsent, requestorCanConsent);
    request.requestorCanConsent = chip::Optional<bool>(static_cast<decltype(request.requestorCanConsent)>(
        chip::JniReferences::GetInstance().BooleanToPrimitive(requestorCanConsent)));
    chip::JniReferences::GetInstance().GetOptionalValue(metadataForProvider, metadataForProvider);
    request.metadataForProvider =
        chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(metadataForProvider)).byteSpan());

    std::unique_ptr<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback,
                    void (*)(CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback *)>
        onSuccess(Platform::New<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback>(callback),
                  Platform::Delete<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, OtaSoftwareUpdateRequestorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateRequestorCluster * cppCluster = new OtaSoftwareUpdateRequestorCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, announceOtaProvider)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject providerLocation, jobject vendorId,
 jobject announcementReason, jobject metadataForNode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster;

    chip::app::Clusters::OtaSoftwareUpdateRequestor::Commands::AnnounceOtaProvider::Type request;

    request.providerLocation =
        static_cast<decltype(request.providerLocation)>(chip::JniReferences::GetInstance().LongToPrimitive(providerLocation));
    request.vendorId = static_cast<decltype(request.vendorId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(vendorId));
    request.announcementReason = static_cast<decltype(request.announcementReason)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(announcementReason));
    chip::JniReferences::GetInstance().GetOptionalValue(metadataForNode, metadataForNode);
    request.metadataForNode =
        chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(metadataForNode)).byteSpan());

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, writeDefaultOtaProviderAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::OtaSoftwareUpdateRequestor::Attributes::DefaultOtaProvider::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniByteArray(env, static_cast<jbyteArray>(value)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, subscribeDefaultOtaProviderAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeDefaultOtaProvider(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, reportDefaultOtaProviderAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPOctetStringAttributeCallback, void (*)(CHIPOctetStringAttributeCallback *)> onReport(
        Platform::New<CHIPOctetStringAttributeCallback>(callback, true), Platform::Delete<CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeDefaultOtaProvider(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, subscribeUpdatePossibleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeUpdatePossible(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, reportUpdatePossibleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeUpdatePossible(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, OccupancySensingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OccupancySensingCluster * cppCluster = new OccupancySensingCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OccupancySensingCluster, subscribeOccupancyAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOccupancy(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OccupancySensingCluster, reportOccupancyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOccupancy(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OccupancySensingCluster, subscribeOccupancySensorTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOccupancySensorType(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OccupancySensingCluster, reportOccupancySensorTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOccupancySensorType(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OccupancySensingCluster, subscribeOccupancySensorTypeBitmapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOccupancySensorTypeBitmap(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OccupancySensingCluster, reportOccupancySensorTypeBitmapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOccupancySensorTypeBitmap(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OccupancySensingCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OccupancySensingCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, OnOffCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OnOffCluster * cppCluster = new OnOffCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffCluster, off)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::Off::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, offWithEffect)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject effectId, jobject effectVariant)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::OffWithEffect::Type request;

    request.effectId = static_cast<decltype(request.effectId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(effectId));
    request.effectVariant =
        static_cast<decltype(request.effectVariant)>(chip::JniReferences::GetInstance().IntegerToPrimitive(effectVariant));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, on)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::On::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, onWithRecallGlobalScene)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::OnWithRecallGlobalScene::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, onWithTimedOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject onOffControl, jobject onTime, jobject offWaitTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::OnWithTimedOff::Type request;

    request.onOffControl =
        static_cast<decltype(request.onOffControl)>(chip::JniReferences::GetInstance().IntegerToPrimitive(onOffControl));
    request.onTime = static_cast<decltype(request.onTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(onTime));
    request.offWaitTime =
        static_cast<decltype(request.offWaitTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(offWaitTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, toggle)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    chip::app::Clusters::OnOff::Commands::Toggle::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, subscribeOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOnOff(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, reportOnOffAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOnOff(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OnOffCluster, subscribeGlobalSceneControlAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeGlobalSceneControl(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, reportGlobalSceneControlAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeGlobalSceneControl(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, OnOffCluster, writeOnTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, subscribeOnTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOnTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, reportOnTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOnTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, OnOffCluster, writeOffWaitTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, subscribeOffWaitTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOffWaitTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, reportOffWaitTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOffWaitTime(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, OnOffCluster, writeStartUpOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffCluster, subscribeStartUpOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStartUpOnOff(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, reportStartUpOnOffAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStartUpOnOff(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OnOffCluster, subscribeFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeFeatureMap(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, reportFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeFeatureMap(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OnOffCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, OnOffSwitchConfigurationCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OnOffSwitchConfigurationCluster * cppCluster = new OnOffSwitchConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, subscribeSwitchTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSwitchType(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, reportSwitchTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSwitchType(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, writeSwitchActionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::OnOffSwitchConfiguration::Attributes::SwitchActions::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OnOffSwitchConfigurationCluster, subscribeSwitchActionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSwitchActions(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, reportSwitchActionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSwitchActions(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OnOffSwitchConfigurationCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, OperationalCredentialsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster = new OperationalCredentialsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OperationalCredentialsCluster, addNOC)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray NOCValue, jobject ICACValue, jbyteArray IPKValue,
 jobject caseAdminNode, jobject adminVendorId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::AddNOC::Type request;

    request.NOCValue = chip::JniByteArray(env, static_cast<jbyteArray>(NOCValue)).byteSpan();
    chip::JniReferences::GetInstance().GetOptionalValue(ICACValue, ICACValue);
    request.ICACValue = chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(ICACValue)).byteSpan());
    request.IPKValue  = chip::JniByteArray(env, static_cast<jbyteArray>(IPKValue)).byteSpan();
    request.caseAdminNode =
        static_cast<decltype(request.caseAdminNode)>(chip::JniReferences::GetInstance().LongToPrimitive(caseAdminNode));
    request.adminVendorId =
        static_cast<decltype(request.adminVendorId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(adminVendorId));

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, addTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray rootCertificate)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::AddTrustedRootCertificate::Type request;

    request.rootCertificate = chip::JniByteArray(env, static_cast<jbyteArray>(rootCertificate)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, attestationRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray attestationNonce)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::AttestationRequest::Type request;

    request.attestationNonce = chip::JniByteArray(env, static_cast<jbyteArray>(attestationNonce)).byteSpan();

    std::unique_ptr<CHIPOperationalCredentialsClusterAttestationResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterAttestationResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterAttestationResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterAttestationResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPOperationalCredentialsClusterAttestationResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, certificateChainRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject certificateType)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::CertificateChainRequest::Type request;

    request.certificateType =
        static_cast<decltype(request.certificateType)>(chip::JniReferences::GetInstance().IntegerToPrimitive(certificateType));

    std::unique_ptr<CHIPOperationalCredentialsClusterCertificateChainResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterCertificateChainResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterCertificateChainResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterCertificateChainResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterCertificateChainResponseCallbackType>::FromCancelable(
            onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, opCSRRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray CSRNonce)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::OpCSRRequest::Type request;

    request.CSRNonce = chip::JniByteArray(env, static_cast<jbyteArray>(CSRNonce)).byteSpan();

    std::unique_ptr<CHIPOperationalCredentialsClusterOpCSRResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterOpCSRResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterOpCSRResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterOpCSRResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterOpCSRResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, removeFabric)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject fabricIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::RemoveFabric::Type request;

    request.fabricIndex =
        static_cast<decltype(request.fabricIndex)>(chip::JniReferences::GetInstance().IntegerToPrimitive(fabricIndex));

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, removeTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray trustedRootIdentifier)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::RemoveTrustedRootCertificate::Type request;

    request.trustedRootIdentifier = chip::JniByteArray(env, static_cast<jbyteArray>(trustedRootIdentifier)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, updateFabricLabel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring label)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::UpdateFabricLabel::Type request;

    request.label = chip::JniUtfString(env, static_cast<jstring>(label)).charSpan();

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, updateNOC)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray NOCValue, jobject ICACValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    chip::app::Clusters::OperationalCredentials::Commands::UpdateNOC::Type request;

    request.NOCValue = chip::JniByteArray(env, static_cast<jbyteArray>(NOCValue)).byteSpan();
    chip::JniReferences::GetInstance().GetOptionalValue(ICACValue, ICACValue);
    request.ICACValue = chip::Optional<chip::ByteSpan>(chip::JniByteArray(env, static_cast<jbyteArray>(ICACValue)).byteSpan());

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, subscribeSupportedFabricsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSupportedFabrics(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OperationalCredentialsCluster, reportSupportedFabricsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSupportedFabrics(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, subscribeCommissionedFabricsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCommissionedFabrics(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OperationalCredentialsCluster, reportCommissionedFabricsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCommissionedFabrics(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, subscribeCurrentFabricIndexAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentFabricIndex(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OperationalCredentialsCluster, reportCurrentFabricIndexAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentFabricIndex(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, OperationalCredentialsCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OperationalCredentialsCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, PowerSourceCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PowerSourceCluster * cppCluster = new PowerSourceCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PowerSourceCluster, subscribeStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStatus(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PowerSourceCluster, reportStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PowerSourceCluster, subscribeOrderAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOrder(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PowerSourceCluster, reportOrderAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOrder(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PowerSourceCluster, subscribeDescriptionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeDescription(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PowerSourceCluster, reportDescriptionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeDescription(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PowerSourceCluster, subscribeBatteryVoltageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBatteryVoltage(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PowerSourceCluster, reportBatteryVoltageAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBatteryVoltage(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PowerSourceCluster, subscribeBatteryPercentRemainingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBatteryPercentRemaining(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PowerSourceCluster, reportBatteryPercentRemainingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBatteryPercentRemaining(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PowerSourceCluster, subscribeBatteryTimeRemainingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBatteryTimeRemaining(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PowerSourceCluster, reportBatteryTimeRemainingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBatteryTimeRemaining(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PowerSourceCluster, subscribeBatteryChargeLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBatteryChargeLevel(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PowerSourceCluster, reportBatteryChargeLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBatteryChargeLevel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PowerSourceCluster, subscribeBatteryChargeStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBatteryChargeState(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PowerSourceCluster, reportBatteryChargeStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBatteryChargeState(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PowerSourceCluster, subscribeFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeFeatureMap(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PowerSourceCluster, reportFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeFeatureMap(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PowerSourceCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PowerSourceCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    PowerSourceCluster * cppCluster = reinterpret_cast<PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, PowerSourceConfigurationCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PowerSourceConfigurationCluster * cppCluster = new PowerSourceConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, PressureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PressureMeasurementCluster * cppCluster = new PressureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PressureMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PressureMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PressureMeasurementCluster, subscribeMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PressureMeasurementCluster, reportMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PressureMeasurementCluster, subscribeMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PressureMeasurementCluster, reportMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PressureMeasurementCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PressureMeasurementCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, PumpConfigurationAndControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PumpConfigurationAndControlCluster * cppCluster = new PumpConfigurationAndControlCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMaxPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxPressure(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMaxPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxPressure(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMaxSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxSpeed(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMaxSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxSpeed(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMaxFlowAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxFlow(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMaxFlowAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxFlow(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMinConstPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinConstPressure(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMinConstPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinConstPressure(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMaxConstPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxConstPressure(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMaxConstPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxConstPressure(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMinCompPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinCompPressure(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMinCompPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinCompPressure(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMaxCompPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxCompPressure(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMaxCompPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxCompPressure(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMinConstSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinConstSpeed(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMinConstSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinConstSpeed(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMaxConstSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxConstSpeed(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMaxConstSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxConstSpeed(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMinConstFlowAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinConstFlow(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMinConstFlowAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinConstFlow(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMaxConstFlowAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxConstFlow(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMaxConstFlowAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxConstFlow(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMinConstTempAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinConstTemp(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMinConstTempAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinConstTemp(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeMaxConstTempAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxConstTemp(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportMaxConstTempAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxConstTemp(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribePumpStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePumpStatus(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportPumpStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePumpStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeEffectiveOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeEffectiveOperationMode(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportEffectiveOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeEffectiveOperationMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeEffectiveControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeEffectiveControlMode(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportEffectiveControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeEffectiveControlMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeCapacityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCapacity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportCapacityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCapacity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSpeed(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSpeed(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeLifetimeRunningHoursAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeRunningHours::TypeInfo;
    TypeInfo::Type cppValue;

    uint32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint32_t>() : chip::app::DataModel::Nullable<uint32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeLifetimeRunningHoursAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLifetimeRunningHours(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportLifetimeRunningHoursAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLifetimeRunningHours(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribePowerAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePower(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportPowerAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePower(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeLifetimeEnergyConsumedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo;
    TypeInfo::Type cppValue;

    uint32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint32_t>() : chip::app::DataModel::Nullable<uint32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeLifetimeEnergyConsumedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLifetimeEnergyConsumed(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportLifetimeEnergyConsumedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLifetimeEnergyConsumed(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOperationMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOperationMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeControlMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeControlMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeAlarmMaskAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeAlarmMask(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportAlarmMaskAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeAlarmMask(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeFeatureMap(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeFeatureMap(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, RelativeHumidityMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    RelativeHumidityMeasurementCluster * cppCluster = new RelativeHumidityMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTolerance(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTolerance(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ScenesCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster = new ScenesCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ScenesCluster, addScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jobject sceneId, jobject transitionTime,
 jstring sceneName, jobject clusterId, jobject length, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::AddScene::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.sceneId = static_cast<decltype(request.sceneId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(sceneId));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));
    request.sceneName = chip::JniUtfString(env, static_cast<jstring>(sceneName)).charSpan();
    request.extensionFieldSets =
        chip::app::DataModel::List<const chip::app::Clusters::Scenes::Structs::SceneExtensionFieldSet::Type>();

    std::unique_ptr<CHIPScenesClusterAddSceneResponseCallback, void (*)(CHIPScenesClusterAddSceneResponseCallback *)> onSuccess(
        Platform::New<CHIPScenesClusterAddSceneResponseCallback>(callback),
        Platform::Delete<CHIPScenesClusterAddSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPScenesClusterAddSceneResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, getSceneMembership)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::GetSceneMembership::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));

    std::unique_ptr<CHIPScenesClusterGetSceneMembershipResponseCallback,
                    void (*)(CHIPScenesClusterGetSceneMembershipResponseCallback *)>
        onSuccess(Platform::New<CHIPScenesClusterGetSceneMembershipResponseCallback>(callback),
                  Platform::Delete<CHIPScenesClusterGetSceneMembershipResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPScenesClusterGetSceneMembershipResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, recallScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jobject sceneId, jobject transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::RecallScene::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.sceneId = static_cast<decltype(request.sceneId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(sceneId));
    request.transitionTime =
        static_cast<decltype(request.transitionTime)>(chip::JniReferences::GetInstance().IntegerToPrimitive(transitionTime));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, removeAllScenes)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::RemoveAllScenes::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));

    std::unique_ptr<CHIPScenesClusterRemoveAllScenesResponseCallback, void (*)(CHIPScenesClusterRemoveAllScenesResponseCallback *)>
        onSuccess(Platform::New<CHIPScenesClusterRemoveAllScenesResponseCallback>(callback),
                  Platform::Delete<CHIPScenesClusterRemoveAllScenesResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPScenesClusterRemoveAllScenesResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, removeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jobject sceneId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::RemoveScene::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.sceneId = static_cast<decltype(request.sceneId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(sceneId));

    std::unique_ptr<CHIPScenesClusterRemoveSceneResponseCallback, void (*)(CHIPScenesClusterRemoveSceneResponseCallback *)>
        onSuccess(Platform::New<CHIPScenesClusterRemoveSceneResponseCallback>(callback),
                  Platform::Delete<CHIPScenesClusterRemoveSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPScenesClusterRemoveSceneResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, storeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jobject sceneId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::StoreScene::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.sceneId = static_cast<decltype(request.sceneId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(sceneId));

    std::unique_ptr<CHIPScenesClusterStoreSceneResponseCallback, void (*)(CHIPScenesClusterStoreSceneResponseCallback *)> onSuccess(
        Platform::New<CHIPScenesClusterStoreSceneResponseCallback>(callback),
        Platform::Delete<CHIPScenesClusterStoreSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPScenesClusterStoreSceneResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, viewScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject groupId, jobject sceneId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    chip::app::Clusters::Scenes::Commands::ViewScene::Type request;

    request.groupId = static_cast<decltype(request.groupId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(groupId));
    request.sceneId = static_cast<decltype(request.sceneId)>(chip::JniReferences::GetInstance().IntegerToPrimitive(sceneId));

    std::unique_ptr<CHIPScenesClusterViewSceneResponseCallback, void (*)(CHIPScenesClusterViewSceneResponseCallback *)> onSuccess(
        Platform::New<CHIPScenesClusterViewSceneResponseCallback>(callback),
        Platform::Delete<CHIPScenesClusterViewSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPScenesClusterViewSceneResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ScenesCluster, subscribeSceneCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSceneCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ScenesCluster, reportSceneCountAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSceneCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ScenesCluster, subscribeCurrentSceneAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentScene(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ScenesCluster, reportCurrentSceneAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentScene(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ScenesCluster, subscribeCurrentGroupAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentGroup(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ScenesCluster, reportCurrentGroupAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentGroup(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ScenesCluster, subscribeSceneValidAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSceneValid(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ScenesCluster, reportSceneValidAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSceneValid(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ScenesCluster, subscribeNameSupportAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNameSupport(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ScenesCluster, reportNameSupportAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNameSupport(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ScenesCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ScenesCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    ScenesCluster * cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, SoftwareDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    SoftwareDiagnosticsCluster * cppCluster = new SoftwareDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, resetWatermarks)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster;

    chip::app::Clusters::SoftwareDiagnostics::Commands::ResetWatermarks::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, SoftwareDiagnosticsCluster, subscribeCurrentHeapFreeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentHeapFree(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, reportCurrentHeapFreeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentHeapFree(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, SoftwareDiagnosticsCluster, subscribeCurrentHeapUsedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentHeapUsed(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, reportCurrentHeapUsedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentHeapUsed(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, SoftwareDiagnosticsCluster, subscribeCurrentHeapHighWatermarkAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentHeapHighWatermark(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, reportCurrentHeapHighWatermarkAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentHeapHighWatermark(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, SoftwareDiagnosticsCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, SwitchCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    SwitchCluster * cppCluster = new SwitchCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SwitchCluster, subscribeNumberOfPositionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNumberOfPositions(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SwitchCluster, reportNumberOfPositionsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNumberOfPositions(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, SwitchCluster, subscribeCurrentPositionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPosition(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SwitchCluster, reportCurrentPositionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPosition(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, SwitchCluster, subscribeMultiPressMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMultiPressMax(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SwitchCluster, reportMultiPressMaxAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMultiPressMax(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, SwitchCluster, subscribeFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeFeatureMap(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SwitchCluster, reportFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeFeatureMap(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, SwitchCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SwitchCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, TvChannelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TvChannelCluster * cppCluster = new TvChannelCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TvChannelCluster, changeChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring match)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    chip::app::Clusters::TvChannel::Commands::ChangeChannel::Type request;

    request.match = chip::JniUtfString(env, static_cast<jstring>(match)).charSpan();

    std::unique_ptr<CHIPTvChannelClusterChangeChannelResponseCallback,
                    void (*)(CHIPTvChannelClusterChangeChannelResponseCallback *)>
        onSuccess(Platform::New<CHIPTvChannelClusterChangeChannelResponseCallback>(callback),
                  Platform::Delete<CHIPTvChannelClusterChangeChannelResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTvChannelClusterChangeChannelResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TvChannelCluster, changeChannelByNumber)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject majorNumber, jobject minorNumber)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    chip::app::Clusters::TvChannel::Commands::ChangeChannelByNumber::Type request;

    request.majorNumber =
        static_cast<decltype(request.majorNumber)>(chip::JniReferences::GetInstance().IntegerToPrimitive(majorNumber));
    request.minorNumber =
        static_cast<decltype(request.minorNumber)>(chip::JniReferences::GetInstance().IntegerToPrimitive(minorNumber));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TvChannelCluster, skipChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject count)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    chip::app::Clusters::TvChannel::Commands::SkipChannel::Type request;

    request.count = static_cast<decltype(request.count)>(chip::JniReferences::GetInstance().IntegerToPrimitive(count));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TvChannelCluster, subscribeTvChannelLineupAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTvChannelLineup(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TvChannelCluster, reportTvChannelLineupAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPOctetStringAttributeCallback, void (*)(CHIPOctetStringAttributeCallback *)> onReport(
        Platform::New<CHIPOctetStringAttributeCallback>(callback, true), Platform::Delete<CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTvChannelLineup(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, TvChannelCluster, subscribeCurrentTvChannelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentTvChannel(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TvChannelCluster, reportCurrentTvChannelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPOctetStringAttributeCallback, void (*)(CHIPOctetStringAttributeCallback *)> onReport(
        Platform::New<CHIPOctetStringAttributeCallback>(callback, true), Platform::Delete<CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentTvChannel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, TvChannelCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TvChannelCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, TargetNavigatorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TargetNavigatorCluster * cppCluster = new TargetNavigatorCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TargetNavigatorCluster, navigateTarget)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject target, jstring data)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TargetNavigatorCluster * cppCluster;

    chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type request;

    request.target = static_cast<decltype(request.target)>(chip::JniReferences::GetInstance().IntegerToPrimitive(target));
    request.data   = chip::JniUtfString(env, static_cast<jstring>(data)).charSpan();

    std::unique_ptr<CHIPTargetNavigatorClusterNavigateTargetResponseCallback,
                    void (*)(CHIPTargetNavigatorClusterNavigateTargetResponseCallback *)>
        onSuccess(Platform::New<CHIPTargetNavigatorClusterNavigateTargetResponseCallback>(callback),
                  Platform::Delete<CHIPTargetNavigatorClusterNavigateTargetResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TargetNavigatorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTargetNavigatorClusterNavigateTargetResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TargetNavigatorCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    TargetNavigatorCluster * cppCluster = reinterpret_cast<TargetNavigatorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TargetNavigatorCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    TargetNavigatorCluster * cppCluster = reinterpret_cast<TargetNavigatorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, TemperatureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TemperatureMeasurementCluster * cppCluster = new TemperatureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TemperatureMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, TemperatureMeasurementCluster, subscribeMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, TemperatureMeasurementCluster, subscribeMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, TemperatureMeasurementCluster, subscribeToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTolerance(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTolerance(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, TemperatureMeasurementCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, TestClusterCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster = new TestClusterCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TestClusterCluster, simpleStructEchoRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject a, jobject b, jobject c, jbyteArray d, jstring e,
 jobject f, jobject g, jobject h)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::SimpleStructEchoRequest::Type request;

    request.arg1 = chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type();

    std::unique_ptr<CHIPTestClusterClusterSimpleStructResponseCallback,
                    void (*)(CHIPTestClusterClusterSimpleStructResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterSimpleStructResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterSimpleStructResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterSimpleStructResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, test)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::Test::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testAddArguments)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1, jobject arg2)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type request;

    request.arg1 = static_cast<decltype(request.arg1)>(chip::JniReferences::GetInstance().IntegerToPrimitive(arg1));
    request.arg2 = static_cast<decltype(request.arg2)>(chip::JniReferences::GetInstance().IntegerToPrimitive(arg2));

    std::unique_ptr<CHIPTestClusterClusterTestAddArgumentsResponseCallback,
                    void (*)(CHIPTestClusterClusterTestAddArgumentsResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestAddArgumentsResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestAddArgumentsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterTestAddArgumentsResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testEnumsRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1, jobject arg2)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type request;

    request.arg1 = static_cast<decltype(request.arg1)>(chip::JniReferences::GetInstance().IntegerToPrimitive(arg1));
    request.arg2 = static_cast<decltype(request.arg2)>(chip::JniReferences::GetInstance().IntegerToPrimitive(arg2));

    std::unique_ptr<CHIPTestClusterClusterTestEnumsResponseCallback, void (*)(CHIPTestClusterClusterTestEnumsResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestEnumsResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestEnumsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterTestEnumsResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testListInt8UArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type request;

    request.arg1 = chip::app::DataModel::List<const uint8_t>();

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testListInt8UReverseRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type request;

    request.arg1 = chip::app::DataModel::List<const uint8_t>();

    std::unique_ptr<CHIPTestClusterClusterTestListInt8UReverseResponseCallback,
                    void (*)(CHIPTestClusterClusterTestListInt8UReverseResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestListInt8UReverseResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestListInt8UReverseResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPTestClusterClusterTestListInt8UReverseResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testListNestedStructListArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject a, jobject b, jobject c, jobject d, jobject e,
 jbyteArray f, jobject g)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type request;

    request.arg1 = chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>();

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testListStructArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject a, jobject b, jobject c, jbyteArray d, jstring e,
 jobject f, jobject g, jobject h)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type request;

    request.arg1 = chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>();

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testNestedStructArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject a, jobject b, jobject c)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type request;

    request.arg1 = chip::app::Clusters::TestCluster::Structs::NestedStruct::Type();

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testNestedStructListArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject a, jobject b, jobject c, jobject d, jobject e,
 jbyteArray f, jobject g)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type request;

    request.arg1 = chip::app::Clusters::TestCluster::Structs::NestedStructList::Type();

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testNotHandled)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testNullableOptionalRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type request;

    chip::JniReferences::GetInstance().GetOptionalValue(arg1, arg1);
    uint8_t arg1Value;
    if (arg1 != nullptr)
    {
        arg1Value = chip::JniReferences::GetInstance().IntegerToPrimitive(arg1);
    }
    request.arg1 = chip::Optional<chip::app::DataModel::Nullable<uint8_t>>(
        arg1 == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(arg1Value));

    std::unique_ptr<CHIPTestClusterClusterTestNullableOptionalResponseCallback,
                    void (*)(CHIPTestClusterClusterTestNullableOptionalResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestNullableOptionalResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestNullableOptionalResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPTestClusterClusterTestNullableOptionalResponseCallbackType>::FromCancelable(
        onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testSimpleOptionalArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject arg1)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type request;

    chip::JniReferences::GetInstance().GetOptionalValue(arg1, arg1);
    request.arg1 =
        chip::Optional<bool>(static_cast<decltype(request.arg1)>(chip::JniReferences::GetInstance().BooleanToPrimitive(arg1)));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testSpecific)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestSpecific::Type request;

    std::unique_ptr<CHIPTestClusterClusterTestSpecificResponseCallback,
                    void (*)(CHIPTestClusterClusterTestSpecificResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestSpecificResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestSpecificResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterTestSpecificResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testStructArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject a, jobject b, jobject c, jbyteArray d, jstring e,
 jobject f, jobject g, jobject h)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type request;

    request.arg1 = chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type();

    std::unique_ptr<CHIPTestClusterClusterBooleanResponseCallback, void (*)(CHIPTestClusterClusterBooleanResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterBooleanResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterBooleanResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn =
        chip::Callback::Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, testUnknownCommand)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TestUnknownCommand::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, timedInvokeRequest)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall, 10000);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBoolean(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportBooleanAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBoolean(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBitmap8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportBitmap8Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBitmap8(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBitmap16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportBitmap16Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBitmap16(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBitmap32(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportBitmap32Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBitmap32(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBitmap64(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportBitmap64Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBitmap64(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt8u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt8uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt8u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt16u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt16uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt16u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt24uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int24u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt24uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt24u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt24uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt24u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt32u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt32uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt32u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt40uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int40u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt40uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt40u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt40uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt40u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt48uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int48u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt48uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt48u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt48uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt48u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt56uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int56u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt56uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt56u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt56uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt56u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt64u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt64uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt64u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt8s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt8sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8sAttributeCallback, void (*)(CHIPInt8sAttributeCallback *)> onReport(
        Platform::New<CHIPInt8sAttributeCallback>(callback, true), Platform::Delete<CHIPInt8sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt8s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt16s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt16sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt16s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt24sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int24s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt24sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt24s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt24sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32sAttributeCallback, void (*)(CHIPInt32sAttributeCallback *)> onReport(
        Platform::New<CHIPInt32sAttributeCallback>(callback, true), Platform::Delete<CHIPInt32sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt24s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt32s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt32sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32sAttributeCallback, void (*)(CHIPInt32sAttributeCallback *)> onReport(
        Platform::New<CHIPInt32sAttributeCallback>(callback, true), Platform::Delete<CHIPInt32sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt32s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt40sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int40s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt40sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt40s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt40sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64sAttributeCallback, void (*)(CHIPInt64sAttributeCallback *)> onReport(
        Platform::New<CHIPInt64sAttributeCallback>(callback, true), Platform::Delete<CHIPInt64sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt40s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt48sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int48s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt48sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt48s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt48sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64sAttributeCallback, void (*)(CHIPInt64sAttributeCallback *)> onReport(
        Platform::New<CHIPInt64sAttributeCallback>(callback, true), Platform::Delete<CHIPInt64sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt48s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt56sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int56s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt56sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt56s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt56sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64sAttributeCallback, void (*)(CHIPInt64sAttributeCallback *)> onReport(
        Platform::New<CHIPInt64sAttributeCallback>(callback, true), Platform::Delete<CHIPInt64sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt56s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInt64s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportInt64sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64sAttributeCallback, void (*)(CHIPInt64sAttributeCallback *)> onReport(
        Platform::New<CHIPInt64sAttributeCallback>(callback, true), Platform::Delete<CHIPInt64sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInt64s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeEnum8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportEnum8Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeEnum8(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeEnum16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportEnum16Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeEnum16(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeFloatSingleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().FloatToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeFloatSingleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeFloatSingle(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportFloatSingleAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPFloatAttributeCallback, void (*)(CHIPFloatAttributeCallback *)> onReport(
        Platform::New<CHIPFloatAttributeCallback>(callback, true), Platform::Delete<CHIPFloatAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeFloatSingle(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeFloatDoubleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().DoubleToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeFloatDoubleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeFloatDouble(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportFloatDoubleAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDoubleAttributeCallback, void (*)(CHIPDoubleAttributeCallback *)> onReport(
        Platform::New<CHIPDoubleAttributeCallback>(callback, true), Platform::Delete<CHIPDoubleAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeFloatDouble(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniByteArray(env, static_cast<jbyteArray>(value)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOctetString(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportOctetStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPOctetStringAttributeCallback, void (*)(CHIPOctetStringAttributeCallback *)> onReport(
        Platform::New<CHIPOctetStringAttributeCallback>(callback, true), Platform::Delete<CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOctetString(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeLongOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniByteArray(env, static_cast<jbyteArray>(value)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeLongOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLongOctetString(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportLongOctetStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPOctetStringAttributeCallback, void (*)(CHIPOctetStringAttributeCallback *)> onReport(
        Platform::New<CHIPOctetStringAttributeCallback>(callback, true), Platform::Delete<CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLongOctetString(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCharString(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportCharStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCharString(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeLongCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeLongCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLongCharString(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportLongCharStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLongCharString(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeEpochUsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeEpochUsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeEpochUs(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportEpochUsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeEpochUs(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeEpochSAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeEpochSAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeEpochS(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                               static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportEpochSAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeEpochS(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeVendorId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportVendorIdAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeVendorId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeRangeRestrictedInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeRangeRestrictedInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRangeRestrictedInt8u(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportRangeRestrictedInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRangeRestrictedInt8u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeRangeRestrictedInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeRangeRestrictedInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRangeRestrictedInt8s(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportRangeRestrictedInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8sAttributeCallback, void (*)(CHIPInt8sAttributeCallback *)> onReport(
        Platform::New<CHIPInt8sAttributeCallback>(callback, true), Platform::Delete<CHIPInt8sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRangeRestrictedInt8s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeRangeRestrictedInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeRangeRestrictedInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRangeRestrictedInt16u(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportRangeRestrictedInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRangeRestrictedInt16u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeRangeRestrictedInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeRangeRestrictedInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRangeRestrictedInt16s(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportRangeRestrictedInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRangeRestrictedInt16s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeTimedWriteBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::TimedWriteBoolean::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeUnsupportedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Unsupported::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeUnsupportedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeUnsupported(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportUnsupportedAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeUnsupported(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo;
    TypeInfo::Type cppValue;

    bool valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().BooleanToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<bool>() : chip::app::DataModel::Nullable<bool>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableBoolean(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableBooleanAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableBoolean(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableBitmap8(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableBitmap8Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableBitmap8(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableBitmap16(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableBitmap16(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo;
    TypeInfo::Type cppValue;

    uint32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint32_t>() : chip::app::DataModel::Nullable<uint32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableBitmap32(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableBitmap32(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo;
    TypeInfo::Type cppValue;

    uint64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint64_t>() : chip::app::DataModel::Nullable<uint64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableBitmap64(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableBitmap64(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt8u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt8uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt8u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt16u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt16uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt16u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt24uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt24u::TypeInfo;
    TypeInfo::Type cppValue;

    uint32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint32_t>() : chip::app::DataModel::Nullable<uint32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt24uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt24u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt24uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt24u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo;
    TypeInfo::Type cppValue;

    uint32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint32_t>() : chip::app::DataModel::Nullable<uint32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt32u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt32uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt32u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt40uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt40u::TypeInfo;
    TypeInfo::Type cppValue;

    uint64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint64_t>() : chip::app::DataModel::Nullable<uint64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt40uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt40u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt40uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt40u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt48uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt48u::TypeInfo;
    TypeInfo::Type cppValue;

    uint64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint64_t>() : chip::app::DataModel::Nullable<uint64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt48uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt48u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt48uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt48u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt56uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt56u::TypeInfo;
    TypeInfo::Type cppValue;

    uint64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint64_t>() : chip::app::DataModel::Nullable<uint64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt56uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt56u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt56uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt56u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo;
    TypeInfo::Type cppValue;

    uint64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint64_t>() : chip::app::DataModel::Nullable<uint64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt64u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt64uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt64u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo;
    TypeInfo::Type cppValue;

    int8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int8_t>() : chip::app::DataModel::Nullable<int8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt8s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt8sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8sAttributeCallback, void (*)(CHIPInt8sAttributeCallback *)> onReport(
        Platform::New<CHIPInt8sAttributeCallback>(callback, true), Platform::Delete<CHIPInt8sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt8s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo;
    TypeInfo::Type cppValue;

    int16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int16_t>() : chip::app::DataModel::Nullable<int16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt16s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt16sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt16s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt24sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt24s::TypeInfo;
    TypeInfo::Type cppValue;

    int32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int32_t>() : chip::app::DataModel::Nullable<int32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt24sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt24s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt24sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32sAttributeCallback, void (*)(CHIPInt32sAttributeCallback *)> onReport(
        Platform::New<CHIPInt32sAttributeCallback>(callback, true), Platform::Delete<CHIPInt32sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt24s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo;
    TypeInfo::Type cppValue;

    int32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int32_t>() : chip::app::DataModel::Nullable<int32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt32s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt32sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32sAttributeCallback, void (*)(CHIPInt32sAttributeCallback *)> onReport(
        Platform::New<CHIPInt32sAttributeCallback>(callback, true), Platform::Delete<CHIPInt32sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt32s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt40sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt40s::TypeInfo;
    TypeInfo::Type cppValue;

    int64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int64_t>() : chip::app::DataModel::Nullable<int64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt40sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt40s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt40sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64sAttributeCallback, void (*)(CHIPInt64sAttributeCallback *)> onReport(
        Platform::New<CHIPInt64sAttributeCallback>(callback, true), Platform::Delete<CHIPInt64sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt40s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt48sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt48s::TypeInfo;
    TypeInfo::Type cppValue;

    int64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int64_t>() : chip::app::DataModel::Nullable<int64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt48sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt48s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt48sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64sAttributeCallback, void (*)(CHIPInt64sAttributeCallback *)> onReport(
        Platform::New<CHIPInt64sAttributeCallback>(callback, true), Platform::Delete<CHIPInt64sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt48s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt56sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt56s::TypeInfo;
    TypeInfo::Type cppValue;

    int64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int64_t>() : chip::app::DataModel::Nullable<int64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt56sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt56s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt56sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64sAttributeCallback, void (*)(CHIPInt64sAttributeCallback *)> onReport(
        Platform::New<CHIPInt64sAttributeCallback>(callback, true), Platform::Delete<CHIPInt64sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt56s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo;
    TypeInfo::Type cppValue;

    int64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int64_t>() : chip::app::DataModel::Nullable<int64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableInt64s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableInt64sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64sAttributeCallback, void (*)(CHIPInt64sAttributeCallback *)> onReport(
        Platform::New<CHIPInt64sAttributeCallback>(callback, true), Platform::Delete<CHIPInt64sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableInt64s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo;
    TypeInfo::Type cppValue;

    decltype(cppValue) valueValue;
    if (value != nullptr)
    {
        valueValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableEnum8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableEnum8Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableEnum8(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo;
    TypeInfo::Type cppValue;

    decltype(cppValue) valueValue;
    if (value != nullptr)
    {
        valueValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableEnum16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableEnum16Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableEnum16(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableFloatSingleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo;
    TypeInfo::Type cppValue;

    float valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().FloatToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<float>() : chip::app::DataModel::Nullable<float>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableFloatSingleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableFloatSingle(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableFloatSingleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPFloatAttributeCallback, void (*)(CHIPFloatAttributeCallback *)> onReport(
        Platform::New<CHIPFloatAttributeCallback>(callback, true), Platform::Delete<CHIPFloatAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableFloatSingle(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableFloatDoubleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo;
    TypeInfo::Type cppValue;

    double valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().DoubleToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<double>() : chip::app::DataModel::Nullable<double>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableFloatDoubleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableFloatDouble(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableFloatDoubleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDoubleAttributeCallback, void (*)(CHIPDoubleAttributeCallback *)> onReport(
        Platform::New<CHIPDoubleAttributeCallback>(callback, true), Platform::Delete<CHIPDoubleAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableFloatDouble(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo;
    TypeInfo::Type cppValue;

    chip::ByteSpan valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniByteArray(env, static_cast<jbyteArray>(value)).byteSpan();
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<chip::ByteSpan>()
                                : chip::app::DataModel::Nullable<chip::ByteSpan>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableOctetString(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPOctetStringAttributeCallback, void (*)(CHIPOctetStringAttributeCallback *)> onReport(
        Platform::New<CHIPOctetStringAttributeCallback>(callback, true), Platform::Delete<CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableOctetString(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo;
    TypeInfo::Type cppValue;

    chip::CharSpan valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<chip::CharSpan>()
                                : chip::app::DataModel::Nullable<chip::CharSpan>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableCharString(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableCharString(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableRangeRestrictedInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableRangeRestrictedInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableRangeRestrictedInt8u(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableRangeRestrictedInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableRangeRestrictedInt8u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableRangeRestrictedInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo;
    TypeInfo::Type cppValue;

    int8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int8_t>() : chip::app::DataModel::Nullable<int8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableRangeRestrictedInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableRangeRestrictedInt8s(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableRangeRestrictedInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8sAttributeCallback, void (*)(CHIPInt8sAttributeCallback *)> onReport(
        Platform::New<CHIPInt8sAttributeCallback>(callback, true), Platform::Delete<CHIPInt8sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableRangeRestrictedInt8s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableRangeRestrictedInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableRangeRestrictedInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableRangeRestrictedInt16u(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableRangeRestrictedInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableRangeRestrictedInt16u(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableRangeRestrictedInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo;
    TypeInfo::Type cppValue;

    int16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int16_t>() : chip::app::DataModel::Nullable<int16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeNullableRangeRestrictedInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNullableRangeRestrictedInt16s(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportNullableRangeRestrictedInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNullableRangeRestrictedInt16s(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, TestClusterCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ThermostatCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatCluster * cppCluster = new ThermostatCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatCluster, clearWeeklySchedule)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    chip::app::Clusters::Thermostat::Commands::ClearWeeklySchedule::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, getRelayStatusLog)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    chip::app::Clusters::Thermostat::Commands::GetRelayStatusLog::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, getWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject daysToReturn, jobject modeToReturn)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    chip::app::Clusters::Thermostat::Commands::GetWeeklySchedule::Type request;

    request.daysToReturn =
        static_cast<decltype(request.daysToReturn)>(chip::JniReferences::GetInstance().IntegerToPrimitive(daysToReturn));
    request.modeToReturn =
        static_cast<decltype(request.modeToReturn)>(chip::JniReferences::GetInstance().IntegerToPrimitive(modeToReturn));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, setWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject numberOfTransitionsForSequence,
 jobject dayOfWeekForSequence, jobject modeForSequence, jobject payload)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    chip::app::Clusters::Thermostat::Commands::SetWeeklySchedule::Type request;

    request.numberOfTransitionsForSequence = static_cast<decltype(request.numberOfTransitionsForSequence)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(numberOfTransitionsForSequence));
    request.dayOfWeekForSequence = static_cast<decltype(request.dayOfWeekForSequence)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(dayOfWeekForSequence));
    request.modeForSequence =
        static_cast<decltype(request.modeForSequence)>(chip::JniReferences::GetInstance().IntegerToPrimitive(modeForSequence));
    request.payload = chip::app::DataModel::List<const uint8_t>();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, setpointRaiseLower)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject mode, jobject amount)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    chip::app::Clusters::Thermostat::Commands::SetpointRaiseLower::Type request;

    request.mode   = static_cast<decltype(request.mode)>(chip::JniReferences::GetInstance().IntegerToPrimitive(mode));
    request.amount = static_cast<decltype(request.amount)>(chip::JniReferences::GetInstance().IntegerToPrimitive(amount));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeLocalTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLocalTemperature(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportLocalTemperatureAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLocalTemperature(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeAbsMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeAbsMinHeatSetpointLimit(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportAbsMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeAbsMinHeatSetpointLimit(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeAbsMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeAbsMaxHeatSetpointLimit(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportAbsMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeAbsMaxHeatSetpointLimit(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeAbsMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeAbsMinCoolSetpointLimit(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportAbsMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeAbsMinCoolSetpointLimit(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeAbsMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeAbsMaxCoolSetpointLimit(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportAbsMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeAbsMaxCoolSetpointLimit(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedCoolingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeOccupiedCoolingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOccupiedCoolingSetpoint(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportOccupiedCoolingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOccupiedCoolingSetpoint(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedHeatingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeOccupiedHeatingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOccupiedHeatingSetpoint(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportOccupiedHeatingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOccupiedHeatingSetpoint(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinHeatSetpointLimit(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinHeatSetpointLimit(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxHeatSetpointLimit(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxHeatSetpointLimit(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinCoolSetpointLimit(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinCoolSetpointLimit(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMaxCoolSetpointLimit(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMaxCoolSetpointLimit(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinSetpointDeadBandAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeMinSetpointDeadBandAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMinSetpointDeadBand(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportMinSetpointDeadBandAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8sAttributeCallback, void (*)(CHIPInt8sAttributeCallback *)> onReport(
        Platform::New<CHIPInt8sAttributeCallback>(callback, true), Platform::Delete<CHIPInt8sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMinSetpointDeadBand(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeControlSequenceOfOperationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeControlSequenceOfOperationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeControlSequenceOfOperation(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportControlSequenceOfOperationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeControlSequenceOfOperation(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeSystemModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeSystemModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSystemMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportSystemModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSystemMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeStartOfWeekAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStartOfWeek(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportStartOfWeekAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStartOfWeek(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeNumberOfWeeklyTransitionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNumberOfWeeklyTransitions(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportNumberOfWeeklyTransitionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNumberOfWeeklyTransitions(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeNumberOfDailyTransitionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNumberOfDailyTransitions(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportNumberOfDailyTransitionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNumberOfDailyTransitions(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeFeatureMap(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeFeatureMap(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThermostatCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ThermostatUserInterfaceConfigurationCluster, initWithDevice)
(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatUserInterfaceConfigurationCluster * cppCluster = new ThermostatUserInterfaceConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeTemperatureDisplayModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, subscribeTemperatureDisplayModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTemperatureDisplayMode(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, reportTemperatureDisplayModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTemperatureDisplayMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeKeypadLockoutAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, subscribeKeypadLockoutAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeKeypadLockout(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, reportKeypadLockoutAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeKeypadLockout(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeScheduleProgrammingVisibilityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, subscribeScheduleProgrammingVisibilityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeScheduleProgrammingVisibility(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, reportScheduleProgrammingVisibilityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeScheduleProgrammingVisibility(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ThreadNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThreadNetworkDiagnosticsCluster * cppCluster = new ThreadNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster;

    chip::app::Clusters::ThreadNetworkDiagnostics::Commands::ResetCounts::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeChannelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeChannel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportChannelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeChannel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRoutingRoleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRoutingRole(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRoutingRoleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRoutingRole(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeNetworkNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeNetworkName(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportNetworkNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPOctetStringAttributeCallback, void (*)(CHIPOctetStringAttributeCallback *)> onReport(
        Platform::New<CHIPOctetStringAttributeCallback>(callback, true), Platform::Delete<CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeNetworkName(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribePanIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePanId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportPanIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePanId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeExtendedPanIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeExtendedPanId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportExtendedPanIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeExtendedPanId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeMeshLocalPrefixAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeshLocalPrefix(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportMeshLocalPrefixAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPOctetStringAttributeCallback, void (*)(CHIPOctetStringAttributeCallback *)> onReport(
        Platform::New<CHIPOctetStringAttributeCallback>(callback, true), Platform::Delete<CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeshLocalPrefix(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOverrunCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOverrunCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribePartitionIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePartitionId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportPartitionIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePartitionId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeWeightingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeWeighting(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportWeightingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeWeighting(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeDataVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeDataVersion(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportDataVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeDataVersion(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeStableDataVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStableDataVersion(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportStableDataVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStableDataVersion(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeLeaderRouterIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLeaderRouterId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportLeaderRouterIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLeaderRouterId(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeDetachedRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeDetachedRoleCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportDetachedRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeDetachedRoleCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeChildRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeChildRoleCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportChildRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeChildRoleCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRouterRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRouterRoleCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRouterRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRouterRoleCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeLeaderRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLeaderRoleCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportLeaderRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLeaderRoleCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeAttachAttemptCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeAttachAttemptCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                           static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportAttachAttemptCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeAttachAttemptCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribePartitionIdChangeCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePartitionIdChangeCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportPartitionIdChangeCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePartitionIdChangeCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeBetterPartitionAttachAttemptCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBetterPartitionAttachAttemptCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportBetterPartitionAttachAttemptCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBetterPartitionAttachAttemptCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeParentChangeCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeParentChangeCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportParentChangeCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeParentChangeCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxTotalCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxTotalCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxTotalCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxTotalCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxUnicastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxUnicastCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxUnicastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxUnicastCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxBroadcastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxBroadcastCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxBroadcastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxBroadcastCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxAckRequestedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxAckRequestedCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxAckRequestedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxAckRequestedCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxAckedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxAckedCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxAckedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxAckedCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxNoAckRequestedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxNoAckRequestedCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxNoAckRequestedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxNoAckRequestedCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxDataCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxDataCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxDataCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxDataCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxDataPollCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxDataPollCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxDataPollCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxDataPollCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxBeaconCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxBeaconCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxBeaconCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxBeaconCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxBeaconRequestCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxBeaconRequestCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxBeaconRequestCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxBeaconRequestCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxOtherCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxOtherCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxRetryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxRetryCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxRetryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxRetryCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxDirectMaxRetryExpiryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxDirectMaxRetryExpiryCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxDirectMaxRetryExpiryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxDirectMaxRetryExpiryCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxIndirectMaxRetryExpiryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxIndirectMaxRetryExpiryCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxIndirectMaxRetryExpiryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxIndirectMaxRetryExpiryCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxErrCcaCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxErrCcaCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxErrCcaCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxErrCcaCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxErrAbortCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxErrAbortCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxErrAbortCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxErrAbortCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeTxErrBusyChannelCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTxErrBusyChannelCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportTxErrBusyChannelCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTxErrBusyChannelCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxTotalCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxTotalCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxTotalCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxTotalCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxUnicastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxUnicastCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxUnicastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxUnicastCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxBroadcastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxBroadcastCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxBroadcastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxBroadcastCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxDataCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxDataCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxDataCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxDataCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxDataPollCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxDataPollCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxDataPollCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxDataPollCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxBeaconCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxBeaconCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxBeaconCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxBeaconCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxBeaconRequestCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxBeaconRequestCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxBeaconRequestCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxBeaconRequestCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxOtherCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxOtherCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxAddressFilteredCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxAddressFilteredCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxAddressFilteredCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxAddressFilteredCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxDestAddrFilteredCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxDestAddrFilteredCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxDestAddrFilteredCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxDestAddrFilteredCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxDuplicatedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxDuplicatedCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxDuplicatedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxDuplicatedCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxErrNoFrameCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxErrNoFrameCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxErrNoFrameCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxErrNoFrameCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxErrUnknownNeighborCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxErrUnknownNeighborCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxErrUnknownNeighborCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxErrUnknownNeighborCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxErrInvalidSrcAddrCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxErrInvalidSrcAddrCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxErrInvalidSrcAddrCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxErrInvalidSrcAddrCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxErrSecCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxErrSecCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxErrSecCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxErrSecCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxErrFcsCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxErrFcsCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxErrFcsCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxErrFcsCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeRxErrOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRxErrOtherCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportRxErrOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRxErrOtherCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeActiveTimestampAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeActiveTimestamp(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportActiveTimestampAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeActiveTimestamp(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribePendingTimestampAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePendingTimestamp(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportPendingTimestampAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePendingTimestamp(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeDelayAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeDelay(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportDelayAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeDelay(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeChannelMaskAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeChannelMask(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportChannelMaskAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPOctetStringAttributeCallback, void (*)(CHIPOctetStringAttributeCallback *)> onReport(
        Platform::New<CHIPOctetStringAttributeCallback>(callback, true), Platform::Delete<CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeChannelMask(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, WakeOnLanCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WakeOnLanCluster * cppCluster = new WakeOnLanCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WakeOnLanCluster, subscribeWakeOnLanMacAddressAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                = CHIP_NO_ERROR;
    WakeOnLanCluster * cppCluster = reinterpret_cast<WakeOnLanCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeWakeOnLanMacAddress(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WakeOnLanCluster, reportWakeOnLanMacAddressAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPCharStringAttributeCallback, void (*)(CHIPCharStringAttributeCallback *)> onReport(
        Platform::New<CHIPCharStringAttributeCallback>(callback, true), Platform::Delete<CHIPCharStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                = CHIP_NO_ERROR;
    WakeOnLanCluster * cppCluster = reinterpret_cast<WakeOnLanCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeWakeOnLanMacAddress(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WakeOnLanCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                = CHIP_NO_ERROR;
    WakeOnLanCluster * cppCluster = reinterpret_cast<WakeOnLanCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WakeOnLanCluster, reportClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                = CHIP_NO_ERROR;
    WakeOnLanCluster * cppCluster = reinterpret_cast<WakeOnLanCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, WiFiNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WiFiNetworkDiagnosticsCluster * cppCluster = new WiFiNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster;

    chip::app::Clusters::WiFiNetworkDiagnostics::Commands::ResetCounts::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribeBssidAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBssid(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportBssidAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPOctetStringAttributeCallback, void (*)(CHIPOctetStringAttributeCallback *)> onReport(
        Platform::New<CHIPOctetStringAttributeCallback>(callback, true), Platform::Delete<CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBssid(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribeSecurityTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSecurityType(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportSecurityTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSecurityType(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribeWiFiVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeWiFiVersion(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportWiFiVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeWiFiVersion(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribeChannelNumberAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeChannelNumber(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportChannelNumberAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeChannelNumber(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribeRssiAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeRssi(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                             static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportRssiAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8sAttributeCallback, void (*)(CHIPInt8sAttributeCallback *)> onReport(
        Platform::New<CHIPInt8sAttributeCallback>(callback, true), Platform::Delete<CHIPInt8sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeRssi(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribeBeaconLostCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBeaconLostCount(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportBeaconLostCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBeaconLostCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribeBeaconRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeBeaconRxCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportBeaconRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeBeaconRxCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribePacketMulticastRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePacketMulticastRxCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportPacketMulticastRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePacketMulticastRxCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribePacketMulticastTxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePacketMulticastTxCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportPacketMulticastTxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePacketMulticastTxCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribePacketUnicastRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePacketUnicastRxCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportPacketUnicastRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePacketUnicastRxCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribePacketUnicastTxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePacketUnicastTxCount(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportPacketUnicastTxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePacketUnicastTxCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribeCurrentMaxRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentMaxRate(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportCurrentMaxRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentMaxRate(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribeOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOverrunCount(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt64uAttributeCallback, void (*)(CHIPInt64uAttributeCallback *)> onReport(
        Platform::New<CHIPInt64uAttributeCallback>(callback, true), Platform::Delete<CHIPInt64uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOverrunCount(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, WindowCoveringCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster = new WindowCoveringCluster();

    cppCluster->Associate(reinterpret_cast<DeviceProxy *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WindowCoveringCluster, downOrClose)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToLiftPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject liftPercentageValue, jobject liftPercent100thsValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type request;

    request.liftPercentageValue = static_cast<decltype(request.liftPercentageValue)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(liftPercentageValue));
    request.liftPercent100thsValue = static_cast<decltype(request.liftPercent100thsValue)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(liftPercent100thsValue));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToLiftValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject liftValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::GoToLiftValue::Type request;

    request.liftValue = static_cast<decltype(request.liftValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(liftValue));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToTiltPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject tiltPercentageValue, jobject tiltPercent100thsValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type request;

    request.tiltPercentageValue = static_cast<decltype(request.tiltPercentageValue)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(tiltPercentageValue));
    request.tiltPercent100thsValue = static_cast<decltype(request.tiltPercent100thsValue)>(
        chip::JniReferences::GetInstance().IntegerToPrimitive(tiltPercent100thsValue));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, goToTiltValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject tiltValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::GoToTiltValue::Type request;

    request.tiltValue = static_cast<decltype(request.tiltValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(tiltValue));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, stopMotion)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::StopMotion::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, upOrOpen)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type request;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));
    VerifyOrReturn(onFailure.get() != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error getting native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->InvokeCommand(request, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error invoking command",
                                                                                       CHIP_ERROR_INCORRECT_STATE));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeType(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                             static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportTypeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeType(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionLift(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionLift(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionTilt(onSuccess->Cancel(), onFailure->Cancel(),
                                                            static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionTilt(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeConfigStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeConfigStatus(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportConfigStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeConfigStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionLiftPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionLiftPercentage(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionLiftPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionLiftPercentage(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionTiltPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionTiltPercentage(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionTiltPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionTiltPercentage(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeOperationalStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOperationalStatus(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportOperationalStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOperationalStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeTargetPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTargetPositionLiftPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportTargetPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTargetPositionLiftPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeTargetPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTargetPositionTiltPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportTargetPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTargetPositionTiltPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeEndProductTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeEndProductType(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                       static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportEndProductTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeEndProductType(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionLiftPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionLiftPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionTiltPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionTiltPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeInstalledOpenLimitLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInstalledOpenLimitLift(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportInstalledOpenLimitLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInstalledOpenLimitLift(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeInstalledClosedLimitLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInstalledClosedLimitLift(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportInstalledClosedLimitLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInstalledClosedLimitLift(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeInstalledOpenLimitTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInstalledOpenLimitTilt(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportInstalledOpenLimitTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInstalledOpenLimitTilt(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeInstalledClosedLimitTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeInstalledClosedLimitTilt(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportInstalledClosedLimitTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeInstalledClosedLimitTilt(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, writeModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());
    err            = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                             static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeSafetyStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSafetyStatus(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportSafetyStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSafetyStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeFeatureMap(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt32uAttributeCallback, void (*)(CHIPInt32uAttributeCallback *)> onReport(
        Platform::New<CHIPInt32uAttributeCallback>(callback, true), Platform::Delete<CHIPInt32uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeFeatureMap(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(void, WindowCoveringCluster, subscribeClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeClusterRevision(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeClusterRevision(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
