/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#include "CHIPCallbackTypes.h"
#include "CHIPInvokeCallbacks.h"
#include "CHIPReadCallbacks.h"

#include <app-common/zap-generated/cluster-objects.h>
#include <zap-generated/CHIPClientCallbacks.h>
#include <zap-generated/CHIPClusters.h>

#include <controller/java/AndroidCallbacks.h>
#include <controller/java/AndroidClusterExceptions.h>
#include <controller/java/CHIPDefaultCallbacks.h>
#include <jni.h>
#include <lib/support/CodeUtils.h>
#include <lib/support/JniReferences.h>
#include <lib/support/JniTypeWrappers.h>
#include <lib/support/Span.h>
#include <platform/PlatformManager.h>

#define JNI_METHOD(RETURN, CLASS_NAME, METHOD_NAME)                                                                                \
    extern "C" JNIEXPORT RETURN JNICALL Java_chip_devicecontroller_ChipClusters_00024##CLASS_NAME##_##METHOD_NAME

using namespace chip;
using namespace chip::Controller;

JNI_METHOD(void, BasicCluster, writeNodeLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Basic::Attributes::NodeLabel::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, writeLocationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Basic::Attributes::Location::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, writeLocalConfigDisabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Basic::Attributes::LocalConfigDisabled::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, writeOutOfServiceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, writePresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorControlOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointRIntensity::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointGIntensity::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::ColorPointBIntensity::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeStartUpColorTemperatureMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ContentLauncherCluster, writeSupportedStreamingProtocolsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                      = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, writeLanguageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::DoorLock::Attributes::Language::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, writeAutoRelockTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::DoorLock::Attributes::AutoRelockTime::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, writeSoundVolumeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::DoorLock::Attributes::SoundVolume::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, writeOperatingModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::DoorLock::Attributes::OperatingMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, writeEnableOneTouchLockingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::DoorLock::Attributes::EnableOneTouchLocking::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, writeEnablePrivacyModeButtonAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::DoorLock::Attributes::EnablePrivacyModeButton::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, writeWrongCodeEntryLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::DoorLock::Attributes::WrongCodeEntryLimit::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralCommissioningCluster, writeBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::GeneralCommissioning::Attributes::Breadcrumb::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IdentifyCluster, writeIdentifyTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Identify::Attributes::IdentifyTime::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeDefaultMoveRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeStartUpCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LocalizationConfigurationCluster, writeActiveLocaleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::LocalizationConfiguration::Attributes::ActiveLocale::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                = CHIP_NO_ERROR;
    LocalizationConfigurationCluster * cppCluster = reinterpret_cast<LocalizationConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ModeSelectCluster, writeOnModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ModeSelect::Attributes::OnMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, NetworkCommissioningCluster, writeInterfaceEnabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::NetworkCommissioning::Attributes::InterfaceEnabled::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, writeOnTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, writeOffWaitTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, writeStartUpOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, writeSwitchActionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::OnOffSwitchConfiguration::Attributes::SwitchActions::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeLifetimeRunningHoursAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeRunningHours::TypeInfo;
    TypeInfo::Type cppValue;

    uint32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint32_t>() : chip::app::DataModel::Nullable<uint32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeLifetimeEnergyConsumedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo;
    TypeInfo::Type cppValue;

    uint32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint32_t>() : chip::app::DataModel::Nullable<uint32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt24uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int24u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt40uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int40u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt48uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int48u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt56uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int56u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt24sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int24s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt40sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int40s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt48sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int48s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt56sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int56s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeFloatSingleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().FloatToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeFloatDoubleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().DoubleToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniByteArray(env, static_cast<jbyteArray>(value)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeLongOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniByteArray(env, static_cast<jbyteArray>(value)).byteSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeLongCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEpochUsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEpochSAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnumAttrAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::EnumAttr::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeRangeRestrictedInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeRangeRestrictedInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeRangeRestrictedInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeRangeRestrictedInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeTimedWriteBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::TimedWriteBoolean::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                               chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeUnsupportedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::Unsupported::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo;
    TypeInfo::Type cppValue;

    bool valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().BooleanToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<bool>() : chip::app::DataModel::Nullable<bool>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo;
    TypeInfo::Type cppValue;

    uint32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint32_t>() : chip::app::DataModel::Nullable<uint32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo;
    TypeInfo::Type cppValue;

    uint64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint64_t>() : chip::app::DataModel::Nullable<uint64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt24uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt24u::TypeInfo;
    TypeInfo::Type cppValue;

    uint32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint32_t>() : chip::app::DataModel::Nullable<uint32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo;
    TypeInfo::Type cppValue;

    uint32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint32_t>() : chip::app::DataModel::Nullable<uint32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt40uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt40u::TypeInfo;
    TypeInfo::Type cppValue;

    uint64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint64_t>() : chip::app::DataModel::Nullable<uint64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt48uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt48u::TypeInfo;
    TypeInfo::Type cppValue;

    uint64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint64_t>() : chip::app::DataModel::Nullable<uint64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt56uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt56u::TypeInfo;
    TypeInfo::Type cppValue;

    uint64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint64_t>() : chip::app::DataModel::Nullable<uint64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo;
    TypeInfo::Type cppValue;

    uint64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint64_t>() : chip::app::DataModel::Nullable<uint64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo;
    TypeInfo::Type cppValue;

    int8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int8_t>() : chip::app::DataModel::Nullable<int8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo;
    TypeInfo::Type cppValue;

    int16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int16_t>() : chip::app::DataModel::Nullable<int16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt24sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt24s::TypeInfo;
    TypeInfo::Type cppValue;

    int32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int32_t>() : chip::app::DataModel::Nullable<int32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo;
    TypeInfo::Type cppValue;

    int32_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int32_t>() : chip::app::DataModel::Nullable<int32_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt40sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt40s::TypeInfo;
    TypeInfo::Type cppValue;

    int64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int64_t>() : chip::app::DataModel::Nullable<int64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt48sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt48s::TypeInfo;
    TypeInfo::Type cppValue;

    int64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int64_t>() : chip::app::DataModel::Nullable<int64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt56sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt56s::TypeInfo;
    TypeInfo::Type cppValue;

    int64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int64_t>() : chip::app::DataModel::Nullable<int64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo;
    TypeInfo::Type cppValue;

    int64_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().LongToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int64_t>() : chip::app::DataModel::Nullable<int64_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableFloatSingleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo;
    TypeInfo::Type cppValue;

    float valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().FloatToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<float>() : chip::app::DataModel::Nullable<float>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableFloatDoubleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo;
    TypeInfo::Type cppValue;

    double valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().DoubleToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<double>() : chip::app::DataModel::Nullable<double>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo;
    TypeInfo::Type cppValue;

    chip::ByteSpan valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniByteArray(env, static_cast<jbyteArray>(value)).byteSpan();
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<chip::ByteSpan>()
                                : chip::app::DataModel::Nullable<chip::ByteSpan>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo;
    TypeInfo::Type cppValue;

    chip::CharSpan valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniUtfString(env, static_cast<jstring>(value)).charSpan();
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<chip::CharSpan>()
                                : chip::app::DataModel::Nullable<chip::CharSpan>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableEnumAttrAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableEnumAttr::TypeInfo;
    TypeInfo::Type cppValue;

    decltype(cppValue)::UnderlyingType valueValue;
    if (value != nullptr)
    {
        valueValue = static_cast<decltype(valueValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum>()
                                : chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableRangeRestrictedInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo;
    TypeInfo::Type cppValue;

    uint8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint8_t>() : chip::app::DataModel::Nullable<uint8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableRangeRestrictedInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo;
    TypeInfo::Type cppValue;

    int8_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int8_t>() : chip::app::DataModel::Nullable<int8_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableRangeRestrictedInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo;
    TypeInfo::Type cppValue;

    uint16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<uint16_t>() : chip::app::DataModel::Nullable<uint16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeNullableRangeRestrictedInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo;
    TypeInfo::Type cppValue;

    int16_t valueValue;
    if (value != nullptr)
    {
        valueValue = chip::JniReferences::GetInstance().IntegerToPrimitive(value);
    }
    cppValue = value == nullptr ? chip::app::DataModel::Nullable<int16_t>() : chip::app::DataModel::Nullable<int16_t>(valueValue);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedCoolingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedHeatingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinSetpointDeadBandAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeControlSequenceOfOperationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeSystemModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeTemperatureDisplayModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeKeypadLockoutAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeScheduleProgrammingVisibilityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, writeModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    using TypeInfo = chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo;
    TypeInfo::Type cppValue;

    cppValue = static_cast<decltype(cppValue)>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
