/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#include "CHIPReadCallbacks.h"

#include <app-common/zap-generated/cluster-objects.h>
#include <zap-generated/CHIPClusters.h>

#include <controller/java/AndroidClusterExceptions.h>
#include <controller/java/CHIPDefaultCallbacks.h>
#include <jni.h>
#include <lib/support/CodeUtils.h>
#include <platform/PlatformManager.h>

#define JNI_METHOD(RETURN, CLASS_NAME, METHOD_NAME)                                                                                \
    extern "C" JNIEXPORT RETURN JNICALL Java_chip_devicecontroller_ChipClusters_00024##CLASS_NAME##_##METHOD_NAME

JNI_METHOD(void, AccountLoginCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::AccountLoginCluster * cppCluster = reinterpret_cast<chip::Controller::AccountLoginCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, AdministratorCommissioningCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::AdministratorCommissioningCluster * cppCluster =
        reinterpret_cast<chip::Controller::AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationBasicCluster, readVendorNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeVendorName(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationBasicCluster, readVendorIdAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeVendorId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationBasicCluster, readApplicationNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeApplicationName(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationBasicCluster, readProductIdAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeProductId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationBasicCluster, readApplicationIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeApplicationId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationBasicCluster, readCatalogVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCatalogVendorId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationBasicCluster, readApplicationStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeApplicationStatus(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationBasicCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationLauncherCluster, readApplicationLauncherListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationLauncherCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeApplicationLauncherList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPApplicationLauncherApplicationLauncherListAttributeCallback,
                    void (*)(chip::CHIPApplicationLauncherApplicationLauncherListAttributeCallback *)>
        readCallback(
            chip::Platform::New<chip::CHIPApplicationLauncherApplicationLauncherListAttributeCallback>(callback, actionBlock),
            chip::Platform::Delete<chip::CHIPApplicationLauncherApplicationLauncherListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationLauncherCluster, readCatalogVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationLauncherCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCatalogVendorId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationLauncherCluster, readApplicationIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationLauncherCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeApplicationId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ApplicationLauncherCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ApplicationLauncherCluster * cppCluster =
        reinterpret_cast<chip::Controller::ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, AudioOutputCluster, readAudioOutputListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::AudioOutputCluster * cppCluster = reinterpret_cast<chip::Controller::AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeAudioOutputList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPAudioOutputAudioOutputListAttributeCallback,
                    void (*)(chip::CHIPAudioOutputAudioOutputListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPAudioOutputAudioOutputListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPAudioOutputAudioOutputListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, AudioOutputCluster, readCurrentAudioOutputAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::AudioOutputCluster * cppCluster = reinterpret_cast<chip::Controller::AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentAudioOutput(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, AudioOutputCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::AudioOutputCluster * cppCluster = reinterpret_cast<chip::Controller::AudioOutputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BarrierControlCluster, readBarrierMovingStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BarrierControlCluster * cppCluster = reinterpret_cast<chip::Controller::BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBarrierMovingState(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BarrierControlCluster, readBarrierSafetyStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BarrierControlCluster * cppCluster = reinterpret_cast<chip::Controller::BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBarrierSafetyStatus(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BarrierControlCluster, readBarrierCapabilitiesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BarrierControlCluster * cppCluster = reinterpret_cast<chip::Controller::BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBarrierCapabilities(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BarrierControlCluster, readBarrierPositionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BarrierControlCluster * cppCluster = reinterpret_cast<chip::Controller::BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBarrierPosition(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BarrierControlCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BarrierControlCluster * cppCluster = reinterpret_cast<chip::Controller::BarrierControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readInteractionModelVersionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInteractionModelVersion(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readVendorNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeVendorName(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readVendorIDAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeVendorID(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readProductNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeProductName(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readProductIDAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeProductID(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readUserLabelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeUserLabel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readLocationAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLocation(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readHardwareVersionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeHardwareVersion(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readHardwareVersionStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeHardwareVersionString(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readSoftwareVersionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSoftwareVersion(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readSoftwareVersionStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSoftwareVersionString(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readManufacturingDateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeManufacturingDate(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readPartNumberAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePartNumber(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readProductURLAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeProductURL(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readProductLabelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeProductLabel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readSerialNumberAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSerialNumber(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readLocalConfigDisabledAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLocalConfigDisabled(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readReachableAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeReachable(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BasicCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BasicCluster * cppCluster = reinterpret_cast<chip::Controller::BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, readOutOfServiceAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BinaryInputBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOutOfService(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, readPresentValueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BinaryInputBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePresentValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, readStatusFlagsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BinaryInputBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeStatusFlags(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BinaryInputBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BindingCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BindingCluster * cppCluster = reinterpret_cast<chip::Controller::BindingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BooleanStateCluster, readStateValueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BooleanStateCluster * cppCluster = reinterpret_cast<chip::Controller::BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeStateValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BooleanStateCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BooleanStateCluster * cppCluster = reinterpret_cast<chip::Controller::BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedActionsCluster, readActionListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedActionsCluster * cppCluster = reinterpret_cast<chip::Controller::BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeActionList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBridgedActionsActionListAttributeCallback,
                    void (*)(chip::CHIPBridgedActionsActionListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPBridgedActionsActionListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPBridgedActionsActionListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedActionsCluster, readEndpointListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedActionsCluster * cppCluster = reinterpret_cast<chip::Controller::BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeEndpointList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBridgedActionsEndpointListAttributeCallback,
                    void (*)(chip::CHIPBridgedActionsEndpointListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPBridgedActionsEndpointListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPBridgedActionsEndpointListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedActionsCluster, readSetupUrlAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedActionsCluster * cppCluster = reinterpret_cast<chip::Controller::BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSetupUrl(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedActionsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedActionsCluster * cppCluster = reinterpret_cast<chip::Controller::BridgedActionsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readVendorNameAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeVendorName(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readVendorIDAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeVendorID(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readProductNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeProductName(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readUserLabelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeUserLabel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readHardwareVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeHardwareVersion(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readHardwareVersionStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeHardwareVersionString(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readSoftwareVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSoftwareVersion(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readSoftwareVersionStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSoftwareVersionString(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readManufacturingDateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeManufacturingDate(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readPartNumberAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePartNumber(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readProductURLAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeProductURL(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readProductLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeProductLabel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readSerialNumberAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSerialNumber(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readReachableAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeReachable(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, BridgedDeviceBasicCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::BridgedDeviceBasicCluster * cppCluster =
        reinterpret_cast<chip::Controller::BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readCurrentHueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentHue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readCurrentSaturationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentSaturation(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readRemainingTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRemainingTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readCurrentXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentX(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readCurrentYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentY(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readDriftCompensationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeDriftCompensation(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readCompensationTextAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCompensationText(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorTemperatureAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorTemperature(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorControlOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorControlOptions(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readNumberOfPrimariesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeNumberOfPrimaries(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary1XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary1X(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary1YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary1Y(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary1IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary1Intensity(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary2XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary2X(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary2YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary2Y(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary2IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary2Intensity(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary3XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary3X(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary3YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary3Y(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary3IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary3Intensity(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary4XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary4X(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary4YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary4Y(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary4IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary4Intensity(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary5XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary5X(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary5YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary5Y(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary5IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary5Intensity(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary6XAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary6X(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary6YAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary6Y(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readPrimary6IntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePrimary6Intensity(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readWhitePointXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeWhitePointX(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readWhitePointYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeWhitePointY(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorPointRXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorPointRX(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorPointRYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorPointRY(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorPointRIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorPointRIntensity(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorPointGXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorPointGX(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorPointGYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorPointGY(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorPointGIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorPointGIntensity(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorPointBXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorPointBX(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorPointBYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorPointBY(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorPointBIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorPointBIntensity(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readEnhancedCurrentHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeEnhancedCurrentHue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readEnhancedColorModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeEnhancedColorMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorLoopActiveAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorLoopActive(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorLoopDirectionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorLoopDirection(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorLoopTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorLoopTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorLoopStartEnhancedHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorLoopStartEnhancedHue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorLoopStoredEnhancedHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorLoopStoredEnhancedHue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorCapabilitiesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorCapabilities(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorTempPhysicalMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorTempPhysicalMin(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readColorTempPhysicalMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeColorTempPhysicalMax(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readCoupleColorTempToLevelMinMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCoupleColorTempToLevelMinMireds(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readStartUpColorTemperatureMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeStartUpColorTemperatureMireds(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ColorControlCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ColorControlCluster * cppCluster = reinterpret_cast<chip::Controller::ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ContentLauncherCluster, readAcceptsHeaderListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ContentLauncherCluster * cppCluster =
        reinterpret_cast<chip::Controller::ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeAcceptsHeaderList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPContentLauncherAcceptsHeaderListAttributeCallback,
                    void (*)(chip::CHIPContentLauncherAcceptsHeaderListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPContentLauncherAcceptsHeaderListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPContentLauncherAcceptsHeaderListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ContentLauncherCluster, readSupportedStreamingTypesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ContentLauncherCluster * cppCluster =
        reinterpret_cast<chip::Controller::ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSupportedStreamingTypes(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPContentLauncherSupportedStreamingTypesAttributeCallback,
                    void (*)(chip::CHIPContentLauncherSupportedStreamingTypesAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPContentLauncherSupportedStreamingTypesAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPContentLauncherSupportedStreamingTypesAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ContentLauncherCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ContentLauncherCluster * cppCluster =
        reinterpret_cast<chip::Controller::ContentLauncherCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, DescriptorCluster, readDeviceListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::DescriptorCluster * cppCluster = reinterpret_cast<chip::Controller::DescriptorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeDeviceList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPDescriptorDeviceListAttributeCallback, void (*)(chip::CHIPDescriptorDeviceListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPDescriptorDeviceListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPDescriptorDeviceListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, DescriptorCluster, readServerListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::DescriptorCluster * cppCluster = reinterpret_cast<chip::Controller::DescriptorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeServerList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPDescriptorServerListAttributeCallback, void (*)(chip::CHIPDescriptorServerListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPDescriptorServerListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPDescriptorServerListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, DescriptorCluster, readClientListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::DescriptorCluster * cppCluster = reinterpret_cast<chip::Controller::DescriptorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClientList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPDescriptorClientListAttributeCallback, void (*)(chip::CHIPDescriptorClientListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPDescriptorClientListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPDescriptorClientListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, DescriptorCluster, readPartsListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::DescriptorCluster * cppCluster = reinterpret_cast<chip::Controller::DescriptorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePartsList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPDescriptorPartsListAttributeCallback, void (*)(chip::CHIPDescriptorPartsListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPDescriptorPartsListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPDescriptorPartsListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, DescriptorCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::DescriptorCluster * cppCluster = reinterpret_cast<chip::Controller::DescriptorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, DoorLockCluster, readLockStateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::DoorLockCluster * cppCluster = reinterpret_cast<chip::Controller::DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLockState(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, DoorLockCluster, readLockTypeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::DoorLockCluster * cppCluster = reinterpret_cast<chip::Controller::DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLockType(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, DoorLockCluster, readActuatorEnabledAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::DoorLockCluster * cppCluster = reinterpret_cast<chip::Controller::DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeActuatorEnabled(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, DoorLockCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::DoorLockCluster * cppCluster = reinterpret_cast<chip::Controller::DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readMeasurementTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMeasurementType(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readTotalActivePowerAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTotalActivePower(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32sAttributeCallback, void (*)(chip::CHIPInt32sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsVoltageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRmsVoltage(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsVoltageMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRmsVoltageMin(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsVoltageMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRmsVoltageMax(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsCurrentAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRmsCurrent(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsCurrentMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRmsCurrentMin(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readRmsCurrentMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRmsCurrentMax(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readActivePowerAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeActivePower(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readActivePowerMinAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeActivePowerMin(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readActivePowerMaxAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeActivePowerMax(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ElectricalMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ElectricalMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::ElectricalMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readPHYRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::EthernetNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePHYRate(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readFullDuplexAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::EthernetNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeFullDuplex(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readPacketRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::EthernetNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePacketRxCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readPacketTxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::EthernetNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePacketTxCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readTxErrCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::EthernetNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxErrCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readCollisionCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::EthernetNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCollisionCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::EthernetNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOverrunCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readCarrierDetectAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::EthernetNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCarrierDetect(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readTimeSinceResetAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::EthernetNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTimeSinceReset(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::EthernetNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, FixedLabelCluster, readLabelListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::FixedLabelCluster * cppCluster = reinterpret_cast<chip::Controller::FixedLabelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLabelList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPFixedLabelLabelListAttributeCallback, void (*)(chip::CHIPFixedLabelLabelListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPFixedLabelLabelListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPFixedLabelLabelListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, FixedLabelCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::FixedLabelCluster * cppCluster = reinterpret_cast<chip::Controller::FixedLabelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, FlowMeasurementCluster, readMeasuredValueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::FlowMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, FlowMeasurementCluster, readMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::FlowMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, FlowMeasurementCluster, readMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::FlowMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, FlowMeasurementCluster, readToleranceAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::FlowMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTolerance(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, FlowMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::FlowMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::FlowMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GeneralCommissioningCluster, readBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GeneralCommissioningCluster * cppCluster =
        reinterpret_cast<chip::Controller::GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBreadcrumb(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GeneralCommissioningCluster, readBasicCommissioningInfoListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GeneralCommissioningCluster * cppCluster =
        reinterpret_cast<chip::Controller::GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBasicCommissioningInfoList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback,
                    void (*)(chip::CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback *)>
        readCallback(
            chip::Platform::New<chip::CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback>(callback, actionBlock),
            chip::Platform::Delete<chip::CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GeneralCommissioningCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GeneralCommissioningCluster * cppCluster =
        reinterpret_cast<chip::Controller::GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, readNetworkInterfacesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GeneralDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeNetworkInterfaces(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback,
                    void (*)(chip::CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, readRebootCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GeneralDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRebootCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, readUpTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GeneralDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeUpTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, readTotalOperationalHoursAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GeneralDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTotalOperationalHours(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, readBootReasonsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GeneralDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBootReasons(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GeneralDiagnosticsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GeneralDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::GeneralDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GroupKeyManagementCluster, readGroupsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GroupKeyManagementCluster * cppCluster =
        reinterpret_cast<chip::Controller::GroupKeyManagementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeGroups(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPGroupKeyManagementGroupsAttributeCallback,
                    void (*)(chip::CHIPGroupKeyManagementGroupsAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPGroupKeyManagementGroupsAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPGroupKeyManagementGroupsAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GroupKeyManagementCluster, readGroupKeysAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GroupKeyManagementCluster * cppCluster =
        reinterpret_cast<chip::Controller::GroupKeyManagementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeGroupKeys(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPGroupKeyManagementGroupKeysAttributeCallback,
                    void (*)(chip::CHIPGroupKeyManagementGroupKeysAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPGroupKeyManagementGroupKeysAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPGroupKeyManagementGroupKeysAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GroupKeyManagementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GroupKeyManagementCluster * cppCluster =
        reinterpret_cast<chip::Controller::GroupKeyManagementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GroupsCluster, readNameSupportAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GroupsCluster * cppCluster = reinterpret_cast<chip::Controller::GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeNameSupport(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, GroupsCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::GroupsCluster * cppCluster = reinterpret_cast<chip::Controller::GroupsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, IdentifyCluster, readIdentifyTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::IdentifyCluster * cppCluster = reinterpret_cast<chip::Controller::IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeIdentifyTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, IdentifyCluster, readIdentifyTypeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::IdentifyCluster * cppCluster = reinterpret_cast<chip::Controller::IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeIdentifyType(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, IdentifyCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::IdentifyCluster * cppCluster = reinterpret_cast<chip::Controller::IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, readMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::IlluminanceMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, readMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::IlluminanceMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, readMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::IlluminanceMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, readToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::IlluminanceMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTolerance(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, readLightSensorTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::IlluminanceMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLightSensorType(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::IlluminanceMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, KeypadInputCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::KeypadInputCluster * cppCluster = reinterpret_cast<chip::Controller::KeypadInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readCurrentLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentLevel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readRemainingTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRemainingTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readMinLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinLevel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readMaxLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxLevel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readCurrentFrequencyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentFrequency(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readMinFrequencyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinFrequency(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readMaxFrequencyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxFrequency(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readOptionsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOptions(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readOnOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOnOffTransitionTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readOnLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOnLevel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readOnTransitionTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOnTransitionTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOffTransitionTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readDefaultMoveRateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeDefaultMoveRate(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readStartUpCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeStartUpCurrentLevel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LevelControlCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LevelControlCluster * cppCluster = reinterpret_cast<chip::Controller::LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, LowPowerCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::LowPowerCluster * cppCluster = reinterpret_cast<chip::Controller::LowPowerCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaInputCluster, readMediaInputListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaInputCluster * cppCluster = reinterpret_cast<chip::Controller::MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMediaInputList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPMediaInputMediaInputListAttributeCallback,
                    void (*)(chip::CHIPMediaInputMediaInputListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPMediaInputMediaInputListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPMediaInputMediaInputListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaInputCluster, readCurrentMediaInputAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaInputCluster * cppCluster = reinterpret_cast<chip::Controller::MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentMediaInput(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaInputCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaInputCluster * cppCluster = reinterpret_cast<chip::Controller::MediaInputCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaPlaybackCluster, readPlaybackStateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaPlaybackCluster * cppCluster = reinterpret_cast<chip::Controller::MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePlaybackState(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaPlaybackCluster, readStartTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaPlaybackCluster * cppCluster = reinterpret_cast<chip::Controller::MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeStartTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaPlaybackCluster, readDurationAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaPlaybackCluster * cppCluster = reinterpret_cast<chip::Controller::MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeDuration(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaPlaybackCluster, readPositionUpdatedAtAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaPlaybackCluster * cppCluster = reinterpret_cast<chip::Controller::MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePositionUpdatedAt(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaPlaybackCluster, readPositionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaPlaybackCluster * cppCluster = reinterpret_cast<chip::Controller::MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePosition(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaPlaybackCluster, readPlaybackSpeedAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaPlaybackCluster * cppCluster = reinterpret_cast<chip::Controller::MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePlaybackSpeed(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaPlaybackCluster, readSeekRangeEndAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaPlaybackCluster * cppCluster = reinterpret_cast<chip::Controller::MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSeekRangeEnd(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaPlaybackCluster, readSeekRangeStartAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaPlaybackCluster * cppCluster = reinterpret_cast<chip::Controller::MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSeekRangeStart(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, MediaPlaybackCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::MediaPlaybackCluster * cppCluster = reinterpret_cast<chip::Controller::MediaPlaybackCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ModeSelectCluster, readCurrentModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ModeSelectCluster * cppCluster = reinterpret_cast<chip::Controller::ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ModeSelectCluster, readSupportedModesAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ModeSelectCluster * cppCluster = reinterpret_cast<chip::Controller::ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSupportedModes(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPModeSelectSupportedModesAttributeCallback,
                    void (*)(chip::CHIPModeSelectSupportedModesAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPModeSelectSupportedModesAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPModeSelectSupportedModesAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ModeSelectCluster, readOnModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ModeSelectCluster * cppCluster = reinterpret_cast<chip::Controller::ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOnMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ModeSelectCluster, readStartUpModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ModeSelectCluster * cppCluster = reinterpret_cast<chip::Controller::ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeStartUpMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ModeSelectCluster, readDescriptionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ModeSelectCluster * cppCluster = reinterpret_cast<chip::Controller::ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeDescription(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ModeSelectCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ModeSelectCluster * cppCluster = reinterpret_cast<chip::Controller::ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, NetworkCommissioningCluster, readFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::NetworkCommissioningCluster * cppCluster =
        reinterpret_cast<chip::Controller::NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeFeatureMap(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, NetworkCommissioningCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::NetworkCommissioningCluster * cppCluster =
        reinterpret_cast<chip::Controller::NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OtaSoftwareUpdateProviderCluster * cppCluster =
        reinterpret_cast<chip::Controller::OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, readDefaultOtaProviderAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OtaSoftwareUpdateRequestorCluster * cppCluster =
        reinterpret_cast<chip::Controller::OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeDefaultOtaProvider(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOctetStringAttributeCallback, void (*)(chip::CHIPOctetStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPOctetStringAttributeCallback>(callback, actionBlock, true),
        chip::Platform::Delete<chip::CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, readUpdatePossibleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OtaSoftwareUpdateRequestorCluster * cppCluster =
        reinterpret_cast<chip::Controller::OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeUpdatePossible(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OtaSoftwareUpdateRequestorCluster * cppCluster =
        reinterpret_cast<chip::Controller::OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OccupancySensingCluster, readOccupancyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OccupancySensingCluster * cppCluster =
        reinterpret_cast<chip::Controller::OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOccupancy(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OccupancySensingCluster, readOccupancySensorTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OccupancySensingCluster * cppCluster =
        reinterpret_cast<chip::Controller::OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOccupancySensorType(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OccupancySensingCluster, readOccupancySensorTypeBitmapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OccupancySensingCluster * cppCluster =
        reinterpret_cast<chip::Controller::OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOccupancySensorTypeBitmap(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OccupancySensingCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OccupancySensingCluster * cppCluster =
        reinterpret_cast<chip::Controller::OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OnOffCluster, readOnOffAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OnOffCluster * cppCluster = reinterpret_cast<chip::Controller::OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOnOff(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OnOffCluster, readGlobalSceneControlAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OnOffCluster * cppCluster = reinterpret_cast<chip::Controller::OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeGlobalSceneControl(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OnOffCluster, readOnTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OnOffCluster * cppCluster = reinterpret_cast<chip::Controller::OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOnTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OnOffCluster, readOffWaitTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OnOffCluster * cppCluster = reinterpret_cast<chip::Controller::OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOffWaitTime(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OnOffCluster, readStartUpOnOffAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OnOffCluster * cppCluster = reinterpret_cast<chip::Controller::OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeStartUpOnOff(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OnOffCluster, readFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OnOffCluster * cppCluster = reinterpret_cast<chip::Controller::OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeFeatureMap(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OnOffCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OnOffCluster * cppCluster = reinterpret_cast<chip::Controller::OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, readSwitchTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OnOffSwitchConfigurationCluster * cppCluster =
        reinterpret_cast<chip::Controller::OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSwitchType(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, readSwitchActionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OnOffSwitchConfigurationCluster * cppCluster =
        reinterpret_cast<chip::Controller::OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSwitchActions(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OnOffSwitchConfigurationCluster * cppCluster =
        reinterpret_cast<chip::Controller::OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OperationalCredentialsCluster, readFabricsListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OperationalCredentialsCluster * cppCluster =
        reinterpret_cast<chip::Controller::OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeFabricsList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOperationalCredentialsFabricsListAttributeCallback,
                    void (*)(chip::CHIPOperationalCredentialsFabricsListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPOperationalCredentialsFabricsListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPOperationalCredentialsFabricsListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OperationalCredentialsCluster, readSupportedFabricsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OperationalCredentialsCluster * cppCluster =
        reinterpret_cast<chip::Controller::OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSupportedFabrics(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OperationalCredentialsCluster, readCommissionedFabricsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OperationalCredentialsCluster * cppCluster =
        reinterpret_cast<chip::Controller::OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCommissionedFabrics(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OperationalCredentialsCluster, readTrustedRootCertificatesAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OperationalCredentialsCluster * cppCluster =
        reinterpret_cast<chip::Controller::OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTrustedRootCertificates(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback,
                    void (*)(chip::CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback *)>
        readCallback(
            chip::Platform::New<chip::CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback>(callback, actionBlock),
            chip::Platform::Delete<chip::CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OperationalCredentialsCluster, readCurrentFabricIndexAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OperationalCredentialsCluster * cppCluster =
        reinterpret_cast<chip::Controller::OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentFabricIndex(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, OperationalCredentialsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::OperationalCredentialsCluster * cppCluster =
        reinterpret_cast<chip::Controller::OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeStatus(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readOrderAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOrder(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readDescriptionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeDescription(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readBatteryVoltageAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBatteryVoltage(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readBatteryPercentRemainingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBatteryPercentRemaining(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readBatteryTimeRemainingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBatteryTimeRemaining(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readBatteryChargeLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBatteryChargeLevel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readActiveBatteryFaultsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeActiveBatteryFaults(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPPowerSourceActiveBatteryFaultsAttributeCallback,
                    void (*)(chip::CHIPPowerSourceActiveBatteryFaultsAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPPowerSourceActiveBatteryFaultsAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPPowerSourceActiveBatteryFaultsAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readBatteryChargeStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBatteryChargeState(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeFeatureMap(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PowerSourceCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PowerSourceCluster * cppCluster = reinterpret_cast<chip::Controller::PowerSourceCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PressureMeasurementCluster, readMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PressureMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PressureMeasurementCluster, readMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PressureMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PressureMeasurementCluster, readMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PressureMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PressureMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PressureMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxPressure(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxSpeed(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxFlowAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxFlow(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMinConstPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinConstPressure(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxConstPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxConstPressure(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMinCompPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinCompPressure(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxCompPressureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxCompPressure(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMinConstSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinConstSpeed(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxConstSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxConstSpeed(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMinConstFlowAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinConstFlow(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxConstFlowAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxConstFlow(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMinConstTempAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinConstTemp(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readMaxConstTempAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxConstTemp(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readPumpStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePumpStatus(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readEffectiveOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeEffectiveOperationMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readEffectiveControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeEffectiveControlMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readCapacityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCapacity(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readSpeedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSpeed(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readLifetimeEnergyConsumedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLifetimeEnergyConsumed(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOperationMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeControlMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readAlarmMaskAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeAlarmMask(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readFeatureMapAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeFeatureMap(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::PumpConfigurationAndControlCluster * cppCluster =
        reinterpret_cast<chip::Controller::PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, readMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::RelativeHumidityMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, readMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::RelativeHumidityMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, readMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::RelativeHumidityMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, readToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::RelativeHumidityMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTolerance(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::RelativeHumidityMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ScenesCluster, readSceneCountAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ScenesCluster * cppCluster = reinterpret_cast<chip::Controller::ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSceneCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ScenesCluster, readCurrentSceneAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ScenesCluster * cppCluster = reinterpret_cast<chip::Controller::ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentScene(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ScenesCluster, readCurrentGroupAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ScenesCluster * cppCluster = reinterpret_cast<chip::Controller::ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentGroup(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ScenesCluster, readSceneValidAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ScenesCluster * cppCluster = reinterpret_cast<chip::Controller::ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSceneValid(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ScenesCluster, readNameSupportAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ScenesCluster * cppCluster = reinterpret_cast<chip::Controller::ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeNameSupport(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ScenesCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ScenesCluster * cppCluster = reinterpret_cast<chip::Controller::ScenesCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, readCurrentHeapFreeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::SoftwareDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentHeapFree(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, readCurrentHeapUsedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::SoftwareDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentHeapUsed(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, readCurrentHeapHighWatermarkAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::SoftwareDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentHeapHighWatermark(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::SoftwareDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, SwitchCluster, readNumberOfPositionsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::SwitchCluster * cppCluster = reinterpret_cast<chip::Controller::SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeNumberOfPositions(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, SwitchCluster, readCurrentPositionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::SwitchCluster * cppCluster = reinterpret_cast<chip::Controller::SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentPosition(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, SwitchCluster, readMultiPressMaxAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::SwitchCluster * cppCluster = reinterpret_cast<chip::Controller::SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMultiPressMax(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, SwitchCluster, readFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::SwitchCluster * cppCluster = reinterpret_cast<chip::Controller::SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeFeatureMap(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, SwitchCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::SwitchCluster * cppCluster = reinterpret_cast<chip::Controller::SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TvChannelCluster, readTvChannelListAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TvChannelCluster * cppCluster = reinterpret_cast<chip::Controller::TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTvChannelList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPTvChannelTvChannelListAttributeCallback,
                    void (*)(chip::CHIPTvChannelTvChannelListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPTvChannelTvChannelListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPTvChannelTvChannelListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TvChannelCluster, readTvChannelLineupAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TvChannelCluster * cppCluster = reinterpret_cast<chip::Controller::TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTvChannelLineup(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOctetStringAttributeCallback, void (*)(chip::CHIPOctetStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPOctetStringAttributeCallback>(callback, actionBlock, true),
        chip::Platform::Delete<chip::CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TvChannelCluster, readCurrentTvChannelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TvChannelCluster * cppCluster = reinterpret_cast<chip::Controller::TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentTvChannel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOctetStringAttributeCallback, void (*)(chip::CHIPOctetStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPOctetStringAttributeCallback>(callback, actionBlock, true),
        chip::Platform::Delete<chip::CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TvChannelCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TvChannelCluster * cppCluster = reinterpret_cast<chip::Controller::TvChannelCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TargetNavigatorCluster, readTargetNavigatorListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TargetNavigatorCluster * cppCluster =
        reinterpret_cast<chip::Controller::TargetNavigatorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTargetNavigatorList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPTargetNavigatorTargetNavigatorListAttributeCallback,
                    void (*)(chip::CHIPTargetNavigatorTargetNavigatorListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPTargetNavigatorTargetNavigatorListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPTargetNavigatorTargetNavigatorListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TargetNavigatorCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TargetNavigatorCluster * cppCluster =
        reinterpret_cast<chip::Controller::TargetNavigatorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, readMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TemperatureMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, readMinMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TemperatureMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, readMaxMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TemperatureMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxMeasuredValue(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, readToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TemperatureMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTolerance(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TemperatureMeasurementCluster * cppCluster =
        reinterpret_cast<chip::Controller::TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readBooleanAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBoolean(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readBitmap8Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBitmap8(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readBitmap16Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBitmap16(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readBitmap32Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBitmap32(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readBitmap64Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBitmap64(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readInt8uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInt8u(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readInt16uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInt16u(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readInt32uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInt32u(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readInt64uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInt64u(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readInt8sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInt8s(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8sAttributeCallback, void (*)(chip::CHIPInt8sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readInt16sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInt16s(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readInt32sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInt32s(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32sAttributeCallback, void (*)(chip::CHIPInt32sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readInt64sAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInt64s(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64sAttributeCallback, void (*)(chip::CHIPInt64sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readEnum8Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeEnum8(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readEnum16Attribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeEnum16(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readOctetStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOctetString(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOctetStringAttributeCallback, void (*)(chip::CHIPOctetStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPOctetStringAttributeCallback>(callback, actionBlock, true),
        chip::Platform::Delete<chip::CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readListInt8uAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeListInt8u(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPTestClusterListInt8uAttributeCallback, void (*)(chip::CHIPTestClusterListInt8uAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPTestClusterListInt8uAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPTestClusterListInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readListOctetStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeListOctetString(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPTestClusterListOctetStringAttributeCallback,
                    void (*)(chip::CHIPTestClusterListOctetStringAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPTestClusterListOctetStringAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPTestClusterListOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readListStructOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeListStructOctetString(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPTestClusterListStructOctetStringAttributeCallback,
                    void (*)(chip::CHIPTestClusterListStructOctetStringAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPTestClusterListStructOctetStringAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPTestClusterListStructOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readLongOctetStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLongOctetString(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOctetStringAttributeCallback, void (*)(chip::CHIPOctetStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPOctetStringAttributeCallback>(callback, actionBlock, true),
        chip::Platform::Delete<chip::CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readCharStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCharString(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readLongCharStringAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLongCharString(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readEpochUsAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeEpochUs(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readEpochSAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeEpochS(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readVendorIdAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeVendorId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readListNullablesAndOptionalsStructAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeListNullablesAndOptionalsStruct(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback,
                    void (*)(chip::CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback *)>
        readCallback(
            chip::Platform::New<chip::CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback>(callback, actionBlock),
            chip::Platform::Delete<chip::CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readUnsupportedAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeUnsupported(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPBooleanAttributeCallback, void (*)(chip::CHIPBooleanAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPBooleanAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPBooleanAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, TestClusterCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::TestClusterCluster * cppCluster = reinterpret_cast<chip::Controller::TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readLocalTemperatureAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLocalTemperature(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readAbsMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeAbsMinHeatSetpointLimit(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readAbsMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeAbsMaxHeatSetpointLimit(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readAbsMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeAbsMinCoolSetpointLimit(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readAbsMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeAbsMaxCoolSetpointLimit(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readOccupiedCoolingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOccupiedCoolingSetpoint(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readOccupiedHeatingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOccupiedHeatingSetpoint(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinHeatSetpointLimit(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxHeatSetpointLimit(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinCoolSetpointLimit(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMaxCoolSetpointLimit(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16sAttributeCallback, void (*)(chip::CHIPInt16sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readMinSetpointDeadBandAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMinSetpointDeadBand(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8sAttributeCallback, void (*)(chip::CHIPInt8sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readControlSequenceOfOperationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeControlSequenceOfOperation(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readSystemModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSystemMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readStartOfWeekAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeStartOfWeek(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readNumberOfWeeklyTransitionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeNumberOfWeeklyTransitions(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readNumberOfDailyTransitionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeNumberOfDailyTransitions(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeFeatureMap(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatCluster * cppCluster = reinterpret_cast<chip::Controller::ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, readTemperatureDisplayModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTemperatureDisplayMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, readKeypadLockoutAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeKeypadLockout(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, readScheduleProgrammingVisibilityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeScheduleProgrammingVisibility(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readChannelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeChannel(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRoutingRoleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRoutingRole(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readNetworkNameAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeNetworkName(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOctetStringAttributeCallback, void (*)(chip::CHIPOctetStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPOctetStringAttributeCallback>(callback, actionBlock, true),
        chip::Platform::Delete<chip::CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readPanIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePanId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readExtendedPanIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeExtendedPanId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readMeshLocalPrefixAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMeshLocalPrefix(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOctetStringAttributeCallback, void (*)(chip::CHIPOctetStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPOctetStringAttributeCallback>(callback, actionBlock, true),
        chip::Platform::Delete<chip::CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOverrunCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readNeighborTableListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeNeighborTableList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback,
                    void (*)(chip::CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback *)>
        readCallback(
            chip::Platform::New<chip::CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback>(callback, actionBlock),
            chip::Platform::Delete<chip::CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRouteTableListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRouteTableList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback,
                    void (*)(chip::CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readPartitionIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePartitionId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readWeightingAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeWeighting(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readDataVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeDataVersion(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readStableDataVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeStableDataVersion(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readLeaderRouterIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLeaderRouterId(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readDetachedRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeDetachedRoleCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readChildRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeChildRoleCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRouterRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRouterRoleCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readLeaderRoleCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeLeaderRoleCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readAttachAttemptCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeAttachAttemptCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readPartitionIdChangeCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePartitionIdChangeCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readBetterPartitionAttachAttemptCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBetterPartitionAttachAttemptCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readParentChangeCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeParentChangeCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxTotalCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxTotalCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxUnicastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxUnicastCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxBroadcastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxBroadcastCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxAckRequestedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxAckRequestedCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxAckedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxAckedCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxNoAckRequestedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxNoAckRequestedCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxDataCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxDataCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxDataPollCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxDataPollCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxBeaconCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxBeaconCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxBeaconRequestCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxBeaconRequestCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxOtherCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxRetryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxRetryCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxDirectMaxRetryExpiryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxDirectMaxRetryExpiryCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxIndirectMaxRetryExpiryCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxIndirectMaxRetryExpiryCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxErrCcaCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxErrCcaCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxErrAbortCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxErrAbortCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readTxErrBusyChannelCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTxErrBusyChannelCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxTotalCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxTotalCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxUnicastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxUnicastCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxBroadcastCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxBroadcastCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxDataCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxDataCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxDataPollCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxDataPollCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxBeaconCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxBeaconCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxBeaconRequestCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxBeaconRequestCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxOtherCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxAddressFilteredCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxAddressFilteredCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxDestAddrFilteredCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxDestAddrFilteredCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxDuplicatedCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxDuplicatedCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrNoFrameCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxErrNoFrameCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrUnknownNeighborCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxErrUnknownNeighborCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrInvalidSrcAddrCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxErrInvalidSrcAddrCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrSecCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxErrSecCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrFcsCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxErrFcsCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readRxErrOtherCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRxErrOtherCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readActiveTimestampAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeActiveTimestamp(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readPendingTimestampAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePendingTimestamp(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readDelayAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeDelay(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readSecurityPolicyAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSecurityPolicy(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback,
                    void (*)(chip::CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback>(callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readChannelMaskAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeChannelMask(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOctetStringAttributeCallback, void (*)(chip::CHIPOctetStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPOctetStringAttributeCallback>(callback, actionBlock, true),
        chip::Platform::Delete<chip::CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readOperationalDatasetComponentsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOperationalDatasetComponents(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback,
                    void (*)(chip::CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback *)>
        readCallback(chip::Platform::New<chip::CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback>(
                         callback, actionBlock),
                     chip::Platform::Delete<chip::CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readActiveNetworkFaultsListAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeActiveNetworkFaultsList(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback,
                    void (*)(chip::CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback *)>
        readCallback(
            chip::Platform::New<chip::CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback>(callback, actionBlock),
            chip::Platform::Delete<chip::CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::ThreadNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WakeOnLanCluster, readWakeOnLanMacAddressAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WakeOnLanCluster * cppCluster = reinterpret_cast<chip::Controller::WakeOnLanCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeWakeOnLanMacAddress(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPCharStringAttributeCallback, void (*)(chip::CHIPCharStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPCharStringAttributeCallback>(callback, actionBlock, false),
        chip::Platform::Delete<chip::CHIPCharStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WakeOnLanCluster, readClusterRevisionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WakeOnLanCluster * cppCluster = reinterpret_cast<chip::Controller::WakeOnLanCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readBssidAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBssid(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPOctetStringAttributeCallback, void (*)(chip::CHIPOctetStringAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPOctetStringAttributeCallback>(callback, actionBlock, true),
        chip::Platform::Delete<chip::CHIPOctetStringAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readSecurityTypeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSecurityType(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readWiFiVersionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeWiFiVersion(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readChannelNumberAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeChannelNumber(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readRssiAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeRssi(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8sAttributeCallback, void (*)(chip::CHIPInt8sAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8sAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8sAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readBeaconLostCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBeaconLostCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readBeaconRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeBeaconRxCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readPacketMulticastRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePacketMulticastRxCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readPacketMulticastTxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePacketMulticastTxCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readPacketUnicastRxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePacketUnicastRxCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readPacketUnicastTxCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributePacketUnicastTxCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readCurrentMaxRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentMaxRate(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readOverrunCountAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOverrunCount(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt64uAttributeCallback, void (*)(chip::CHIPInt64uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt64uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt64uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WiFiNetworkDiagnosticsCluster * cppCluster =
        reinterpret_cast<chip::Controller::WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readTypeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeType(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentPositionLift(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentPositionTilt(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readConfigStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeConfigStatus(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionLiftPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentPositionLiftPercentage(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionTiltPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentPositionTiltPercentage(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readOperationalStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeOperationalStatus(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readTargetPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTargetPositionLiftPercent100ths(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readTargetPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeTargetPositionTiltPercent100ths(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readEndProductTypeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeEndProductType(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentPositionLiftPercent100ths(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readCurrentPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeCurrentPositionTiltPercent100ths(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readInstalledOpenLimitLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInstalledOpenLimitLift(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readInstalledClosedLimitLiftAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInstalledClosedLimitLift(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readInstalledOpenLimitTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInstalledOpenLimitTilt(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readInstalledClosedLimitTiltAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeInstalledClosedLimitTilt(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeMode(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt8uAttributeCallback, void (*)(chip::CHIPInt8uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt8uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt8uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readSafetyStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeSafetyStatus(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readFeatureMapAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeFeatureMap(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt32uAttributeCallback, void (*)(chip::CHIPInt32uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt32uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt32uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}

JNI_METHOD(void, WindowCoveringCluster, readClusterRevisionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;

    chip::Controller::WindowCoveringCluster * cppCluster = reinterpret_cast<chip::Controller::WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    chip::CHIPActionBlock actionBlock = [cppCluster](chip::Callback::Cancelable * success, chip::Callback::Cancelable * failure) {
        return cppCluster->ReadAttributeClusterRevision(success->Cancel(), failure->Cancel());
    };

    std::unique_ptr<chip::CHIPInt16uAttributeCallback, void (*)(chip::CHIPInt16uAttributeCallback *)> readCallback(
        chip::Platform::New<chip::CHIPInt16uAttributeCallback>(callback, actionBlock),
        chip::Platform::Delete<chip::CHIPInt16uAttributeCallback>);
    VerifyOrReturn(readCallback.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native callback", CHIP_ERROR_NO_MEMORY));

    readCallback.release();
}
