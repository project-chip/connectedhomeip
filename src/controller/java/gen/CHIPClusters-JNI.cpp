/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include "CHIPJNIError.h"
#include "JniReferences.h"
#include "JniTypeWrappers.h"
#include "StackLock.h"
#include "gen/CHIPClientCallbacks.h"
#include "gen/CHIPClusters.h"

#include <core/CHIPSafeCasts.h>
#include <jni.h>
#include <lib/support/Span.h>
#include <support/CodeUtils.h>

#define JNI_METHOD(RETURN, CLASS_NAME, METHOD_NAME)                                                                                \
    extern "C" JNIEXPORT RETURN JNICALL Java_chip_devicecontroller_ChipClusters_00024##CLASS_NAME##_##METHOD_NAME

using namespace chip;
using namespace chip::Controller;

static CHIP_ERROR CreateChipClusterException(JNIEnv * env, jint errorCode, jthrowable & outEx);
static CHIP_ERROR CreateIllegalStateException(JNIEnv * env, const char message[], jint errorCode, jthrowable & outEx);

CHIP_ERROR CreateChipClusterException(JNIEnv * env, jint errorCode, jthrowable & outEx)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    jmethodID exceptionConstructor;

    exceptionConstructor = env->GetMethodID(GetClusterExceptionCls(), "<init>", "(I)V");
    VerifyOrExit(exceptionConstructor != NULL, err = CHIP_JNI_ERROR_TYPE_NOT_FOUND);

    outEx = (jthrowable) env->NewObject(GetClusterExceptionCls(), exceptionConstructor, errorCode);
    VerifyOrExit(outEx != NULL, err = CHIP_JNI_ERROR_TYPE_NOT_FOUND);

exit:
    return err;
}

CHIP_ERROR CreateIllegalStateException(JNIEnv * env, const char message[], jint errorCode, jthrowable & outEx)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    jmethodID exceptionConstructor;
    jclass exceptionClass;
    jstring errStr;

    err = GetClassRef(env, "java/lang/IllegalStateException", exceptionClass);
    SuccessOrExit(err);

    exceptionConstructor = env->GetMethodID(exceptionClass, "<init>", "(Ljava/lang/String;)V");
    VerifyOrExit(exceptionConstructor != NULL, err = CHIP_JNI_ERROR_TYPE_NOT_FOUND);

    char buf[CHIP_CONFIG_LOG_MESSAGE_MAX_SIZE];
    snprintf(buf, sizeof(buf), "%s: %d", message, errorCode);
    errStr = env->NewStringUTF(buf);

    outEx = (jthrowable) env->NewObject(exceptionClass, exceptionConstructor, errStr);
    VerifyOrExit(outEx != NULL, err = CHIP_JNI_ERROR_TYPE_NOT_FOUND);
exit:
    return err;
}

class CHIPDefaultSuccessCallback : public Callback::Callback<DefaultSuccessCallback>
{
public:
    CHIPDefaultSuccessCallback(jobject javaCallback) : Callback::Callback<DefaultSuccessCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    ~CHIPDefaultSuccessCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        jmethodID javaMethod;
        JNIEnv * env = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        CHIPDefaultSuccessCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDefaultSuccessCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_ERROR_INCORRECT_STATE);

        // It's valid for javaCallbackRef to be NULL if the Java code passed in a null callback.
        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDefaultFailureCallback : public Callback::Callback<DefaultFailureCallback>
{
public:
    CHIPDefaultFailureCallback(jobject javaCallback) : Callback::Callback<DefaultFailureCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }

    ~CHIPDefaultFailureCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        jmethodID javaMethod;
        JNIEnv * env = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jthrowable exception;
        CHIPDefaultFailureCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDefaultFailureCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_ERROR_INCORRECT_STATE);

        // It's valid for javaCallbackRef to be NULL if the Java code passed in a null callback.
        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onError", "(Ljava/lang/Exception;)V", &javaMethod);
        SuccessOrExit(err);

        err = CreateChipClusterException(env, status, exception);
        SuccessOrExit(err);

        env->ExceptionClear();
        env->CallVoidMethod(javaCallbackRef, javaMethod, exception);
    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

// TODO(#7376): add attribute callbacks.

class CHIPAccountLoginClusterGetSetupPINResponseCallback : public Callback::Callback<AccountLoginClusterGetSetupPINResponseCallback>
{
public:
    CHIPAccountLoginClusterGetSetupPINResponseCallback(jobject javaCallback) :
        Callback::Callback<AccountLoginClusterGetSetupPINResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPAccountLoginClusterGetSetupPINResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t * setupPIN)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPAccountLoginClusterGetSetupPINResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString setupPINStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPAccountLoginClusterGetSetupPINResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, setupPINStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPApplicationLauncherClusterLaunchAppResponseCallback
    : public Callback::Callback<ApplicationLauncherClusterLaunchAppResponseCallback>
{
public:
    CHIPApplicationLauncherClusterLaunchAppResponseCallback(jobject javaCallback) :
        Callback::Callback<ApplicationLauncherClusterLaunchAppResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPApplicationLauncherClusterLaunchAppResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t * data)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPApplicationLauncherClusterLaunchAppResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString dataStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPApplicationLauncherClusterLaunchAppResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, dataStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPContentLaunchClusterLaunchContentResponseCallback
    : public Callback::Callback<ContentLaunchClusterLaunchContentResponseCallback>
{
public:
    CHIPContentLaunchClusterLaunchContentResponseCallback(jobject javaCallback) :
        Callback::Callback<ContentLaunchClusterLaunchContentResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPContentLaunchClusterLaunchContentResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t * data, uint8_t contentLaunchStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPContentLaunchClusterLaunchContentResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString dataStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPContentLaunchClusterLaunchContentResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, dataStr.jniValue(), static_cast<jint>(contentLaunchStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPContentLaunchClusterLaunchURLResponseCallback : public Callback::Callback<ContentLaunchClusterLaunchURLResponseCallback>
{
public:
    CHIPContentLaunchClusterLaunchURLResponseCallback(jobject javaCallback) :
        Callback::Callback<ContentLaunchClusterLaunchURLResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPContentLaunchClusterLaunchURLResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t * data, uint8_t contentLaunchStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPContentLaunchClusterLaunchURLResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString dataStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPContentLaunchClusterLaunchURLResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, dataStr.jniValue(), static_cast<jint>(contentLaunchStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearAllPinsResponseCallback : public Callback::Callback<DoorLockClusterClearAllPinsResponseCallback>
{
public:
    CHIPDoorLockClusterClearAllPinsResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearAllPinsResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearAllPinsResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearAllPinsResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearAllPinsResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearAllRfidsResponseCallback : public Callback::Callback<DoorLockClusterClearAllRfidsResponseCallback>
{
public:
    CHIPDoorLockClusterClearAllRfidsResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearAllRfidsResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearAllRfidsResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearAllRfidsResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearAllRfidsResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearHolidayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterClearHolidayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterClearHolidayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearHolidayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearHolidayScheduleResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearHolidayScheduleResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearHolidayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearPinResponseCallback : public Callback::Callback<DoorLockClusterClearPinResponseCallback>
{
public:
    CHIPDoorLockClusterClearPinResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearPinResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearPinResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearPinResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearPinResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearRfidResponseCallback : public Callback::Callback<DoorLockClusterClearRfidResponseCallback>
{
public:
    CHIPDoorLockClusterClearRfidResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearRfidResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearRfidResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearRfidResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearRfidResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearWeekdayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterClearWeekdayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterClearWeekdayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearWeekdayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearWeekdayScheduleResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearWeekdayScheduleResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearYeardayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterClearYeardayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterClearYeardayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearYeardayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearYeardayScheduleResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearYeardayScheduleResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearYeardayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetHolidayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterGetHolidayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterGetHolidayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetHolidayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetHolidayScheduleResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t scheduleId, uint32_t localStartTime, uint32_t localEndTime,
                           uint8_t operatingModeDuringHoliday)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetHolidayScheduleResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetHolidayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(IJJI)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jlong>(localStartTime),
                            static_cast<jlong>(localEndTime), static_cast<jint>(operatingModeDuringHoliday));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetLogRecordResponseCallback : public Callback::Callback<DoorLockClusterGetLogRecordResponseCallback>
{
public:
    CHIPDoorLockClusterGetLogRecordResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetLogRecordResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetLogRecordResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t logEntryId, uint32_t timestamp, uint8_t eventType, uint8_t source,
                           uint8_t eventIdOrAlarmCode, uint16_t userId, uint8_t * pin)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetLogRecordResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString pinStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetLogRecordResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(IJIIIILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(logEntryId), static_cast<jlong>(timestamp),
                            static_cast<jint>(eventType), static_cast<jint>(source), static_cast<jint>(eventIdOrAlarmCode),
                            static_cast<jint>(userId), pinStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetPinResponseCallback : public Callback::Callback<DoorLockClusterGetPinResponseCallback>
{
public:
    CHIPDoorLockClusterGetPinResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetPinResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetPinResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t userId, uint8_t userStatus, uint8_t userType, uint8_t * pin)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetPinResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString pinStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetPinResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(IIILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userStatus),
                            static_cast<jint>(userType), pinStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetRfidResponseCallback : public Callback::Callback<DoorLockClusterGetRfidResponseCallback>
{
public:
    CHIPDoorLockClusterGetRfidResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetRfidResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetRfidResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t userId, uint8_t userStatus, uint8_t userType, uint8_t * rfid)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetRfidResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString rfidStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetRfidResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(IIILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userStatus),
                            static_cast<jint>(userType), rfidStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetUserTypeResponseCallback : public Callback::Callback<DoorLockClusterGetUserTypeResponseCallback>
{
public:
    CHIPDoorLockClusterGetUserTypeResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetUserTypeResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetUserTypeResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t userId, uint8_t userType)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetUserTypeResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetUserTypeResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userType));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetWeekdayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterGetWeekdayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterGetWeekdayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetWeekdayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetWeekdayScheduleResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t scheduleId, uint16_t userId, uint8_t daysMask, uint8_t startHour,
                           uint8_t startMinute, uint8_t endHour, uint8_t endMinute)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetWeekdayScheduleResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(IIIIIII)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(userId),
                            static_cast<jint>(daysMask), static_cast<jint>(startHour), static_cast<jint>(startMinute),
                            static_cast<jint>(endHour), static_cast<jint>(endMinute));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetYeardayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterGetYeardayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterGetYeardayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetYeardayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetYeardayScheduleResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t scheduleId, uint16_t userId, uint32_t localStartTime, uint32_t localEndTime)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetYeardayScheduleResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetYeardayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(IIJJ)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(userId),
                            static_cast<jlong>(localStartTime), static_cast<jlong>(localEndTime));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterLockDoorResponseCallback : public Callback::Callback<DoorLockClusterLockDoorResponseCallback>
{
public:
    CHIPDoorLockClusterLockDoorResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterLockDoorResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterLockDoorResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterLockDoorResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterLockDoorResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetHolidayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterSetHolidayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterSetHolidayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetHolidayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetHolidayScheduleResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetHolidayScheduleResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetHolidayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetPinResponseCallback : public Callback::Callback<DoorLockClusterSetPinResponseCallback>
{
public:
    CHIPDoorLockClusterSetPinResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetPinResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetPinResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetPinResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetPinResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetRfidResponseCallback : public Callback::Callback<DoorLockClusterSetRfidResponseCallback>
{
public:
    CHIPDoorLockClusterSetRfidResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetRfidResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetRfidResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetRfidResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetRfidResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetUserTypeResponseCallback : public Callback::Callback<DoorLockClusterSetUserTypeResponseCallback>
{
public:
    CHIPDoorLockClusterSetUserTypeResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetUserTypeResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetUserTypeResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetUserTypeResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetUserTypeResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetWeekdayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterSetWeekdayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterSetWeekdayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetWeekdayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetWeekdayScheduleResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetWeekdayScheduleResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetYeardayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterSetYeardayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterSetYeardayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetYeardayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetYeardayScheduleResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetYeardayScheduleResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetYeardayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterUnlockDoorResponseCallback : public Callback::Callback<DoorLockClusterUnlockDoorResponseCallback>
{
public:
    CHIPDoorLockClusterUnlockDoorResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterUnlockDoorResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterUnlockDoorResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterUnlockDoorResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterUnlockDoorResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterUnlockWithTimeoutResponseCallback
    : public Callback::Callback<DoorLockClusterUnlockWithTimeoutResponseCallback>
{
public:
    CHIPDoorLockClusterUnlockWithTimeoutResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterUnlockWithTimeoutResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterUnlockWithTimeoutResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterUnlockWithTimeoutResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralCommissioningClusterArmFailSafeResponseCallback
    : public Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback>
{
public:
    CHIPGeneralCommissioningClusterArmFailSafeResponseCallback(jobject javaCallback) :
        Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGeneralCommissioningClusterArmFailSafeResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGeneralCommissioningClusterArmFailSafeResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback
    : public Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback>
{
public:
    CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback(jobject javaCallback) :
        Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback
    : public Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>
{
public:
    CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback(jobject javaCallback) :
        Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterAddGroupResponseCallback : public Callback::Callback<GroupsClusterAddGroupResponseCallback>
{
public:
    CHIPGroupsClusterAddGroupResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterAddGroupResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterAddGroupResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t groupId)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterAddGroupResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterAddGroupResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(groupId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterGetGroupMembershipResponseCallback
    : public Callback::Callback<GroupsClusterGetGroupMembershipResponseCallback>
{
public:
    CHIPGroupsClusterGetGroupMembershipResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterGetGroupMembershipResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterGetGroupMembershipResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t capacity, uint8_t groupCount,
                           /* TYPE WARNING: array array defaults to */ uint8_t * groupList)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterGetGroupMembershipResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterGetGroupMembershipResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(capacity), static_cast<jint>(groupCount)
                            // groupList: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterRemoveGroupResponseCallback : public Callback::Callback<GroupsClusterRemoveGroupResponseCallback>
{
public:
    CHIPGroupsClusterRemoveGroupResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterRemoveGroupResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterRemoveGroupResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t groupId)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterRemoveGroupResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterRemoveGroupResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(groupId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterViewGroupResponseCallback : public Callback::Callback<GroupsClusterViewGroupResponseCallback>
{
public:
    CHIPGroupsClusterViewGroupResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterViewGroupResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterViewGroupResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t groupId, uint8_t * groupName)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterViewGroupResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString groupNameStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterViewGroupResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(groupId), groupNameStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPIdentifyClusterIdentifyQueryResponseCallback : public Callback::Callback<IdentifyClusterIdentifyQueryResponseCallback>
{
public:
    CHIPIdentifyClusterIdentifyQueryResponseCallback(jobject javaCallback) :
        Callback::Callback<IdentifyClusterIdentifyQueryResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPIdentifyClusterIdentifyQueryResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t timeout)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPIdentifyClusterIdentifyQueryResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPIdentifyClusterIdentifyQueryResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(timeout));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPKeypadInputClusterSendKeyResponseCallback : public Callback::Callback<KeypadInputClusterSendKeyResponseCallback>
{
public:
    CHIPKeypadInputClusterSendKeyResponseCallback(jobject javaCallback) :
        Callback::Callback<KeypadInputClusterSendKeyResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPKeypadInputClusterSendKeyResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPKeypadInputClusterSendKeyResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPKeypadInputClusterSendKeyResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaFastForwardResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaFastForwardResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaFastForwardResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaFastForwardResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaFastForwardResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaFastForwardResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaNextResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaNextResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaNextResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaNextResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaNextResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaNextResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaNextResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaPauseResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaPauseResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaPauseResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaPauseResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaPauseResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaPauseResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaPauseResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaPlayResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaPlayResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaPlayResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaPlayResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaPlayResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaPlayResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaPlayResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaPreviousResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaPreviousResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaPreviousResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaPreviousResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaPreviousResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaPreviousResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaPreviousResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaRewindResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaRewindResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaRewindResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaRewindResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaRewindResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaRewindResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaRewindResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaSkipBackwardResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaSkipBackwardResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaSkipForwardResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaSkipForwardResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaSkipSeekResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaSkipSeekResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaSkipSeekResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaSkipSeekResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaSkipSeekResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaSkipSeekResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaSkipSeekResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaStartOverResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaStartOverResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaStartOverResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaStartOverResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaStartOverResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaStartOverResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaStartOverResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaStopResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaStopResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaStopResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaStopResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaStopResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaStopResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaStopResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterAddThreadNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterAddThreadNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterAddWiFiNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterAddWiFiNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterDisableNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterDisableNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterDisableNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterDisableNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterDisableNetworkResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterDisableNetworkResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterEnableNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterEnableNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterEnableNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterEnableNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterEnableNetworkResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterEnableNetworkResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterRemoveNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterRemoveNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterScanNetworksResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterScanNetworksResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterScanNetworksResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText,
                           /* TYPE WARNING: array array defaults to */ uint8_t * wifiScanResults,
                           /* TYPE WARNING: array array defaults to */ uint8_t * threadScanResults)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterScanNetworksResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterScanNetworksResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue()
                            // wifiScanResults: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
                            // threadScanResults: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, uint8_t * debugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString debugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOperationalCredentialsClusterOpCSRResponseCallback
    : public Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback>
{
public:
    CHIPOperationalCredentialsClusterOpCSRResponseCallback(jobject javaCallback) :
        Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOperationalCredentialsClusterOpCSRResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, chip::ByteSpan CSR, chip::ByteSpan CSRNonce, chip::ByteSpan VendorReserved1,
                           chip::ByteSpan VendorReserved2, chip::ByteSpan VendorReserved3, chip::ByteSpan Signature)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOperationalCredentialsClusterOpCSRResponseCallback * cppCallback;
        jbyteArray CSRArr;
        jbyteArray CSRNonceArr;
        jbyteArray VendorReserved1Arr;
        jbyteArray VendorReserved2Arr;
        jbyteArray VendorReserved3Arr;
        jbyteArray SignatureArr;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOperationalCredentialsClusterOpCSRResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        CSRArr = env->NewByteArray(CSR.size());
        VerifyOrExit(CSRArr != NULL, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(CSRArr, 0, CSR.size(), (jbyte *) CSR.data());
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);
        CSRNonceArr = env->NewByteArray(CSRNonce.size());
        VerifyOrExit(CSRNonceArr != NULL, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(CSRNonceArr, 0, CSRNonce.size(), (jbyte *) CSRNonce.data());
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);
        VendorReserved1Arr = env->NewByteArray(VendorReserved1.size());
        VerifyOrExit(VendorReserved1Arr != NULL, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(VendorReserved1Arr, 0, VendorReserved1.size(), (jbyte *) VendorReserved1.data());
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);
        VendorReserved2Arr = env->NewByteArray(VendorReserved2.size());
        VerifyOrExit(VendorReserved2Arr != NULL, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(VendorReserved2Arr, 0, VendorReserved2.size(), (jbyte *) VendorReserved2.data());
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);
        VendorReserved3Arr = env->NewByteArray(VendorReserved3.size());
        VerifyOrExit(VendorReserved3Arr != NULL, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(VendorReserved3Arr, 0, VendorReserved3.size(), (jbyte *) VendorReserved3.data());
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);
        SignatureArr = env->NewByteArray(Signature.size());
        VerifyOrExit(SignatureArr != NULL, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(SignatureArr, 0, Signature.size(), (jbyte *) Signature.data());
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, CSRArr, CSRNonceArr, VendorReserved1Arr, VendorReserved2Arr,
                            VendorReserved3Arr, SignatureArr);

        env->DeleteLocalRef(CSRArr);
        env->DeleteLocalRef(CSRNonceArr);
        env->DeleteLocalRef(VendorReserved1Arr);
        env->DeleteLocalRef(VendorReserved2Arr);
        env->DeleteLocalRef(VendorReserved3Arr);
        env->DeleteLocalRef(SignatureArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOperationalCredentialsClusterOpCertResponseCallback
    : public Callback::Callback<OperationalCredentialsClusterOpCertResponseCallback>
{
public:
    CHIPOperationalCredentialsClusterOpCertResponseCallback(jobject javaCallback) :
        Callback::Callback<OperationalCredentialsClusterOpCertResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOperationalCredentialsClusterOpCertResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t StatusCode, uint64_t FabricIndex, uint8_t * DebugText)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOperationalCredentialsClusterOpCertResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString DebugTextStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOperationalCredentialsClusterOpCertResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(IJLjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(StatusCode), static_cast<jlong>(FabricIndex),
                            DebugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOperationalCredentialsClusterSetFabricResponseCallback
    : public Callback::Callback<OperationalCredentialsClusterSetFabricResponseCallback>
{
public:
    CHIPOperationalCredentialsClusterSetFabricResponseCallback(jobject javaCallback) :
        Callback::Callback<OperationalCredentialsClusterSetFabricResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOperationalCredentialsClusterSetFabricResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, chip::FabricId FabricId)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOperationalCredentialsClusterSetFabricResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOperationalCredentialsClusterSetFabricResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(J)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jlong>(FabricId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterAddSceneResponseCallback : public Callback::Callback<ScenesClusterAddSceneResponseCallback>
{
public:
    CHIPScenesClusterAddSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterAddSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterAddSceneResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t groupId, uint8_t sceneId)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterAddSceneResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterAddSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(groupId), static_cast<jint>(sceneId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterGetSceneMembershipResponseCallback
    : public Callback::Callback<ScenesClusterGetSceneMembershipResponseCallback>
{
public:
    CHIPScenesClusterGetSceneMembershipResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterGetSceneMembershipResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterGetSceneMembershipResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t capacity, uint16_t groupId, uint8_t sceneCount,
                           /* TYPE WARNING: array array defaults to */ uint8_t * sceneList)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterGetSceneMembershipResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterGetSceneMembershipResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(III)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(capacity), static_cast<jint>(groupId),
                            static_cast<jint>(sceneCount)
                            // sceneList: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterRemoveAllScenesResponseCallback : public Callback::Callback<ScenesClusterRemoveAllScenesResponseCallback>
{
public:
    CHIPScenesClusterRemoveAllScenesResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterRemoveAllScenesResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterRemoveAllScenesResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t groupId)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterRemoveAllScenesResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterRemoveAllScenesResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(groupId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterRemoveSceneResponseCallback : public Callback::Callback<ScenesClusterRemoveSceneResponseCallback>
{
public:
    CHIPScenesClusterRemoveSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterRemoveSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterRemoveSceneResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t groupId, uint8_t sceneId)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterRemoveSceneResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterRemoveSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(groupId), static_cast<jint>(sceneId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterStoreSceneResponseCallback : public Callback::Callback<ScenesClusterStoreSceneResponseCallback>
{
public:
    CHIPScenesClusterStoreSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterStoreSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterStoreSceneResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t groupId, uint8_t sceneId)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterStoreSceneResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterStoreSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(groupId), static_cast<jint>(sceneId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterViewSceneResponseCallback : public Callback::Callback<ScenesClusterViewSceneResponseCallback>
{
public:
    CHIPScenesClusterViewSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterViewSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterViewSceneResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t groupId, uint8_t sceneId, uint16_t transitionTime, uint8_t * sceneName,
                           /* TYPE WARNING: array array defaults to */ uint8_t * extensionFieldSets)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterViewSceneResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString sceneNameStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterViewSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(IIILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(groupId), static_cast<jint>(sceneId),
                            static_cast<jint>(transitionTime), sceneNameStr.jniValue()
                            // extensionFieldSets: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTvChannelClusterChangeChannelResponseCallback : public Callback::Callback<TvChannelClusterChangeChannelResponseCallback>
{
public:
    CHIPTvChannelClusterChangeChannelResponseCallback(jobject javaCallback) :
        Callback::Callback<TvChannelClusterChangeChannelResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTvChannelClusterChangeChannelResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, /* TYPE WARNING: array array defaults to */ uint8_t * ChannelMatch, uint8_t ErrorType)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTvChannelClusterChangeChannelResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTvChannelClusterChangeChannelResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef,
                            javaMethod
                            // ChannelMatch: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
                            ,
                            static_cast<jint>(ErrorType));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTargetNavigatorClusterNavigateTargetResponseCallback
    : public Callback::Callback<TargetNavigatorClusterNavigateTargetResponseCallback>
{
public:
    CHIPTargetNavigatorClusterNavigateTargetResponseCallback(jobject javaCallback) :
        Callback::Callback<TargetNavigatorClusterNavigateTargetResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTargetNavigatorClusterNavigateTargetResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t * data)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTargetNavigatorClusterNavigateTargetResponseCallback * cppCallback;
        // ByteSpan is not properly returned yet, temporarily use empty string
        UtfString dataStr(env, "");

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTargetNavigatorClusterNavigateTargetResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, dataStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterClusterTestSpecificResponseCallback : public Callback::Callback<TestClusterClusterTestSpecificResponseCallback>
{
public:
    CHIPTestClusterClusterTestSpecificResponseCallback(jobject javaCallback) :
        Callback::Callback<TestClusterClusterTestSpecificResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTestClusterClusterTestSpecificResponseCallback()
    {
        JNIEnv * env = GetEnvForCurrentThread();
        if (env == NULL)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t returnValue)
    {
        StackUnlockGuard unlockGuard(GetStackLock());
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTestClusterClusterTestSpecificResponseCallback * cppCallback;

        VerifyOrExit(env != NULL, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTestClusterClusterTestSpecificResponseCallback *>(context);
        VerifyOrExit(cppCallback != NULL, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != NULL, err = CHIP_NO_ERROR);

        err = FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(returnValue));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %d", err);
        }
    }

private:
    jobject javaCallbackRef;
};

JNI_METHOD(void, BaseChipCluster, deleteCluster)(JNIEnv * env, jobject self, jlong clusterPtr)
{
    ClusterBase * cluster = reinterpret_cast<ClusterBase *>(clusterPtr);
    if (cluster != NULL)
    {
        delete cluster;
    }
}

JNI_METHOD(jlong, AccountLoginCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    AccountLoginCluster * cppCluster = new AccountLoginCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AccountLoginCluster, getSetupPIN)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster;

    JniUtfString tempAccountIdentifierStr(env, tempAccountIdentifier);
    CHIPAccountLoginClusterGetSetupPINResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPAccountLoginClusterGetSetupPINResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->GetSetupPIN(onSuccess->Cancel(), onFailure->Cancel(),
                                chip::ByteSpan((const uint8_t *) tempAccountIdentifier, strlen(tempAccountIdentifierStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, AccountLoginCluster, login)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier, jstring setupPIN)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster;

    JniUtfString tempAccountIdentifierStr(env, tempAccountIdentifier);
    JniUtfString setupPINStr(env, setupPIN);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Login(onSuccess->Cancel(), onFailure->Cancel(),
                            chip::ByteSpan((const uint8_t *) tempAccountIdentifier, strlen(tempAccountIdentifierStr.c_str())),
                            chip::ByteSpan((const uint8_t *) setupPIN, strlen(setupPINStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, ApplicationBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    ApplicationBasicCluster * cppCluster = new ApplicationBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, ApplicationLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    ApplicationLauncherCluster * cppCluster = new ApplicationLauncherCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationLauncherCluster, launchApp)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring data, jint catalogVendorId, jstring applicationId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster;

    JniUtfString dataStr(env, data);
    JniUtfString applicationIdStr(env, applicationId);
    CHIPApplicationLauncherClusterLaunchAppResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPApplicationLauncherClusterLaunchAppResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LaunchApp(onSuccess->Cancel(), onFailure->Cancel(),
                                chip::ByteSpan((const uint8_t *) data, strlen(dataStr.c_str())), catalogVendorId,
                                chip::ByteSpan((const uint8_t *) applicationId, strlen(applicationIdStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, AudioOutputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    AudioOutputCluster * cppCluster = new AudioOutputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AudioOutputCluster, renameOutput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index, jstring name)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster;

    JniUtfString nameStr(env, name);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RenameOutput(onSuccess->Cancel(), onFailure->Cancel(), index,
                                   chip::ByteSpan((const uint8_t *) name, strlen(nameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, AudioOutputCluster, selectOutput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SelectOutput(onSuccess->Cancel(), onFailure->Cancel(), index);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, BarrierControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    BarrierControlCluster * cppCluster = new BarrierControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BarrierControlCluster, barrierControlGoToPercent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint percentOpen)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->BarrierControlGoToPercent(onSuccess->Cancel(), onFailure->Cancel(), percentOpen);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, BarrierControlCluster, barrierControlStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->BarrierControlStop(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, BasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    BasicCluster * cppCluster = new BasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BasicCluster, mfgSpecificPing)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    BasicCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MfgSpecificPing(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, BinaryInputBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    BinaryInputBasicCluster * cppCluster = new BinaryInputBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, BindingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    BindingCluster * cppCluster = new BindingCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BindingCluster, bind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong nodeId, jint groupId, jint endpointId, jint clusterId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    BindingCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Bind(onSuccess->Cancel(), onFailure->Cancel(), nodeId, groupId, endpointId, clusterId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, BindingCluster, unbind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong nodeId, jint groupId, jint endpointId, jint clusterId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    BindingCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Unbind(onSuccess->Cancel(), onFailure->Cancel(), nodeId, groupId, endpointId, clusterId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, BridgedDeviceBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    BridgedDeviceBasicCluster * cppCluster = new BridgedDeviceBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, ColorControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    ColorControlCluster * cppCluster = new ColorControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ColorControlCluster, moveColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint rateX, jint rateY, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveColor(onSuccess->Cancel(), onFailure->Cancel(), rateX, rateY, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint colorTemperatureMinimum,
 jint colorTemperatureMaximum, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveColorTemperature(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate, colorTemperatureMinimum,
                                           colorTemperatureMaximum, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveHue(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveSaturation(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveToColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint colorX, jint colorY, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToColor(onSuccess->Cancel(), onFailure->Cancel(), colorX, colorY, transitionTime, optionsMask,
                                  optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveToColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint colorTemperature, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToColorTemperature(onSuccess->Cancel(), onFailure->Cancel(), colorTemperature, transitionTime,
                                             optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint hue, jint direction, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToHue(onSuccess->Cancel(), onFailure->Cancel(), hue, direction, transitionTime, optionsMask,
                                optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint hue, jint saturation, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToHueAndSaturation(onSuccess->Cancel(), onFailure->Cancel(), hue, saturation, transitionTime, optionsMask,
                                             optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, moveToSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint saturation, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToSaturation(onSuccess->Cancel(), onFailure->Cancel(), saturation, transitionTime, optionsMask,
                                       optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, stepColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepX, jint stepY, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->StepColor(onSuccess->Cancel(), onFailure->Cancel(), stepX, stepY, transitionTime, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, stepColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint colorTemperatureMinimum, jint colorTemperatureMaximum, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepColorTemperature(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime,
                                           colorTemperatureMinimum, colorTemperatureMaximum, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, stepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepHue(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime, optionsMask,
                              optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, stepSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepSaturation(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime, optionsMask,
                                     optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ColorControlCluster, stopMoveStep)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint optionsMask, jint optionsOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StopMoveStep(onSuccess->Cancel(), onFailure->Cancel(), optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, ContentLaunchCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    ContentLaunchCluster * cppCluster = new ContentLaunchCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ContentLaunchCluster, launchContent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint autoPlay, jstring data)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ContentLaunchCluster * cppCluster;

    JniUtfString dataStr(env, data);
    CHIPContentLaunchClusterLaunchContentResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ContentLaunchCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPContentLaunchClusterLaunchContentResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LaunchContent(onSuccess->Cancel(), onFailure->Cancel(), autoPlay,
                                    chip::ByteSpan((const uint8_t *) data, strlen(dataStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ContentLaunchCluster, launchURL)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring contentURL, jstring displayString)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ContentLaunchCluster * cppCluster;

    JniUtfString contentURLStr(env, contentURL);
    JniUtfString displayStringStr(env, displayString);
    CHIPContentLaunchClusterLaunchURLResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ContentLaunchCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPContentLaunchClusterLaunchURLResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LaunchURL(onSuccess->Cancel(), onFailure->Cancel(),
                                chip::ByteSpan((const uint8_t *) contentURL, strlen(contentURLStr.c_str())),
                                chip::ByteSpan((const uint8_t *) displayString, strlen(displayStringStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, DescriptorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    DescriptorCluster * cppCluster = new DescriptorCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, DoorLockCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    DoorLockCluster * cppCluster = new DoorLockCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DoorLockCluster, clearAllPins)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearAllPinsResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearAllPinsResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearAllPins(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearAllRfids)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearAllRfidsResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearAllRfidsResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearAllRfids(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearHolidayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearHolidayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearHolidaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearPin)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearPinResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearPinResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearPin(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearRfid)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearRfidResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearRfidResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearRfid(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearWeekdayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearWeekdayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearWeekdaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, clearYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterClearYeardayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterClearYeardayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearYeardaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetHolidayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetHolidayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetHolidaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getLogRecord)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint logIndex)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetLogRecordResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetLogRecordResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetLogRecord(onSuccess->Cancel(), onFailure->Cancel(), logIndex);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getPin)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetPinResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetPinResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetPin(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getRfid)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetRfidResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetRfidResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetRfid(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getUserType)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetUserTypeResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetUserTypeResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetUserType(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetWeekdayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetWeekdayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetWeekdaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, getYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterGetYeardayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterGetYeardayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetYeardaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, lockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring pin)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniUtfString pinStr(env, pin);
    CHIPDoorLockClusterLockDoorResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterLockDoorResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LockDoor(onSuccess->Cancel(), onFailure->Cancel(),
                               chip::ByteSpan((const uint8_t *) pin, strlen(pinStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jlong localStartTime, jlong localEndTime,
 jint operatingModeDuringHoliday)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterSetHolidayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetHolidayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetHolidaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, localStartTime, localEndTime,
                                         operatingModeDuringHoliday);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setPin)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userStatus, jint userType, jstring pin)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniUtfString pinStr(env, pin);
    CHIPDoorLockClusterSetPinResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetPinResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetPin(onSuccess->Cancel(), onFailure->Cancel(), userId, userStatus, userType,
                             chip::ByteSpan((const uint8_t *) pin, strlen(pinStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setRfid)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userStatus, jint userType, jstring id)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniUtfString idStr(env, id);
    CHIPDoorLockClusterSetRfidResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetRfidResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetRfid(onSuccess->Cancel(), onFailure->Cancel(), userId, userStatus, userType,
                              chip::ByteSpan((const uint8_t *) id, strlen(idStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setUserType)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userType)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterSetUserTypeResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetUserTypeResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetUserType(onSuccess->Cancel(), onFailure->Cancel(), userId, userType);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId, jint daysMask, jint startHour,
 jint startMinute, jint endHour, jint endMinute)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterSetWeekdayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetWeekdayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetWeekdaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId, daysMask, startHour,
                                         startMinute, endHour, endMinute);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, setYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId, jlong localStartTime,
 jlong localEndTime)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    CHIPDoorLockClusterSetYeardayScheduleResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterSetYeardayScheduleResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->SetYeardaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId, localStartTime, localEndTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, unlockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring pin)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniUtfString pinStr(env, pin);
    CHIPDoorLockClusterUnlockDoorResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterUnlockDoorResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UnlockDoor(onSuccess->Cancel(), onFailure->Cancel(),
                                 chip::ByteSpan((const uint8_t *) pin, strlen(pinStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, DoorLockCluster, unlockWithTimeout)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint timeoutInSeconds, jstring pin)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniUtfString pinStr(env, pin);
    CHIPDoorLockClusterUnlockWithTimeoutResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDoorLockClusterUnlockWithTimeoutResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UnlockWithTimeout(onSuccess->Cancel(), onFailure->Cancel(), timeoutInSeconds,
                                        chip::ByteSpan((const uint8_t *) pin, strlen(pinStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, EthernetNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    EthernetNetworkDiagnosticsCluster * cppCluster = new EthernetNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResetCounts(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, FixedLabelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    FixedLabelCluster * cppCluster = new FixedLabelCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GeneralCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    GeneralCommissioningCluster * cppCluster = new GeneralCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GeneralCommissioningCluster, armFailSafe)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint expiryLengthSeconds, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    CHIPGeneralCommissioningClusterArmFailSafeResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGeneralCommissioningClusterArmFailSafeResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ArmFailSafe(onSuccess->Cancel(), onFailure->Cancel(), expiryLengthSeconds, breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GeneralCommissioningCluster, commissioningComplete)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->CommissioningComplete(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GeneralCommissioningCluster, setRegulatoryConfig)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint location, jstring countryCode, jlong breadcrumb,
 jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    JniUtfString countryCodeStr(env, countryCode);
    CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetRegulatoryConfig(onSuccess->Cancel(), onFailure->Cancel(), location,
                                          chip::ByteSpan((const uint8_t *) countryCode, strlen(countryCodeStr.c_str())), breadcrumb,
                                          timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, GeneralDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    GeneralDiagnosticsCluster * cppCluster = new GeneralDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GroupKeyManagementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    GroupKeyManagementCluster * cppCluster = new GroupKeyManagementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GroupsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    GroupsCluster * cppCluster = new GroupsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GroupsCluster, addGroup)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jstring groupName)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    JniUtfString groupNameStr(env, groupName);
    CHIPGroupsClusterAddGroupResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGroupsClusterAddGroupResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddGroup(onSuccess->Cancel(), onFailure->Cancel(), groupId,
                               chip::ByteSpan((const uint8_t *) groupName, strlen(groupNameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GroupsCluster, addGroupIfIdentifying)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jstring groupName)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    JniUtfString groupNameStr(env, groupName);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddGroupIfIdentifying(onSuccess->Cancel(), onFailure->Cancel(), groupId,
                                            chip::ByteSpan((const uint8_t *) groupName, strlen(groupNameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GroupsCluster, getGroupMembership)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupCount, jint groupList)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    CHIPGroupsClusterGetGroupMembershipResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGroupsClusterGetGroupMembershipResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetGroupMembership(onSuccess->Cancel(), onFailure->Cancel(), groupCount, groupList);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GroupsCluster, removeAllGroups)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveAllGroups(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GroupsCluster, removeGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    CHIPGroupsClusterRemoveGroupResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGroupsClusterRemoveGroupResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveGroup(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, GroupsCluster, viewGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    CHIPGroupsClusterViewGroupResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPGroupsClusterViewGroupResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ViewGroup(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, IdentifyCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    IdentifyCluster * cppCluster = new IdentifyCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, IdentifyCluster, identify)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint identifyTime)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Identify(onSuccess->Cancel(), onFailure->Cancel(), identifyTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, IdentifyCluster, identifyQuery)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    CHIPIdentifyClusterIdentifyQueryResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPIdentifyClusterIdentifyQueryResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->IdentifyQuery(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, KeypadInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    KeypadInputCluster * cppCluster = new KeypadInputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, KeypadInputCluster, sendKey)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint keyCode)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    KeypadInputCluster * cppCluster;

    CHIPKeypadInputClusterSendKeyResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<KeypadInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPKeypadInputClusterSendKeyResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SendKey(onSuccess->Cancel(), onFailure->Cancel(), keyCode);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, LevelControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    LevelControlCluster * cppCluster = new LevelControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LevelControlCluster, move)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionMask, jint optionOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Move(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate, optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, moveToLevel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint level, jint transitionTime, jint optionMask,
 jint optionOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToLevel(onSuccess->Cancel(), onFailure->Cancel(), level, transitionTime, optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, moveToLevelWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint level, jint transitionTime)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToLevelWithOnOff(onSuccess->Cancel(), onFailure->Cancel(), level, transitionTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, moveWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveWithOnOff(onSuccess->Cancel(), onFailure->Cancel(), moveMode, rate);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, step)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime, jint optionMask,
 jint optionOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->Step(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime, optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, stepWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepWithOnOff(onSuccess->Cancel(), onFailure->Cancel(), stepMode, stepSize, transitionTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, stop)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint optionMask, jint optionOverride)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Stop(onSuccess->Cancel(), onFailure->Cancel(), optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, LevelControlCluster, stopWithOnOff)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StopWithOnOff(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, LowPowerCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    LowPowerCluster * cppCluster = new LowPowerCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LowPowerCluster, sleep)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    LowPowerCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<LowPowerCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Sleep(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, MediaInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    MediaInputCluster * cppCluster = new MediaInputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaInputCluster, hideInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->HideInputStatus(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaInputCluster, renameInput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index, jstring name)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    JniUtfString nameStr(env, name);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RenameInput(onSuccess->Cancel(), onFailure->Cancel(), index,
                                  chip::ByteSpan((const uint8_t *) name, strlen(nameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaInputCluster, selectInput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SelectInput(onSuccess->Cancel(), onFailure->Cancel(), index);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaInputCluster, showInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ShowInputStatus(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, MediaPlaybackCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    MediaPlaybackCluster * cppCluster = new MediaPlaybackCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaPlaybackCluster, mediaFastForward)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaFastForwardResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaFastForwardResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaFastForward(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaNext)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaNextResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaNextResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaNext(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPause)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaPauseResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaPauseResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaPause(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPlay)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaPlayResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaPlayResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaPlay(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPrevious)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaPreviousResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaPreviousResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaPrevious(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaRewind)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaRewindResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaRewindResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaRewind(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipBackward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong deltaPositionMilliseconds)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaSkipBackward(onSuccess->Cancel(), onFailure->Cancel(), deltaPositionMilliseconds);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipForward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong deltaPositionMilliseconds)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaSkipForward(onSuccess->Cancel(), onFailure->Cancel(), deltaPositionMilliseconds);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipSeek)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong position)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaSkipSeekResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaSkipSeekResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaSkipSeek(onSuccess->Cancel(), onFailure->Cancel(), position);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStartOver)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaStartOverResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaStartOverResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaStartOver(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    CHIPMediaPlaybackClusterMediaStopResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPMediaPlaybackClusterMediaStopResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaStop(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, NetworkCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    NetworkCommissioningCluster * cppCluster = new NetworkCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, NetworkCommissioningCluster, addThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray operationalDatasetArr(env, operationalDataset);
    CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddThreadNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                       chip::ByteSpan((const uint8_t *) operationalDatasetArr.data(), operationalDatasetArr.size()),
                                       breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, addWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jlong breadcrumb,
 jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray ssidArr(env, ssid);
    JniByteArray credentialsArr(env, credentials);
    CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddWiFiNetwork(
        onSuccess->Cancel(), onFailure->Cancel(), chip::ByteSpan((const uint8_t *) ssidArr.data(), ssidArr.size()),
        chip::ByteSpan((const uint8_t *) credentialsArr.data(), credentialsArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, disableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray networkIDArr(env, networkID);
    CHIPNetworkCommissioningClusterDisableNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterDisableNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->DisableNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                     chip::ByteSpan((const uint8_t *) networkIDArr.data(), networkIDArr.size()), breadcrumb,
                                     timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, enableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray networkIDArr(env, networkID);
    CHIPNetworkCommissioningClusterEnableNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterEnableNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnableNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                    chip::ByteSpan((const uint8_t *) networkIDArr.data(), networkIDArr.size()), breadcrumb,
                                    timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, getLastNetworkCommissioningResult)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetLastNetworkCommissioningResult(onSuccess->Cancel(), onFailure->Cancel(), timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, removeNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray networkIDArr(env, networkID);
    CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                    chip::ByteSpan((const uint8_t *) networkIDArr.data(), networkIDArr.size()), breadcrumb,
                                    timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, scanNetworks)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray ssidArr(env, ssid);
    CHIPNetworkCommissioningClusterScanNetworksResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterScanNetworksResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ScanNetworks(onSuccess->Cancel(), onFailure->Cancel(),
                                   chip::ByteSpan((const uint8_t *) ssidArr.data(), ssidArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, updateThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jlong breadcrumb, jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray operationalDatasetArr(env, operationalDataset);
    CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateThreadNetwork(
        onSuccess->Cancel(), onFailure->Cancel(),
        chip::ByteSpan((const uint8_t *) operationalDatasetArr.data(), operationalDatasetArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, updateWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jlong breadcrumb,
 jlong timeoutMs)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray ssidArr(env, ssid);
    JniByteArray credentialsArr(env, credentials);
    CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateWiFiNetwork(
        onSuccess->Cancel(), onFailure->Cancel(), chip::ByteSpan((const uint8_t *) ssidArr.data(), ssidArr.size()),
        chip::ByteSpan((const uint8_t *) credentialsArr.data(), credentialsArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, OnOffCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    OnOffCluster * cppCluster = new OnOffCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffCluster, off)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Off(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OnOffCluster, on)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->On(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OnOffCluster, toggle)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Toggle(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, OperationalCredentialsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    OperationalCredentialsCluster * cppCluster = new OperationalCredentialsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OperationalCredentialsCluster, addOpCert)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray noc, jbyteArray iCACertificate, jbyteArray iPKValue,
 jlong caseAdminNode, jint adminVendorId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray nocArr(env, noc);
    JniByteArray iCACertificateArr(env, iCACertificate);
    JniByteArray iPKValueArr(env, iPKValue);
    CHIPOperationalCredentialsClusterOpCertResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOperationalCredentialsClusterOpCertResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddOpCert(
        onSuccess->Cancel(), onFailure->Cancel(), chip::ByteSpan((const uint8_t *) nocArr.data(), nocArr.size()),
        chip::ByteSpan((const uint8_t *) iCACertificateArr.data(), iCACertificateArr.size()),
        chip::ByteSpan((const uint8_t *) iPKValueArr.data(), iPKValueArr.size()), caseAdminNode, adminVendorId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, opCSRRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray cSRNonce)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray cSRNonceArr(env, cSRNonce);
    CHIPOperationalCredentialsClusterOpCSRResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOperationalCredentialsClusterOpCSRResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OpCSRRequest(onSuccess->Cancel(), onFailure->Cancel(),
                                   chip::ByteSpan((const uint8_t *) cSRNonceArr.data(), cSRNonceArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, removeAllFabrics)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveAllFabrics(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, removeFabric)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong fabricId, jlong nodeId, jint vendorId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    CHIPOperationalCredentialsClusterOpCertResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOperationalCredentialsClusterOpCertResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveFabric(onSuccess->Cancel(), onFailure->Cancel(), fabricId, nodeId, vendorId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, setFabric)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint vendorId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    CHIPOperationalCredentialsClusterSetFabricResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOperationalCredentialsClusterSetFabricResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetFabric(onSuccess->Cancel(), onFailure->Cancel(), vendorId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, updateFabricLabel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring label)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniUtfString labelStr(env, label);
    CHIPOperationalCredentialsClusterOpCertResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPOperationalCredentialsClusterOpCertResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateFabricLabel(onSuccess->Cancel(), onFailure->Cancel(),
                                        chip::ByteSpan((const uint8_t *) label, strlen(labelStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, PumpConfigurationAndControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    PumpConfigurationAndControlCluster * cppCluster = new PumpConfigurationAndControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, RelativeHumidityMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    RelativeHumidityMeasurementCluster * cppCluster = new RelativeHumidityMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, ScenesCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    ScenesCluster * cppCluster = new ScenesCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ScenesCluster, addScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId, jint transitionTime, jstring sceneName,
 jint clusterId, jint length, jint value)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    JniUtfString sceneNameStr(env, sceneName);
    CHIPScenesClusterAddSceneResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterAddSceneResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId, transitionTime,
                               chip::ByteSpan((const uint8_t *) sceneName, strlen(sceneNameStr.c_str())), clusterId, length, value);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, getSceneMembership)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPScenesClusterGetSceneMembershipResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterGetSceneMembershipResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetSceneMembership(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, recallScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId, jint transitionTime)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RecallScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId, transitionTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, removeAllScenes)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPScenesClusterRemoveAllScenesResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterRemoveAllScenesResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveAllScenes(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, removeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPScenesClusterRemoveSceneResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterRemoveSceneResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, storeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPScenesClusterStoreSceneResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterStoreSceneResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StoreScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ScenesCluster, viewScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    CHIPScenesClusterViewSceneResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPScenesClusterViewSceneResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ViewScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, SoftwareDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    SoftwareDiagnosticsCluster * cppCluster = new SoftwareDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, resetWatermarks)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResetWatermarks(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, SwitchCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    SwitchCluster * cppCluster = new SwitchCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, TvChannelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    TvChannelCluster * cppCluster = new TvChannelCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TvChannelCluster, changeChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring match)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    JniUtfString matchStr(env, match);
    CHIPTvChannelClusterChangeChannelResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPTvChannelClusterChangeChannelResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ChangeChannel(onSuccess->Cancel(), onFailure->Cancel(),
                                    chip::ByteSpan((const uint8_t *) match, strlen(matchStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TvChannelCluster, changeChannelByNumber)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint majorNumber, jint minorNumber)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ChangeChannelByNumber(onSuccess->Cancel(), onFailure->Cancel(), majorNumber, minorNumber);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TvChannelCluster, skipChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint count)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SkipChannel(onSuccess->Cancel(), onFailure->Cancel(), count);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, TargetNavigatorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    TargetNavigatorCluster * cppCluster = new TargetNavigatorCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TargetNavigatorCluster, navigateTarget)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint target, jstring data)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TargetNavigatorCluster * cppCluster;

    JniUtfString dataStr(env, data);
    CHIPTargetNavigatorClusterNavigateTargetResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TargetNavigatorCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPTargetNavigatorClusterNavigateTargetResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->NavigateTarget(onSuccess->Cancel(), onFailure->Cancel(), target,
                                     chip::ByteSpan((const uint8_t *) data, strlen(dataStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, TemperatureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    TemperatureMeasurementCluster * cppCluster = new TemperatureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, TestClusterCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    TestClusterCluster * cppCluster = new TestClusterCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TestClusterCluster, test)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Test(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TestClusterCluster, testNotHandled)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestNotHandled(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TestClusterCluster, testSpecific)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    CHIPTestClusterClusterTestSpecificResponseCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPTestClusterClusterTestSpecificResponseCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestSpecific(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TestClusterCluster, testUnknownCommand)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestUnknownCommand(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, ThermostatCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    ThermostatCluster * cppCluster = new ThermostatCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatCluster, clearWeeklySchedule)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearWeeklySchedule(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ThermostatCluster, getRelayStatusLog)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetRelayStatusLog(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ThermostatCluster, getWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint daysToReturn, jint modeToReturn)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetWeeklySchedule(onSuccess->Cancel(), onFailure->Cancel(), daysToReturn, modeToReturn);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ThermostatCluster, setWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint numberOfTransitionsForSequence, jint dayOfWeekForSequence,
 jint modeForSequence, jint payload)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetWeeklySchedule(onSuccess->Cancel(), onFailure->Cancel(), numberOfTransitionsForSequence,
                                        dayOfWeekForSequence, modeForSequence, payload);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, ThermostatCluster, setpointRaiseLower)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint mode, jint amount)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetpointRaiseLower(onSuccess->Cancel(), onFailure->Cancel(), mode, amount);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, TrustedRootCertificatesCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    TrustedRootCertificatesCluster * cppCluster = new TrustedRootCertificatesCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TrustedRootCertificatesCluster, addTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray rootCertificate)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TrustedRootCertificatesCluster * cppCluster;

    JniByteArray rootCertificateArr(env, rootCertificate);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TrustedRootCertificatesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddTrustedRootCertificate(
        onSuccess->Cancel(), onFailure->Cancel(),
        chip::ByteSpan((const uint8_t *) rootCertificateArr.data(), rootCertificateArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, TrustedRootCertificatesCluster, removeTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray trustedRootIdentifier)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    TrustedRootCertificatesCluster * cppCluster;

    JniByteArray trustedRootIdentifierArr(env, trustedRootIdentifier);
    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<TrustedRootCertificatesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveTrustedRootCertificate(
        onSuccess->Cancel(), onFailure->Cancel(),
        chip::ByteSpan((const uint8_t *) trustedRootIdentifierArr.data(), trustedRootIdentifierArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(jlong, WakeOnLanCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    WakeOnLanCluster * cppCluster = new WakeOnLanCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, WindowCoveringCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    // TODO locking?
    WindowCoveringCluster * cppCluster = new WindowCoveringCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WindowCoveringCluster, windowCoveringDownClose)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->WindowCoveringDownClose(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, windowCoveringGoToLiftPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint percentageLiftValue)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->WindowCoveringGoToLiftPercentage(onSuccess->Cancel(), onFailure->Cancel(), percentageLiftValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, windowCoveringGoToLiftValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint liftValue)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->WindowCoveringGoToLiftValue(onSuccess->Cancel(), onFailure->Cancel(), liftValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, windowCoveringGoToTiltPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint percentageTiltValue)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->WindowCoveringGoToTiltPercentage(onSuccess->Cancel(), onFailure->Cancel(), percentageTiltValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, windowCoveringGoToTiltValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint tiltValue)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->WindowCoveringGoToTiltValue(onSuccess->Cancel(), onFailure->Cancel(), tiltValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, windowCoveringStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->WindowCoveringStop(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
JNI_METHOD(void, WindowCoveringCluster, windowCoveringUpOpen)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    StackLockGuard lock(GetStackLock());
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    CHIPDefaultSuccessCallback * onSuccess;
    CHIPDefaultFailureCallback * onFailure;

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    onSuccess = new CHIPDefaultSuccessCallback(callback);
    VerifyOrExit(onSuccess != NULL, err = CHIP_ERROR_INCORRECT_STATE);
    onFailure = new CHIPDefaultFailureCallback(callback);
    VerifyOrExit(onFailure != NULL, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->WindowCoveringUpOpen(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        delete onSuccess;
        delete onFailure;

        jthrowable exception;
        jmethodID method;

        err = FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }

        err = CreateIllegalStateException(env, "Error invoking cluster", err, exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %d", err);
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
}
