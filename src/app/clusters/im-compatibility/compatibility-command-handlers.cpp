/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP


#include <cstdint>
#include <cinttypes>

#include <gen/af-structs.h>
#include <gen/call-command-handler.h>
#include <gen/callback.h>
#include <gen/cluster-id.h>
#include <gen/command-id.h>
#include <util.h>

#include <app/InteractionModelEngine.h>
#include <gen/IMClusterCommandHandler.h>

namespace chip {
namespace app {

// Cluster specific command parsing
// TODO: Take care of internal status of ember library.

namespace clusters {

namespace BarrierControl {
#if IM_HAVE_BARRIER_CONTROL_CLUSTER_BARRIER_CONTROL_GO_TO_PERCENT_COMMAND
void OnBarrierControlGoToPercentCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t percentOpen)
{
    emberAfBarrierControlClusterBarrierControlGoToPercentCallback(percentOpen);
}
#endif

#if IM_HAVE_BARRIER_CONTROL_CLUSTER_BARRIER_CONTROL_STOP_COMMAND
void OnBarrierControlStopCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfBarrierControlClusterBarrierControlStopCallback();
}
#endif

} // namespace BarrierControl
namespace Basic {
#if IM_HAVE_BASIC_CLUSTER_RESET_TO_FACTORY_DEFAULTS_COMMAND
void OnResetToFactoryDefaultsCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfBasicClusterResetToFactoryDefaultsCallback();
}
#endif

} // namespace Basic
namespace Binding {
#if IM_HAVE_BINDING_CLUSTER_BIND_COMMAND
void OnBindCommandCallback(app::Command*, EndpointId ZCLEndpointId, chip::NodeId nodeId, chip::GroupId groupId, chip::EndpointId endpointId, chip::ClusterId clusterId)
{
    emberAfBindingClusterBindCallback(nodeId, groupId, endpointId, clusterId);
}
#endif

#if IM_HAVE_BINDING_CLUSTER_UNBIND_COMMAND
void OnUnbindCommandCallback(app::Command*, EndpointId ZCLEndpointId, chip::NodeId nodeId, chip::GroupId groupId, chip::EndpointId endpointId, chip::ClusterId clusterId)
{
    emberAfBindingClusterUnbindCallback(nodeId, groupId, endpointId, clusterId);
}
#endif

} // namespace Binding
namespace ColorControl {
#if IM_HAVE_COLOR_CONTROL_CLUSTER_MOVE_COLOR_COMMAND
void OnMoveColorCommandCallback(app::Command*, EndpointId ZCLEndpointId, int16_t rateX, int16_t rateY, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterMoveColorCallback(rateX, rateY, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_MOVE_COLOR_TEMPERATURE_COMMAND
void OnMoveColorTemperatureCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t moveMode, uint16_t rate, uint16_t colorTemperatureMinimum, uint16_t colorTemperatureMaximum, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterMoveColorTemperatureCallback(moveMode, rate, colorTemperatureMinimum, colorTemperatureMaximum, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_MOVE_HUE_COMMAND
void OnMoveHueCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t moveMode, uint8_t rate, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterMoveHueCallback(moveMode, rate, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_MOVE_SATURATION_COMMAND
void OnMoveSaturationCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t moveMode, uint8_t rate, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterMoveSaturationCallback(moveMode, rate, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_MOVE_TO_COLOR_COMMAND
void OnMoveToColorCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t colorX, uint16_t colorY, uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterMoveToColorCallback(colorX, colorY, transitionTime, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_MOVE_TO_COLOR_TEMPERATURE_COMMAND
void OnMoveToColorTemperatureCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t colorTemperature, uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterMoveToColorTemperatureCallback(colorTemperature, transitionTime, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_MOVE_TO_HUE_COMMAND
void OnMoveToHueCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t hue, uint8_t direction, uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterMoveToHueCallback(hue, direction, transitionTime, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_MOVE_TO_HUE_AND_SATURATION_COMMAND
void OnMoveToHueAndSaturationCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t hue, uint8_t saturation, uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterMoveToHueAndSaturationCallback(hue, saturation, transitionTime, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_MOVE_TO_SATURATION_COMMAND
void OnMoveToSaturationCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t saturation, uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterMoveToSaturationCallback(saturation, transitionTime, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_STEP_COLOR_COMMAND
void OnStepColorCommandCallback(app::Command*, EndpointId ZCLEndpointId, int16_t stepX, int16_t stepY, uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterStepColorCallback(stepX, stepY, transitionTime, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_STEP_COLOR_TEMPERATURE_COMMAND
void OnStepColorTemperatureCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t stepMode, uint16_t stepSize, uint16_t transitionTime, uint16_t colorTemperatureMinimum, uint16_t colorTemperatureMaximum, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterStepColorTemperatureCallback(stepMode, stepSize, transitionTime, colorTemperatureMinimum, colorTemperatureMaximum, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_STEP_HUE_COMMAND
void OnStepHueCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t stepMode, uint8_t stepSize, uint8_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterStepHueCallback(stepMode, stepSize, transitionTime, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_STEP_SATURATION_COMMAND
void OnStepSaturationCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t stepMode, uint8_t stepSize, uint8_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterStepSaturationCallback(stepMode, stepSize, transitionTime, optionsMask, optionsOverride);
}
#endif

#if IM_HAVE_COLOR_CONTROL_CLUSTER_STOP_MOVE_STEP_COMMAND
void OnStopMoveStepCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t optionsMask, uint8_t optionsOverride)
{
    emberAfColorControlClusterStopMoveStepCallback(optionsMask, optionsOverride);
}
#endif

} // namespace ColorControl
namespace ContentLaunch {
#if IM_HAVE_CONTENT_LAUNCH_CLUSTER_LAUNCH_CONTENT_COMMAND
void OnLaunchContentCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfContentLaunchClusterLaunchContentCallback();
}
#endif

#if IM_HAVE_CONTENT_LAUNCH_CLUSTER_LAUNCH_URL_COMMAND
void OnLaunchURLCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfContentLaunchClusterLaunchURLCallback();
}
#endif

} // namespace ContentLaunch
namespace DoorLock {
#if IM_HAVE_DOOR_LOCK_CLUSTER_CLEAR_ALL_PINS_COMMAND
void OnClearAllPinsCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfDoorLockClusterClearAllPinsCallback();
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_CLEAR_ALL_RFIDS_COMMAND
void OnClearAllRfidsCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfDoorLockClusterClearAllRfidsCallback();
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_CLEAR_HOLIDAY_SCHEDULE_COMMAND
void OnClearHolidayScheduleCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t scheduleId)
{
    emberAfDoorLockClusterClearHolidayScheduleCallback(scheduleId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_CLEAR_PIN_COMMAND
void OnClearPinCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t userId)
{
    emberAfDoorLockClusterClearPinCallback(userId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_CLEAR_RFID_COMMAND
void OnClearRfidCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t userId)
{
    emberAfDoorLockClusterClearRfidCallback(userId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_CLEAR_WEEKDAY_SCHEDULE_COMMAND
void OnClearWeekdayScheduleCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t scheduleId, uint16_t userId)
{
    emberAfDoorLockClusterClearWeekdayScheduleCallback(scheduleId, userId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_CLEAR_YEARDAY_SCHEDULE_COMMAND
void OnClearYeardayScheduleCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t scheduleId, uint16_t userId)
{
    emberAfDoorLockClusterClearYeardayScheduleCallback(scheduleId, userId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_GET_HOLIDAY_SCHEDULE_COMMAND
void OnGetHolidayScheduleCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t scheduleId)
{
    emberAfDoorLockClusterGetHolidayScheduleCallback(scheduleId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_GET_LOG_RECORD_COMMAND
void OnGetLogRecordCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t logIndex)
{
    emberAfDoorLockClusterGetLogRecordCallback(logIndex);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_GET_PIN_COMMAND
void OnGetPinCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t userId)
{
    emberAfDoorLockClusterGetPinCallback(userId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_GET_RFID_COMMAND
void OnGetRfidCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t userId)
{
    emberAfDoorLockClusterGetRfidCallback(userId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_GET_USER_TYPE_COMMAND
void OnGetUserTypeCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t userId)
{
    emberAfDoorLockClusterGetUserTypeCallback(userId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_GET_WEEKDAY_SCHEDULE_COMMAND
void OnGetWeekdayScheduleCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t scheduleId, uint16_t userId)
{
    emberAfDoorLockClusterGetWeekdayScheduleCallback(scheduleId, userId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_GET_YEARDAY_SCHEDULE_COMMAND
void OnGetYeardayScheduleCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t scheduleId, uint16_t userId)
{
    emberAfDoorLockClusterGetYeardayScheduleCallback(scheduleId, userId);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_LOCK_DOOR_COMMAND
void OnLockDoorCommandCallback(app::Command*, EndpointId ZCLEndpointId, const uint8_t * PIN)
{
    emberAfDoorLockClusterLockDoorCallback(PIN);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_SET_HOLIDAY_SCHEDULE_COMMAND
void OnSetHolidayScheduleCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t scheduleId, uint32_t localStartTime, uint32_t localEndTime, uint8_t operatingModeDuringHoliday)
{
    emberAfDoorLockClusterSetHolidayScheduleCallback(scheduleId, localStartTime, localEndTime, operatingModeDuringHoliday);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_SET_PIN_COMMAND
void OnSetPinCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t userId, uint8_t userStatus, uint8_t userType, const uint8_t * pin)
{
    emberAfDoorLockClusterSetPinCallback(userId, userStatus, userType, pin);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_SET_RFID_COMMAND
void OnSetRfidCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t userId, uint8_t userStatus, uint8_t userType, const uint8_t * id)
{
    emberAfDoorLockClusterSetRfidCallback(userId, userStatus, userType, id);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_SET_USER_TYPE_COMMAND
void OnSetUserTypeCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t userId, uint8_t userType)
{
    emberAfDoorLockClusterSetUserTypeCallback(userId, userType);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_SET_WEEKDAY_SCHEDULE_COMMAND
void OnSetWeekdayScheduleCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t scheduleId, uint16_t userId, uint8_t daysMask, uint8_t startHour, uint8_t startMinute, uint8_t endHour, uint8_t endMinute)
{
    emberAfDoorLockClusterSetWeekdayScheduleCallback(scheduleId, userId, daysMask, startHour, startMinute, endHour, endMinute);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_SET_YEARDAY_SCHEDULE_COMMAND
void OnSetYeardayScheduleCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t scheduleId, uint16_t userId, uint32_t localStartTime, uint32_t localEndTime)
{
    emberAfDoorLockClusterSetYeardayScheduleCallback(scheduleId, userId, localStartTime, localEndTime);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_UNLOCK_DOOR_COMMAND
void OnUnlockDoorCommandCallback(app::Command*, EndpointId ZCLEndpointId, const uint8_t * PIN)
{
    emberAfDoorLockClusterUnlockDoorCallback(PIN);
}
#endif

#if IM_HAVE_DOOR_LOCK_CLUSTER_UNLOCK_WITH_TIMEOUT_COMMAND
void OnUnlockWithTimeoutCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t timeoutInSeconds, const uint8_t * pin)
{
    emberAfDoorLockClusterUnlockWithTimeoutCallback(timeoutInSeconds, pin);
}
#endif

} // namespace DoorLock
namespace Groups {
#if IM_HAVE_GROUPS_CLUSTER_ADD_GROUP_COMMAND
void OnAddGroupCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId, const uint8_t * groupName)
{
    emberAfGroupsClusterAddGroupCallback(groupId, groupName);
}
#endif

#if IM_HAVE_GROUPS_CLUSTER_ADD_GROUP_IF_IDENTIFYING_COMMAND
void OnAddGroupIfIdentifyingCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId, const uint8_t * groupName)
{
    emberAfGroupsClusterAddGroupIfIdentifyingCallback(groupId, groupName);
}
#endif

#if IM_HAVE_GROUPS_CLUSTER_GET_GROUP_MEMBERSHIP_COMMAND
void OnGetGroupMembershipCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t groupCount, /* TYPE WARNING: array array defaults to */ uint8_t *  groupList)
{
    emberAfGroupsClusterGetGroupMembershipCallback(groupCount, groupList);
}
#endif

#if IM_HAVE_GROUPS_CLUSTER_REMOVE_ALL_GROUPS_COMMAND
void OnRemoveAllGroupsCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfGroupsClusterRemoveAllGroupsCallback();
}
#endif

#if IM_HAVE_GROUPS_CLUSTER_REMOVE_GROUP_COMMAND
void OnRemoveGroupCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId)
{
    emberAfGroupsClusterRemoveGroupCallback(groupId);
}
#endif

#if IM_HAVE_GROUPS_CLUSTER_VIEW_GROUP_COMMAND
void OnViewGroupCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId)
{
    emberAfGroupsClusterViewGroupCallback(groupId);
}
#endif

} // namespace Groups
namespace IasZone {
#if IM_HAVE_IAS_ZONE_CLUSTER_ZONE_ENROLL_RESPONSE_COMMAND
void OnZoneEnrollResponseCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t enrollResponseCode, uint8_t zoneId)
{
    emberAfIasZoneClusterZoneEnrollResponseCallback(enrollResponseCode, zoneId);
}
#endif

} // namespace IasZone
namespace Identify {
#if IM_HAVE_IDENTIFY_CLUSTER_IDENTIFY_COMMAND
void OnIdentifyCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t identifyTime)
{
    emberAfIdentifyClusterIdentifyCallback(identifyTime);
}
#endif

#if IM_HAVE_IDENTIFY_CLUSTER_IDENTIFY_QUERY_COMMAND
void OnIdentifyQueryCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfIdentifyClusterIdentifyQueryCallback();
}
#endif

} // namespace Identify
namespace LevelControl {
#if IM_HAVE_LEVEL_CONTROL_CLUSTER_MOVE_COMMAND
void OnMoveCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t moveMode, uint8_t rate, uint8_t optionMask, uint8_t optionOverride)
{
    emberAfLevelControlClusterMoveCallback(moveMode, rate, optionMask, optionOverride);
}
#endif

#if IM_HAVE_LEVEL_CONTROL_CLUSTER_MOVE_TO_LEVEL_COMMAND
void OnMoveToLevelCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t level, uint16_t transitionTime, uint8_t optionMask, uint8_t optionOverride)
{
    emberAfLevelControlClusterMoveToLevelCallback(level, transitionTime, optionMask, optionOverride);
}
#endif

#if IM_HAVE_LEVEL_CONTROL_CLUSTER_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND
void OnMoveToLevelWithOnOffCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t level, uint16_t transitionTime)
{
    emberAfLevelControlClusterMoveToLevelWithOnOffCallback(level, transitionTime);
}
#endif

#if IM_HAVE_LEVEL_CONTROL_CLUSTER_MOVE_WITH_ON_OFF_COMMAND
void OnMoveWithOnOffCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t moveMode, uint8_t rate)
{
    emberAfLevelControlClusterMoveWithOnOffCallback(moveMode, rate);
}
#endif

#if IM_HAVE_LEVEL_CONTROL_CLUSTER_STEP_COMMAND
void OnStepCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t stepMode, uint8_t stepSize, uint16_t transitionTime, uint8_t optionMask, uint8_t optionOverride)
{
    emberAfLevelControlClusterStepCallback(stepMode, stepSize, transitionTime, optionMask, optionOverride);
}
#endif

#if IM_HAVE_LEVEL_CONTROL_CLUSTER_STEP_WITH_ON_OFF_COMMAND
void OnStepWithOnOffCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t stepMode, uint8_t stepSize, uint16_t transitionTime)
{
    emberAfLevelControlClusterStepWithOnOffCallback(stepMode, stepSize, transitionTime);
}
#endif

#if IM_HAVE_LEVEL_CONTROL_CLUSTER_STOP_COMMAND
void OnStopCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint8_t optionMask, uint8_t optionOverride)
{
    emberAfLevelControlClusterStopCallback(optionMask, optionOverride);
}
#endif

#if IM_HAVE_LEVEL_CONTROL_CLUSTER_STOP_WITH_ON_OFF_COMMAND
void OnStopWithOnOffCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfLevelControlClusterStopWithOnOffCallback();
}
#endif

} // namespace LevelControl
namespace MediaPlayback {
#if IM_HAVE_MEDIA_PLAYBACK_CLUSTER_FAST_FORWARD_REQUEST_COMMAND
void OnFastForwardRequestCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfMediaPlaybackClusterFastForwardRequestCallback();
}
#endif

#if IM_HAVE_MEDIA_PLAYBACK_CLUSTER_NEXT_REQUEST_COMMAND
void OnNextRequestCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfMediaPlaybackClusterNextRequestCallback();
}
#endif

#if IM_HAVE_MEDIA_PLAYBACK_CLUSTER_PAUSE_REQUEST_COMMAND
void OnPauseRequestCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfMediaPlaybackClusterPauseRequestCallback();
}
#endif

#if IM_HAVE_MEDIA_PLAYBACK_CLUSTER_PLAY_REQUEST_COMMAND
void OnPlayRequestCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfMediaPlaybackClusterPlayRequestCallback();
}
#endif

#if IM_HAVE_MEDIA_PLAYBACK_CLUSTER_PREVIOUS_REQUEST_COMMAND
void OnPreviousRequestCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfMediaPlaybackClusterPreviousRequestCallback();
}
#endif

#if IM_HAVE_MEDIA_PLAYBACK_CLUSTER_REWIND_REQUEST_COMMAND
void OnRewindRequestCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfMediaPlaybackClusterRewindRequestCallback();
}
#endif

#if IM_HAVE_MEDIA_PLAYBACK_CLUSTER_SKIP_BACKWARD_REQUEST_COMMAND
void OnSkipBackwardRequestCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfMediaPlaybackClusterSkipBackwardRequestCallback();
}
#endif

#if IM_HAVE_MEDIA_PLAYBACK_CLUSTER_SKIP_FORWARD_REQUEST_COMMAND
void OnSkipForwardRequestCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfMediaPlaybackClusterSkipForwardRequestCallback();
}
#endif

#if IM_HAVE_MEDIA_PLAYBACK_CLUSTER_START_OVER_REQUEST_COMMAND
void OnStartOverRequestCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfMediaPlaybackClusterStartOverRequestCallback();
}
#endif

#if IM_HAVE_MEDIA_PLAYBACK_CLUSTER_STOP_REQUEST_COMMAND
void OnStopRequestCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfMediaPlaybackClusterStopRequestCallback();
}
#endif

} // namespace MediaPlayback
namespace OnOff {
#if IM_HAVE_ON_OFF_CLUSTER_OFF_COMMAND
void OnOffCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfOnOffClusterOffCallback();
}
#endif

#if IM_HAVE_ON_OFF_CLUSTER_ON_COMMAND
void OnOnCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfOnOffClusterOnCallback();
}
#endif

#if IM_HAVE_ON_OFF_CLUSTER_TOGGLE_COMMAND
void OnToggleCommandCallback(app::Command*, EndpointId ZCLEndpointId)
{
    emberAfOnOffClusterToggleCallback();
}
#endif

} // namespace OnOff
namespace Scenes {
#if IM_HAVE_SCENES_CLUSTER_ADD_SCENE_COMMAND
void OnAddSceneCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId, uint8_t sceneId, uint16_t transitionTime, const uint8_t * sceneName, /* TYPE WARNING: array array defaults to */ uint8_t *  extensionFieldSets)
{
    emberAfScenesClusterAddSceneCallback(groupId, sceneId, transitionTime, sceneName, extensionFieldSets);
}
#endif

#if IM_HAVE_SCENES_CLUSTER_GET_SCENE_MEMBERSHIP_COMMAND
void OnGetSceneMembershipCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId)
{
    emberAfScenesClusterGetSceneMembershipCallback(groupId);
}
#endif

#if IM_HAVE_SCENES_CLUSTER_RECALL_SCENE_COMMAND
void OnRecallSceneCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId, uint8_t sceneId, uint16_t transitionTime)
{
    emberAfScenesClusterRecallSceneCallback(groupId, sceneId, transitionTime);
}
#endif

#if IM_HAVE_SCENES_CLUSTER_REMOVE_ALL_SCENES_COMMAND
void OnRemoveAllScenesCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId)
{
    emberAfScenesClusterRemoveAllScenesCallback(groupId);
}
#endif

#if IM_HAVE_SCENES_CLUSTER_REMOVE_SCENE_COMMAND
void OnRemoveSceneCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId, uint8_t sceneId)
{
    emberAfScenesClusterRemoveSceneCallback(groupId, sceneId);
}
#endif

#if IM_HAVE_SCENES_CLUSTER_STORE_SCENE_COMMAND
void OnStoreSceneCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId, uint8_t sceneId)
{
    emberAfScenesClusterStoreSceneCallback(groupId, sceneId);
}
#endif

#if IM_HAVE_SCENES_CLUSTER_VIEW_SCENE_COMMAND
void OnViewSceneCommandCallback(app::Command*, EndpointId ZCLEndpointId, uint16_t groupId, uint8_t sceneId)
{
    emberAfScenesClusterViewSceneCallback(groupId, sceneId);
}
#endif

} // namespace Scenes

} // namespace clusters
} // namespace app
} // namespace chip
