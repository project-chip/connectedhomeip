/*
 *
 *    Copyright (c) 2025 Project CHIP Authors
 *    All rights reserved.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
#pragma once

#include <app-common/zap-generated/cluster-objects.h>
#include <app/AttributeAccessInterface.h>
#include <app/CommandHandlerInterface.h>
#include <string>
#include <vector>

namespace chip {
namespace app {
namespace Clusters {
namespace WebRTCTransportProvider {

using ICEServerDecodableStruct = Structs::ICEServerStruct::DecodableType;
using WebRTCSessionStruct      = Structs::WebRTCSessionStruct::Type;

/**
 * @brief
 *   A delegate interface for the WebRTC Transport Provider cluster, allowing
 *   OEM or application-specific logic to be implemented outside of the cluster
 *   server itself. The server calls these methods to do the "real work."
 */
class Delegate
{
public:
    virtual ~Delegate() = default;

    struct OfferRequestArgs
    {
        uint16_t sessionId;
        StreamUsageEnum streamUsage;
        Optional<DataModel::Nullable<uint16_t>> videoStreamId;
        Optional<DataModel::Nullable<uint16_t>> audioStreamId;
        Optional<std::vector<ICEServerDecodableStruct>> iceServers;
        Optional<std::string> iceTransportPolicy;
        Optional<BitMask<WebRTCMetadataOptionsBitmap>> metadataOptions;
        NodeId peerNodeId;
    };

    struct ProvideOfferRequestArgs : OfferRequestArgs
    {
        std::string sdp;
    };

    /**
     * @brief
     *     This method is called when the server receives the SolicitOffer command.
     *
     *     It is used by the requestor to ask the provider to initiate a new Offer/Answer
     *     negotiation. The specification states that the provider may be in a standby mode
     *     (low power), thus a "deferred offer" scenario might occur if the device needs time
     *     to fully power resources needed for streaming.
     *
     * @note
     *   - The incoming arguments in args include a freshly generated session ID (i.e. args.sessionId)
     *     that uniquely identifies this session. The delegate implementation MUST use this identifier
     *     for all subsequent processing and tracking of the session.
     *   - The `args.iceServers` data (including `urls`) is only valid during this method call.
     *   - The delegate **must** deep-copy any data (e.g., URLs) it needs to retain after this call
     *     returns. Storing references to the input data will cause undefined behavior.
     *
     * @param[in]  args
     *     Structure containing all input arguments for the command. In particular, args.sessionId
     *     is pre-populated with a unique session identifier generated by the server.
     *
     * @param[out] outSession
     *     On success (`CHIP_NO_ERROR`), must be populated with the new session's details.
     *
     * @param[out] outDeferredOffer
     *     On success (`CHIP_NO_ERROR`), set to `true` if the device is in standby
     *     or needs to defer generating an Offer; otherwise, `false`.
     *     If an error is returned, this value is not relevant.
     *
     * @return CHIP_ERROR
     *     - CHIP_NO_ERROR if a session was successfully created or prepared for negotiation.
     *     - CHIP_ERROR_NO_MEMORY if the device cannot allocate a new session.
     *     - Appropriate error otherwise.
     *
     * The combination of `outDeferredOffer == true` with an error return code is invalid
     * (the device cannot be "deferring" if it is failing the command).
     */
    virtual CHIP_ERROR HandleSolicitOffer(const OfferRequestArgs & args, WebRTCSessionStruct & outSession,
                                          bool & outDeferredOffer) = 0;

    /**
     * @brief
     *   Handles the ProvideOffer command received by the server.
     *
     * @note
     *   - The incoming arguments in args include a freshly generated session ID (i.e. args.sessionId)
     *     that uniquely identifies this session. The delegate implementation MUST use this identifier
     *     for all subsequent processing and tracking of the session.
     *   - The `args.iceServers` data (including `urls`) is only valid during this method call.
     *   - The delegate **must** deep-copy any data (e.g., URLs) it needs to retain after this call
     *     returns. Storing references to the input data will cause undefined behavior.
     *
     * @param[in]  args
     *   Contains all input arguments for the command, including the SDP Offer, session usage, etc.
     *   If the video stream ID is missing, the delegate MUST automatically select a matching video stream.
     *   If the audio stream ID is missing, the delegate MUST automatically select a matching audio stream.
     *   In either case, upon successful selection, the delegate is responsible for internally incrementing
     *   the reference count on any used video and audio streams.
     *
     * @param[out] outSession
     *   Must be populated with the final session details (session ID, stream IDs, etc.) when this
     *   method returns `CHIP_NO_ERROR`. If an error is returned, `outSession` is left unmodified or
     *   set to an invalid state.
     *
     * @return
     *   - CHIP_NO_ERROR if the request succeeds and `outSession` is populated.
     *   - CHIP_ERROR_NO_MEMORY if the device cannot allocate a new session.
     *   - Appropriate error otherwise.
     */
    virtual CHIP_ERROR HandleProvideOffer(const ProvideOfferRequestArgs & args, WebRTCSessionStruct & outSession) = 0;

    /**
     * @brief
     *   Called when the server receives the ProvideAnswer command.
     *
     *   In the standard WebRTC Offer/Answer flow, once the provider sends an Offer (or
     *   the requestor has re-offered), the other side will respond with an SDP Answer.
     *   This method is invoked to store and process that Answer.
     *
     * @param[in] sessionId  The identifier of the current session.
     * @param[in] sdpAnswer  The SDP Answer string.
     *
     * @return CHIP_ERROR
     *   - CHIP_NO_ERROR if the Answer is accepted
     *   - Appropriate error if invalid or unexpected
     */
    virtual CHIP_ERROR HandleProvideAnswer(uint16_t sessionId, const std::string & sdpAnswer) = 0;

    /**
     * @brief
     *   Called when the server receives the ProvideICECandidates command.
     *
     *   After the initial Offer/Answer exchange, additional ICE Candidates may be
     *   discovered. This command allows the requestor to provide those candidates
     *   (i.e., Trickle ICE).
     *
     * @param[in] sessionId  The current session ID.
     * @param[in] candidates A list of ICE candidate strings.
     *
     * @return CHIP_ERROR
     *   - CHIP_NO_ERROR on success
     *   - An error if the session is invalid or the candidates cannot be processed
     */
    virtual CHIP_ERROR HandleProvideICECandidates(uint16_t sessionId, const std::vector<std::string> & candidates) = 0;

    /**
     * @brief
     *   Called when the server or the requestor ends a session via the EndSession command.
     *
     *   Internally decrement the ReferenceCount on any used video streams.
     *   Internally decrement the ReferenceCount on any used audio streams.
     *
     * @param[in] sessionId      The ID of the session to end.
     * @param[in] reasonCode     Reason for ending the session (e.g. normal closure, resource limit).
     * @param[in] videoStreamID  The nullable ID of the video stream associated with the session.
     * @param[in] audioStreamID  The nullable ID of the audio stream associated with the session.
     *
     * @return CHIP_ERROR
     *   - CHIP_NO_ERROR on success
     *   - Error if no matching session is found or some cleanup error occurs
     */
    virtual CHIP_ERROR HandleEndSession(uint16_t sessionId, WebRTCEndReasonEnum reasonCode,
                                        DataModel::Nullable<uint16_t> videoStreamID,
                                        DataModel::Nullable<uint16_t> audioStreamID) = 0;

    /**
     * @brief Validates the requested stream usage against the camera's resource management
     *        and stream priority policies.
     *
     * The implementation SHALL ensure:
     *  - The requested stream usage (streamUsage) is allowed given the current allocation of
     *    camera resources (e.g. CPU, memory, network bandwidth) and the prioritized stream list.
     *
     * @param[in] streamUsage    The desired usage type for the stream (e.g. live view, recording, etc.).
     * @param[in] videoStreamId  Optional identifier for the requested video stream.
     * @param[in] audioStreamId  Optional identifier for the requested audio stream.
     *
     * @return CHIP_ERROR CHIP_NO_ERROR if the stream usage is valid; an appropriate error code otherwise.
     */
    virtual CHIP_ERROR ValidateStreamUsage(StreamUsageEnum streamUsage,
                                           const Optional<DataModel::Nullable<uint16_t>> & videoStreamId,
                                           const Optional<DataModel::Nullable<uint16_t>> & audioStreamId) = 0;
};

class WebRTCTransportProviderServer : public AttributeAccessInterface, public CommandHandlerInterface
{
public:
    /**
     * @brief
     *   Constructs the WebRTCTransportProviderServer with the specified delegate and endpoint.
     *
     * @param[in] delegate   A reference to an implementation of the Delegate interface. Must remain
     *                       valid for the lifetime of this object.
     * @param[in] endpointId The Endpoint where the WebRTC Transport Provider cluster is published.
     */
    WebRTCTransportProviderServer(Delegate & delegate, EndpointId endpointId);

    /**
     * @brief
     *   Destructor. Cleans up any internal data, but does not destroy the delegate.
     */
    ~WebRTCTransportProviderServer() override;

    /**
     * @brief
     *   Registers the command handler and attribute interface with the Matter Stack.
     * @return CHIP_ERROR
     *   - CHIP_NO_ERROR on successful registration.
     *   - Other CHIP_ERROR codes if registration fails.
     */
    CHIP_ERROR Init();

    /**
     * @brief
     *   Unregisters the command handler and attribute interface, releasing resources.
     */
    void Shutdown();

private:
    enum class UpsertResultEnum : uint8_t
    {
        kInserted = 0x00,
        kUpdated  = 0x01,
    };

    CHIP_ERROR Read(const ConcreteReadAttributePath & aPath, AttributeValueEncoder & aEncoder) override;
    void InvokeCommand(HandlerContext & ctx) override;

    // Helper functions
    WebRTCSessionStruct * FindSession(uint16_t sessionId);
    WebRTCSessionStruct * CheckForMatchingSession(HandlerContext & ctx, uint16_t sessionId);
    UpsertResultEnum UpsertSession(const WebRTCSessionStruct & session);
    void RemoveSession(uint16_t sessionId);
    uint16_t GenerateSessionId();

    // Command Handlers
    void HandleSolicitOffer(HandlerContext & ctx, const Commands::SolicitOffer::DecodableType & req);
    void HandleProvideOffer(HandlerContext & ctx, const Commands::ProvideOffer::DecodableType & req);
    void HandleProvideAnswer(HandlerContext & ctx, const Commands::ProvideAnswer::DecodableType & req);
    void HandleProvideICECandidates(HandlerContext & ctx, const Commands::ProvideICECandidates::DecodableType & req);
    void HandleEndSession(HandlerContext & ctx, const Commands::EndSession::DecodableType & req);

    Delegate & mDelegate;
    std::vector<WebRTCSessionStruct> mCurrentSessions;
};

} // namespace WebRTCTransportProvider
} // namespace Clusters
} // namespace app
} // namespace chip
