{{#if (zcl_command_arguments_count this.id)}}
CHIP_ERROR TLVError = CHIP_NO_ERROR;
{{#zcl_command_arguments}}
{{#if (isString type)}}
const uint8_t * {{asSymbol label}};
{{else}}
{{asUnderlyingZclType type}} {{asSymbol label}};
{{/if}}
{{/zcl_command_arguments}}

while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
{
  switch (TLV::TagNumFromTag(dataTlv.GetTag()))
  {
{{#zcl_command_arguments}}
    case {{index}}:
{{#if (isString type)}}
      TLVError = dataTlv.GetDataPtr({{asSymbol label}});
{{else if isArray}}
      // Just for compatibility, we will add array type support in IM later.
      TLVError = dataTlv.GetDataPtr(const_cast<const uint8_t *&>({{asSymbol label}}));
{{else}}
      TLVError = dataTlv.Get({{asSymbol label}});
{{/if}}
      break;
{{/zcl_command_arguments}}
    default:
      // Unsupported tag, ignore it.
      ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
      break;
  }
  if (TLVError != CHIP_NO_ERROR)
  {
    ChipLogProgress(Zcl, "Failed to decode TLV data with tag %" PRIx32 ": %" PRId32, TLV::TagNumFromTag(dataTlv.GetTag()), TLVError);
  }
}
{{/if}}
On{{asCamelCased name false}}CommandCallback(command, endpointId{{#zcl_command_arguments}}, {{asSymbol label}}{{/zcl_command_arguments}});
