{{> header}}

#include <app-common/zap-generated/af-structs.h>
#include <app/util/af.h>
#include <app/util/attribute-list-byte-span.h>
#include <app/util/basic-types.h>
#include <lib/support/SafeInt.h>
#include <lib/support/logging/CHIPLogging.h>
#include <app/util/ember-compatibility-functions.h>
#include <lib/core/CHIPTLV.h>

using namespace chip;
using namespace chip::app;
using namespace chip::app::List;

// The first 2 bytes specify the number of entries. A value of 0xFFFF means the list in invalid
// and data is undefined.
constexpr uint16_t kSizeLengthInBytes = 2u;

void copyListMember(uint8_t * dest, uint8_t * src, bool write, uint16_t * offset, uint16_t length)
{
    if (write)
    {
        memmove(dest + *offset, src, length);
    }
    else
    {
        memmove(dest, src + *offset, length);
    }

    *offset = static_cast<uint16_t>(*offset + length);
}

CHIP_ERROR CopyStructAttributeToCHIPTLV(ClusterId clusterId, AttributeId attributeId, uint8_t * src, uint16_t len,
                                        TLV::TLVWriter & writer, uint64_t tag)
{
    switch (clusterId)
    {
 {{#chip_server_clusters}}
 {{#if (chip_server_has_struct_attributes)}}
    case {{asHex code 4}}: // {{name}} Cluster
    {
        switch (attributeId)
        {
        {{#chip_server_cluster_attributes}}
        {{#if isStruct}}
        {{#unless isList}}
            case {{asHex code 4}}: // {{name}}
            {
                // Struct {{chipType}}
                {{chipType}} entry;
                ReturnErrorOnFailure({{chipType}}::FromEmberBuffer(&entry, src, {{size}}));
                return writer.Put(TLV::AnonymousTag, entry);
            }
        {{/unless}}
        {{/if}}
        {{/chip_server_cluster_attributes}}
      }
      break;
    }
{{/if}}
{{/chip_server_clusters}}
    }
    return CHIP_ERROR_INVALID_ARGUMENT;
}

CHIP_ERROR EmberListToCHIPTLV(ClusterId clusterId, AttributeId attributeId, uint8_t * src, uint16_t len, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    size_t count = *reinterpret_cast<uint16_t*>(src);
    uint16_t entryLength = 0;

    IgnoreUnusedVariable(entryLength);
    IgnoreUnusedVariable(count);

    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Array, tmpType));
    switch (clusterId)
    {
 {{#chip_server_clusters}}
 {{#if (chip_server_has_list_attributes)}}
    case {{asHex code 4}}: // {{name}} Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        {{#chip_server_cluster_attributes}}
        {{#if isList}}
            case {{asHex code 4}}: // {{name}}
            {
                for (size_t index = 0; index < count; index++)
                {
                {{#unless (isString type)}}
                entryLength  = {{size}};
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                {{/unless}}
                {{#if isStruct}}
                // Struct {{chipType}}
                {{chipType}} entry;
                SuccessOrExit(err = {{chipType}}::FromEmberBuffer(&entry, src + entryOffset, {{size}}));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
                {{else}}
                {{#if (isString type)}}
                entryOffset = GetByteSpanOffsetFromIndex(src, len, static_cast<uint16_t>(index));
                if (entryOffset == 0)
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }

                chip::ByteSpan {{asCamelCased name}}Span; // {{type}}
                uint16_t {{asCamelCased name}}RemainingSpace = static_cast<uint16_t>(len - entryOffset);
                if (CHIP_NO_ERROR != ReadByteSpan(src + entryOffset, {{asCamelCased name}}RemainingSpace, &{{asCamelCased name}}Span))
                {
                    ChipLogError(Zcl, "Index %zu is invalid. Not enough remaining space", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                writer.Put(TLV::AnonymousTag, {{asCamelCased name}}Span);
                {{else}}
                {{chipType}} entry;
                copyListMember(reinterpret_cast<uint8_t*>(&entry), src, false, &entryOffset, entryLength); // {{type}}
                writer.Put(TLV::AnonymousTag, entry);
                {{/if}}
                {{/if}}
                }
                break;
            }
        {{/if}}
        {{/chip_server_cluster_attributes}}
      }
      break;
    }
{{/if}}
{{/chip_server_clusters}}
    }
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

uint16_t emberAfCopyList(ClusterId clusterId, EmberAfAttributeMetadata * am, bool write, uint8_t * dest, uint8_t * src, int32_t index)
{
    if (index == -1)
    {
        memmove(dest, src, am->size);
        return am->size;
    }

    if (index == 0)
    {
        if (write)
        {
            // src is a pointer to native-endian uint16_t, dest is pointer to buffer that should hold little-endian value
            emberAfCopyInt16u(dest, 0, *reinterpret_cast<uint16_t*>(src));
        }
        else
        {
            // src is pointer to buffer holding little-endian value, dest is a pointer to native-endian uint16_t
            *reinterpret_cast<uint16_t*>(dest) = emberAfGetInt16u(src, 0, kSizeLengthInBytes);
        }
        return kSizeLengthInBytes;
    }

    if (!CanCastTo<uint16_t>(index))
    {
        ChipLogError(Zcl, "Index %" PRId32 " is invalid. Should be between 1 and 65534", index);
        return 0;
    }

    uint16_t entryLength = 0;
    switch (clusterId)
    {
 {{#chip_server_clusters}}
 {{#if (chip_server_has_list_attributes)}}
    case {{asHex code 4}}: // {{name}} Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        {{#chip_server_cluster_attributes}}
        {{#if isList}}
            case {{asHex code 4}}: // {{name}}
            {
                {{#unless (isString type)}}
                entryLength  = {{size}};
                if (((index - 1) * entryLength) > (am->size - entryLength))
                {
                    ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                    return 0;
                }
                entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
                {{/unless}}
                {{#if isStruct}}
                // Struct {{chipType}}
                {{chipType}} * entry = reinterpret_cast<{{chipType}} *>(write ? src : dest);
                CHIP_ERROR err = CHIP_NO_ERROR;
                if (write)
                {
                    size_t unusedLen;
                    err = {{chipType}}::ToEmberBuffer(entry, dest + entryOffset, {{size}}, unusedLen);
                } else {
                    err = {{chipType}}::FromEmberBuffer(entry, src + entryOffset, {{size}});
                }
                if (CHIP_NO_ERROR != err)
                {
                    ChipLogError(Zcl, "Index %" PRId32 " is invalid. Not enough remaining space", index);
                    return 0;
                }
                {{else}}
                {{#if (isString type)}}
                entryOffset = GetByteSpanOffsetFromIndex(write ? dest : src, am->size, static_cast<uint16_t>(index - 1));
                if (entryOffset == 0)
                {
                    ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                    return 0;
                }

                ByteSpan * {{asLowerCamelCase name}}Span   = reinterpret_cast<ByteSpan *>(write ? src : dest); // {{type}}
                uint16_t {{asLowerCamelCase name}}RemainingSpace = static_cast<uint16_t>(am->size - entryOffset);
                if (CHIP_NO_ERROR != (write ? WriteByteSpan(dest + entryOffset, {{asLowerCamelCase name}}RemainingSpace, {{asLowerCamelCase name}}Span) : ReadByteSpan(src + entryOffset, {{asLowerCamelCase name}}RemainingSpace, {{asLowerCamelCase name}}Span)))
                {
                    ChipLogError(Zcl, "Index %" PRId32 " is invalid. Not enough remaining space", index);
                    return 0;
                }

                if (!CanCastTo<uint16_t>({{asLowerCamelCase name}}Span->size()))
                {
                    ChipLogError(Zcl, "Span size %zu is too large", {{asLowerCamelCase name}}Span->size());
                    return 0;
                }
                entryLength = static_cast<uint16_t>({{asLowerCamelCase name}}Span->size());
                {{else}}
                copyListMember(dest, src, write, &entryOffset, entryLength); // {{type}}
                {{/if}}
                {{/if}}
                break;
            }
        {{/if}}
        {{/chip_server_cluster_attributes}}
      }
      break;
    }
{{/if}}
{{/chip_server_clusters}}
    }

    return entryLength;
}

// A list is a collection of entries of the same data type. The data type may be any defined data type.
uint16_t emberAfAttributeValueListSize(ClusterId clusterId, AttributeId attributeId, const uint8_t * buffer)
{
    // The first 2 bytes specify the number of entries. A value of 0xFFFF means the list in invalid
    // and data is undefined.
    uint16_t entryCount = emberAfGetInt16u(buffer, 0, kSizeLengthInBytes);
    if (entryCount == 0xFFFF)
    {
        return 0;
    }

    uint16_t entryLength = 0;
    switch (clusterId)
    {
{{#chip_server_clusters}}
{{#if (chip_server_has_list_attributes)}}
    case {{asHex code 4}}: // {{name}} Cluster
        switch (attributeId)
        {
        {{#chip_server_cluster_attributes}}
        {{#if isList}}
            case {{asHex code 4}}: // {{name}}
            {{#if isStruct}}
            // Struct {{chipType}}
            {{else}}
            // {{chipType}}
            {{/if}}
            {{#if (isString type)}}
            return GetByteSpanOffsetFromIndex(buffer, {{size}}, entryCount);
            {{else}}
            entryLength = {{size}};
            {{/if}}
            break;
        {{/if}}
        {{/chip_server_cluster_attributes}}
        }
    break;
{{/if}}
{{/chip_server_clusters}}
    }

    uint32_t totalSize = kSizeLengthInBytes + (entryCount * entryLength);
    if (!CanCastTo<uint16_t>(totalSize))
    {
        ChipLogError(Zcl, "Cluster " ChipLogFormatMEI ": Size of attribute " ChipLogFormatMEI " is too large.", ChipLogValueMEI(clusterId), ChipLogValueMEI(attributeId));
        return 0;
    }

    return static_cast<uint16_t>(totalSize);
}
