/**
 *
 *    Copyright (c) 2020 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

/**
 *
 *    Copyright (c) 2020 Silicon Labs
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

// This is a set of generated functions that parse the
// the incomming message, and call appropriate command handler.

#include PLATFORM_HEADER
#ifdef EZSP_HOST
// Includes needed for ember related functions for the EZSP host
#include "app/util/ezsp/ezsp-protocol.h"
#include "app/util/ezsp/ezsp-utils.h"
#include "app/util/ezsp/ezsp.h"
#include "app/util/ezsp/serial-interface.h"
#include "stack/include/ember-types.h"
#include "stack/include/error.h"
#else
// Includes needed for ember related functions for the EM250
#include "stack/include/ember.h"
#endif // EZSP_HOST

#include "af-structs.h"
#include "app/framework/util/util.h"
#include "call-command-handler.h"
#include "callback.h"
#include "command-id.h"

static EmberAfStatus status(bool wasHandled, bool clusterExists, bool mfgSpecific)
{
    if (wasHandled)
    {
        return EMBER_ZCL_STATUS_SUCCESS;
    }
    else if (mfgSpecific)
    {
        return EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND;
    }
    else if (clusterExists)
    {
        return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    }
    else
    {
        return EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER;
    }
}

// Main command parsing controller.
EmberAfStatus emberAfClusterSpecificCommandParse(EmberAfClusterCommand * cmd)
{
    EmberAfStatus result = status(false, false, cmd->mfgSpecific);
    if (cmd->direction == (uint8_t) ZCL_DIRECTION_SERVER_TO_CLIENT &&
        emberAfContainsClientWithMfgCode(cmd->apsFrame->destinationEndpoint, cmd->apsFrame->clusterId, cmd->mfgCode))
    {
        switch (cmd->apsFrame->clusterId)
        {
        case ZCL_BASIC_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_POWER_CONFIG_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_DEVICE_TEMP_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_IDENTIFY_CLUSTER_ID:
            result = emberAfIdentifyClusterClientCommandParse(cmd);
            break;
        case ZCL_GROUPS_CLUSTER_ID:
            result = emberAfGroupsClusterClientCommandParse(cmd);
            break;
        case ZCL_SCENES_CLUSTER_ID:
            result = emberAfScenesClusterClientCommandParse(cmd);
            break;
        case ZCL_ON_OFF_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_ON_OFF_SWITCH_CONFIG_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_LEVEL_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_ALARM_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_TIME_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_RSSI_LOCATION_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_BINARY_INPUT_BASIC_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_SHADE_CONFIG_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_DOOR_LOCK_CLUSTER_ID:
            result = emberAfDoorLockClusterClientCommandParse(cmd);
            break;
        case ZCL_WINDOW_COVERING_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_BARRIER_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_PUMP_CONFIG_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_THERMOSTAT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_FAN_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_DEHUMID_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_THERMOSTAT_UI_CONFIG_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_COLOR_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_BALLAST_CONFIGURATION_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_ILLUM_MEASUREMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_ILLUM_LEVEL_SENSING_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_TEMP_MEASUREMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_PRESSURE_MEASUREMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_FLOW_MEASUREMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_RELATIVE_HUMIDITY_MEASUREMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_OCCUPANCY_SENSING_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_IAS_ZONE_CLUSTER_ID:
            result = emberAfIasZoneClusterClientCommandParse(cmd);
            break;
        case ZCL_IAS_ACE_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_IAS_WD_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_GENERIC_TUNNEL_CLUSTER_ID:
            result = emberAfGenericTunnelClusterClientCommandParse(cmd);
            break;
        case ZCL_BACNET_PROTOCOL_TUNNEL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_11073_PROTOCOL_TUNNEL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_PRICE_CLUSTER_ID:
            result = emberAfPriceClusterClientCommandParse(cmd);
            break;
        case ZCL_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_ID:
            result = emberAfDemandResponseLoadControlClusterClientCommandParse(cmd);
            break;
        case ZCL_SIMPLE_METERING_CLUSTER_ID:
            result = emberAfSimpleMeteringClusterClientCommandParse(cmd);
            break;
        case ZCL_MESSAGING_CLUSTER_ID:
            result = emberAfMessagingClusterClientCommandParse(cmd);
            break;
        case ZCL_TUNNELING_CLUSTER_ID:
            result = emberAfTunnelingClusterClientCommandParse(cmd);
            break;
        case ZCL_KEY_ESTABLISHMENT_CLUSTER_ID:
            result = emberAfKeyEstablishmentClusterClientCommandParse(cmd);
            break;
        default:
            // Unrecognized cluster ID, error status will apply.
            break;
        }
    }
    else if (cmd->direction == (uint8_t) ZCL_DIRECTION_CLIENT_TO_SERVER &&
             emberAfContainsServerWithMfgCode(cmd->apsFrame->destinationEndpoint, cmd->apsFrame->clusterId, cmd->mfgCode))
    {
        switch (cmd->apsFrame->clusterId)
        {
        case ZCL_BASIC_CLUSTER_ID:
            result = emberAfBasicClusterServerCommandParse(cmd);
            break;
        case ZCL_POWER_CONFIG_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_DEVICE_TEMP_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_IDENTIFY_CLUSTER_ID:
            result = emberAfIdentifyClusterServerCommandParse(cmd);
            break;
        case ZCL_GROUPS_CLUSTER_ID:
            result = emberAfGroupsClusterServerCommandParse(cmd);
            break;
        case ZCL_SCENES_CLUSTER_ID:
            result = emberAfScenesClusterServerCommandParse(cmd);
            break;
        case ZCL_ON_OFF_CLUSTER_ID:
            result = emberAfOnOffClusterServerCommandParse(cmd);
            break;
        case ZCL_ON_OFF_SWITCH_CONFIG_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_LEVEL_CONTROL_CLUSTER_ID:
            result = emberAfLevelControlClusterServerCommandParse(cmd);
            break;
        case ZCL_ALARM_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_TIME_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_RSSI_LOCATION_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_BINARY_INPUT_BASIC_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_POLL_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_SHADE_CONFIG_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_DOOR_LOCK_CLUSTER_ID:
            result = emberAfDoorLockClusterServerCommandParse(cmd);
            break;
        case ZCL_WINDOW_COVERING_CLUSTER_ID:
            result = emberAfWindowCoveringClusterServerCommandParse(cmd);
            break;
        case ZCL_BARRIER_CONTROL_CLUSTER_ID:
            result = emberAfBarrierControlClusterServerCommandParse(cmd);
            break;
        case ZCL_PUMP_CONFIG_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_THERMOSTAT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_FAN_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_DEHUMID_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_THERMOSTAT_UI_CONFIG_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_COLOR_CONTROL_CLUSTER_ID:
            result = emberAfColorControlClusterServerCommandParse(cmd);
            break;
        case ZCL_BALLAST_CONFIGURATION_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_ILLUM_MEASUREMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_ILLUM_LEVEL_SENSING_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_TEMP_MEASUREMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_PRESSURE_MEASUREMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_FLOW_MEASUREMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_RELATIVE_HUMIDITY_MEASUREMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_OCCUPANCY_SENSING_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_IAS_ZONE_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_IAS_ACE_CLUSTER_ID:
            result = emberAfIasAceClusterServerCommandParse(cmd);
            break;
        case ZCL_IAS_WD_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_GENERIC_TUNNEL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_BACNET_PROTOCOL_TUNNEL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_11073_PROTOCOL_TUNNEL_CLUSTER_ID:
            result = emberAf11073ProtocolTunnelClusterServerCommandParse(cmd);
            break;
        case ZCL_PRICE_CLUSTER_ID:
            result = emberAfPriceClusterServerCommandParse(cmd);
            break;
        case ZCL_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_ID:
            result = emberAfDemandResponseLoadControlClusterServerCommandParse(cmd);
            break;
        case ZCL_SIMPLE_METERING_CLUSTER_ID:
            result = emberAfSimpleMeteringClusterServerCommandParse(cmd);
            break;
        case ZCL_MESSAGING_CLUSTER_ID:
            result = emberAfMessagingClusterServerCommandParse(cmd);
            break;
        case ZCL_TUNNELING_CLUSTER_ID:
            result = emberAfTunnelingClusterServerCommandParse(cmd);
            break;
        case ZCL_KEY_ESTABLISHMENT_CLUSTER_ID:
            result = emberAfKeyEstablishmentClusterServerCommandParse(cmd);
            break;
        case 0xFC00: // Multiple Manufacturer Clusters Present
            switch (cmd->mfgCode)
            {
            case 0x1002: // SAMPLE_MFG_SPECIFIC_CLUSTER Manufacturer: Ember
                result = emberAfSampleMfgSpecificClusterServerCommandParse(cmd);
                break;
            case 0x1049: // SAMPLE_MFG_SPECIFIC_CLUSTER_2 Manufacturer: Silicon Laboratories
                result = emberAfSampleMfgSpecificCluster2ServerCommandParse(cmd);
                break;
            default:
                // Unrecognized mfg id, error status will apply
                break;
            }
        default:
            // Unrecognized cluster ID, error status will apply.
            break;
        }
    }
    return result;
}

// Cluster: Basic, server
EmberAfStatus emberAfBasicClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_RESET_TO_FACTORY_DEFAULTS_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfBasicClusterResetToFactoryDefaultsCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Identify, client
EmberAfStatus emberAfIdentifyClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_IDENTIFY_QUERY_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t timeout; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            timeout    = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfIdentifyClusterIdentifyQueryResponseCallback(timeout);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Identify, server
EmberAfStatus emberAfIdentifyClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_IDENTIFY_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t identifyTime; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            identifyTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled   = emberAfIdentifyClusterIdentifyCallback(identifyTime);
            break;
        }
        case ZCL_IDENTIFY_QUERY_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfIdentifyClusterIdentifyQueryCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Groups, client
EmberAfStatus emberAfGroupsClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_ADD_GROUP_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status;   // Ver.: always
            uint16_t groupId; // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            groupId    = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfGroupsClusterAddGroupResponseCallback(status, groupId);
            break;
        }
        case ZCL_VIEW_GROUP_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status;      // Ver.: always
            uint16_t groupId;    // Ver.: always
            uint8_t * groupName; // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupName  = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfGroupsClusterViewGroupResponseCallback(status, groupId, groupName);
            break;
        }
        case ZCL_GET_GROUP_MEMBERSHIP_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t capacity;    // Ver.: always
            uint8_t groupCount;  // Ver.: always
            uint8_t * groupList; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            capacity = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            groupCount = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            groupList  = cmd->buffer + payloadOffset;
            wasHandled = emberAfGroupsClusterGetGroupMembershipResponseCallback(capacity, groupCount, groupList);
            break;
        }
        case ZCL_REMOVE_GROUP_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status;   // Ver.: always
            uint16_t groupId; // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            groupId    = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfGroupsClusterRemoveGroupResponseCallback(status, groupId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Groups, server
EmberAfStatus emberAfGroupsClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_ADD_GROUP_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId;    // Ver.: always
            uint8_t * groupName; // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupName  = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfGroupsClusterAddGroupCallback(groupId, groupName);
            break;
        }
        case ZCL_VIEW_GROUP_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId    = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfGroupsClusterViewGroupCallback(groupId);
            break;
        }
        case ZCL_GET_GROUP_MEMBERSHIP_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t groupCount;  // Ver.: always
            uint8_t * groupList; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupCount = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            groupList  = cmd->buffer + payloadOffset;
            wasHandled = emberAfGroupsClusterGetGroupMembershipCallback(groupCount, groupList);
            break;
        }
        case ZCL_REMOVE_GROUP_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId    = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfGroupsClusterRemoveGroupCallback(groupId);
            break;
        }
        case ZCL_REMOVE_ALL_GROUPS_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfGroupsClusterRemoveAllGroupsCallback();
            break;
        }
        case ZCL_ADD_GROUP_IF_IDENTIFYING_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId;    // Ver.: always
            uint8_t * groupName; // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupName  = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfGroupsClusterAddGroupIfIdentifyingCallback(groupId, groupName);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Scenes, client
EmberAfStatus emberAfScenesClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_ADD_SCENE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status;   // Ver.: always
            uint16_t groupId; // Ver.: always
            uint8_t sceneId;  // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            sceneId    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfScenesClusterAddSceneResponseCallback(status, groupId, sceneId);
            break;
        }
        case ZCL_VIEW_SCENE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status;               // Ver.: always
            uint16_t groupId;             // Ver.: always
            uint8_t sceneId;              // Ver.: always
            uint16_t transitionTime;      // Ver.: always
            uint8_t * sceneName;          // Ver.: always
            uint8_t * extensionFieldSets; // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (!(status == 0))
            {
                // Argument is not always present:
                // - it is conditionally present based on expression: status==0
                transitionTime = 0xFFFF;
            }
            else
            {
                transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 2u;
            }
            if (!(status == 0))
            {
                // Argument is not always present:
                // - it is conditionally present based on expression: status==0
                sceneName = NULL;
            }
            else
            {
                sceneName = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            }
            if (status == 0)
            {
                // Array is conditionally present based on expression: status==0
                extensionFieldSets = cmd->buffer + payloadOffset;
            }
            else
            {
                extensionFieldSets = NULL;
            }
            wasHandled = emberAfScenesClusterViewSceneResponseCallback(status, groupId, sceneId, transitionTime, sceneName,
                                                                       extensionFieldSets);
            break;
        }
        case ZCL_REMOVE_SCENE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status;   // Ver.: always
            uint16_t groupId; // Ver.: always
            uint8_t sceneId;  // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            sceneId    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfScenesClusterRemoveSceneResponseCallback(status, groupId, sceneId);
            break;
        }
        case ZCL_REMOVE_ALL_SCENES_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status;   // Ver.: always
            uint16_t groupId; // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            groupId    = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfScenesClusterRemoveAllScenesResponseCallback(status, groupId);
            break;
        }
        case ZCL_STORE_SCENE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status;   // Ver.: always
            uint16_t groupId; // Ver.: always
            uint8_t sceneId;  // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            sceneId    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfScenesClusterStoreSceneResponseCallback(status, groupId, sceneId);
            break;
        }
        case ZCL_GET_SCENE_MEMBERSHIP_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status;      // Ver.: always
            uint8_t capacity;    // Ver.: always
            uint16_t groupId;    // Ver.: always
            uint8_t sceneCount;  // Ver.: always
            uint8_t * sceneList; // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            capacity = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (!(status == 0))
            {
                // Argument is not always present:
                // - it is conditionally present based on expression: status==0
                sceneCount = 0xFF;
            }
            else
            {
                sceneCount = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if (status == 0)
            {
                // Array is conditionally present based on expression: status==0
                sceneList = cmd->buffer + payloadOffset;
            }
            else
            {
                sceneList = NULL;
            }
            wasHandled = emberAfScenesClusterGetSceneMembershipResponseCallback(status, capacity, groupId, sceneCount, sceneList);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Scenes, server
EmberAfStatus emberAfScenesClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_ADD_SCENE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId;             // Ver.: always
            uint8_t sceneId;              // Ver.: always
            uint16_t transitionTime;      // Ver.: always
            uint8_t * sceneName;          // Ver.: always
            uint8_t * extensionFieldSets; // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            sceneName = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            extensionFieldSets = cmd->buffer + payloadOffset;
            wasHandled = emberAfScenesClusterAddSceneCallback(groupId, sceneId, transitionTime, sceneName, extensionFieldSets);
            break;
        }
        case ZCL_VIEW_SCENE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId; // Ver.: always
            uint8_t sceneId;  // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            sceneId    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfScenesClusterViewSceneCallback(groupId, sceneId);
            break;
        }
        case ZCL_REMOVE_SCENE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId; // Ver.: always
            uint8_t sceneId;  // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            sceneId    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfScenesClusterRemoveSceneCallback(groupId, sceneId);
            break;
        }
        case ZCL_REMOVE_ALL_SCENES_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId    = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfScenesClusterRemoveAllScenesCallback(groupId);
            break;
        }
        case ZCL_STORE_SCENE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId; // Ver.: always
            uint8_t sceneId;  // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            sceneId    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfScenesClusterStoreSceneCallback(groupId, sceneId);
            break;
        }
        case ZCL_RECALL_SCENE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId;        // Ver.: always
            uint8_t sceneId;         // Ver.: always
            uint16_t transitionTime; // Ver.: since zcl-7.0-07-5123-07
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 2u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl-7.0-07-5123-07
                transitionTime = 0xFFFF;
            }
            else
            {
                transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfScenesClusterRecallSceneCallback(groupId, sceneId, transitionTime);
            break;
        }
        case ZCL_GET_SCENE_MEMBERSHIP_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t groupId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            groupId    = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfScenesClusterGetSceneMembershipCallback(groupId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: On/off, server
EmberAfStatus emberAfOnOffClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (cmd->mfgSpecific)
    {
        if (cmd->mfgCode == 0x1002 && cmd->commandId == ZCL_SAMPLE_MFG_SPECIFIC_OFF_WITH_TRANSITION_COMMAND_ID)
        {
            // Command is fixed length: 0
            wasHandled = emberAfOnOffClusterSampleMfgSpecificOffWithTransitionCallback();
        }
        else if (cmd->mfgCode == 0x1002 && cmd->commandId == ZCL_SAMPLE_MFG_SPECIFIC_ON_WITH_TRANSITION_COMMAND_ID)
        {
            // Command is fixed length: 0
            wasHandled = emberAfOnOffClusterSampleMfgSpecificOnWithTransitionCallback();
        }
        else if (cmd->mfgCode == 0x1002 && cmd->commandId == ZCL_SAMPLE_MFG_SPECIFIC_TOGGLE_WITH_TRANSITION_COMMAND_ID)
        {
            // Command is fixed length: 0
            wasHandled = emberAfOnOffClusterSampleMfgSpecificToggleWithTransitionCallback();
        }
        else if (cmd->mfgCode == 0x1049 && cmd->commandId == ZCL_SAMPLE_MFG_SPECIFIC_ON_WITH_TRANSITION2_COMMAND_ID)
        {
            // Command is fixed length: 0
            wasHandled = emberAfOnOffClusterSampleMfgSpecificOnWithTransition2Callback();
        }
    }
    else
    {
        switch (cmd->commandId)
        {
        case ZCL_OFF_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfOnOffClusterOffCallback();
            break;
        }
        case ZCL_ON_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfOnOffClusterOnCallback();
            break;
        }
        case ZCL_TOGGLE_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfOnOffClusterToggleCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Level Control, server
EmberAfStatus emberAfLevelControlClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_MOVE_TO_LEVEL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t level;           // Ver.: always
            uint16_t transitionTime; // Ver.: always
            uint8_t optionMask;      // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionOverride;  // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            level = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionMask = 0xFF;
            }
            else
            {
                optionMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionOverride = 0xFF;
            }
            else
            {
                optionOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfLevelControlClusterMoveToLevelCallback(level, transitionTime, optionMask, optionOverride);
            break;
        }
        case ZCL_MOVE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t moveMode;       // Ver.: always
            uint8_t rate;           // Ver.: always
            uint8_t optionMask;     // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionOverride; // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionMask = 0xFF;
            }
            else
            {
                optionMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionOverride = 0xFF;
            }
            else
            {
                optionOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfLevelControlClusterMoveCallback(moveMode, rate, optionMask, optionOverride);
            break;
        }
        case ZCL_STEP_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t stepMode;        // Ver.: always
            uint8_t stepSize;        // Ver.: always
            uint16_t transitionTime; // Ver.: always
            uint8_t optionMask;      // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionOverride;  // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionMask = 0xFF;
            }
            else
            {
                optionMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionOverride = 0xFF;
            }
            else
            {
                optionOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfLevelControlClusterStepCallback(stepMode, stepSize, transitionTime, optionMask, optionOverride);
            break;
        }
        case ZCL_STOP_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t optionMask;     // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionOverride; // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionMask = 0xFF;
            }
            else
            {
                optionMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionOverride = 0xFF;
            }
            else
            {
                optionOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfLevelControlClusterStopCallback(optionMask, optionOverride);
            break;
        }
        case ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t level;           // Ver.: always
            uint16_t transitionTime; // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            level = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfLevelControlClusterMoveToLevelWithOnOffCallback(level, transitionTime);
            break;
        }
        case ZCL_MOVE_WITH_ON_OFF_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t moveMode; // Ver.: always
            uint8_t rate;     // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            rate       = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfLevelControlClusterMoveWithOnOffCallback(moveMode, rate);
            break;
        }
        case ZCL_STEP_WITH_ON_OFF_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t stepMode;        // Ver.: always
            uint8_t stepSize;        // Ver.: always
            uint16_t transitionTime; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfLevelControlClusterStepWithOnOffCallback(stepMode, stepSize, transitionTime);
            break;
        }
        case ZCL_STOP_WITH_ON_OFF_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfLevelControlClusterStopWithOnOffCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Door Lock, client
EmberAfStatus emberAfDoorLockClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_LOCK_DOOR_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status     = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterLockDoorResponseCallback(status);
            break;
        }
        case ZCL_UNLOCK_DOOR_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t status; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            status     = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterUnlockDoorResponseCallback(status);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Door Lock, server
EmberAfStatus emberAfDoorLockClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_LOCK_DOOR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * PIN; // Ver.: since ha-1.2-05-3520-29
            // Command is not a fixed length
            if ((cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: ha-1.2-05-3520-29
                PIN = NULL;
            }
            else
            {
                PIN = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfDoorLockClusterLockDoorCallback(PIN);
            break;
        }
        case ZCL_UNLOCK_DOOR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * PIN; // Ver.: since ha-1.2-05-3520-29
            // Command is not a fixed length
            if ((cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: ha-1.2-05-3520-29
                PIN = NULL;
            }
            else
            {
                PIN = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfDoorLockClusterUnlockDoorCallback(PIN);
            break;
        }
        case ZCL_UNLOCK_WITH_TIMEOUT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t timeoutInSeconds; // Ver.: always
            uint8_t * pin;             // Ver.: since ha-1.2-05-3520-29
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            timeoutInSeconds = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if ((cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: ha-1.2-05-3520-29
                pin = NULL;
            }
            else
            {
                pin = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfDoorLockClusterUnlockWithTimeoutCallback(timeoutInSeconds, pin);
            break;
        }
        case ZCL_GET_LOG_RECORD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t logIndex; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            logIndex   = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterGetLogRecordCallback(logIndex);
            break;
        }
        case ZCL_SET_PIN_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t userId;    // Ver.: always
            uint8_t userStatus; // Ver.: always
            uint8_t userType;   // Ver.: always
            uint8_t * pin;      // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            pin        = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterSetPinCallback(userId, userStatus, userType, pin);
            break;
        }
        case ZCL_GET_PIN_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t userId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userId     = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterGetPinCallback(userId);
            break;
        }
        case ZCL_CLEAR_PIN_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t userId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userId     = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterClearPinCallback(userId);
            break;
        }
        case ZCL_CLEAR_ALL_PINS_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfDoorLockClusterClearAllPinsCallback();
            break;
        }
        case ZCL_SET_WEEKDAY_SCHEDULE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t scheduleId;  // Ver.: always
            uint16_t userId;     // Ver.: always
            uint8_t daysMask;    // Ver.: always
            uint8_t startHour;   // Ver.: always
            uint8_t startMinute; // Ver.: always
            uint8_t endHour;     // Ver.: always
            uint8_t endMinute;   // Ver.: always
            // Command is fixed length: 8
            if (cmd->bufLen < payloadOffset + 8u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            scheduleId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            userId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            daysMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            startHour = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            startMinute = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            endHour = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            endMinute  = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterSetWeekdayScheduleCallback(scheduleId, userId, daysMask, startHour, startMinute,
                                                                          endHour, endMinute);
            break;
        }
        case ZCL_GET_WEEKDAY_SCHEDULE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t scheduleId; // Ver.: always
            uint16_t userId;    // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            scheduleId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            userId     = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterGetWeekdayScheduleCallback(scheduleId, userId);
            break;
        }
        case ZCL_CLEAR_WEEKDAY_SCHEDULE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t scheduleId; // Ver.: always
            uint16_t userId;    // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            scheduleId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            userId     = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterClearWeekdayScheduleCallback(scheduleId, userId);
            break;
        }
        case ZCL_SET_YEARDAY_SCHEDULE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t scheduleId;      // Ver.: always
            uint16_t userId;         // Ver.: always
            uint32_t localStartTime; // Ver.: always
            uint32_t localEndTime;   // Ver.: always
            // Command is fixed length: 11
            if (cmd->bufLen < payloadOffset + 11u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            scheduleId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            userId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            localStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            localEndTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled   = emberAfDoorLockClusterSetYeardayScheduleCallback(scheduleId, userId, localStartTime, localEndTime);
            break;
        }
        case ZCL_GET_YEARDAY_SCHEDULE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t scheduleId; // Ver.: always
            uint16_t userId;    // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            scheduleId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            userId     = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterGetYeardayScheduleCallback(scheduleId, userId);
            break;
        }
        case ZCL_CLEAR_YEARDAY_SCHEDULE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t scheduleId; // Ver.: always
            uint16_t userId;    // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            scheduleId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            userId     = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterClearYeardayScheduleCallback(scheduleId, userId);
            break;
        }
        case ZCL_SET_HOLIDAY_SCHEDULE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t scheduleId;                 // Ver.: always
            uint32_t localStartTime;            // Ver.: always
            uint32_t localEndTime;              // Ver.: always
            uint8_t operatingModeDuringHoliday; // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            scheduleId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            localStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            localEndTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            operatingModeDuringHoliday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                 = emberAfDoorLockClusterSetHolidayScheduleCallback(scheduleId, localStartTime, localEndTime,
                                                                          operatingModeDuringHoliday);
            break;
        }
        case ZCL_GET_HOLIDAY_SCHEDULE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t scheduleId; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            scheduleId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterGetHolidayScheduleCallback(scheduleId);
            break;
        }
        case ZCL_CLEAR_HOLIDAY_SCHEDULE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t scheduleId; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            scheduleId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterClearHolidayScheduleCallback(scheduleId);
            break;
        }
        case ZCL_SET_USER_TYPE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t userId;  // Ver.: always
            uint8_t userType; // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            userType   = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterSetUserTypeCallback(userId, userType);
            break;
        }
        case ZCL_GET_USER_TYPE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t userId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userId     = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterGetUserTypeCallback(userId);
            break;
        }
        case ZCL_SET_RFID_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t userId;    // Ver.: always
            uint8_t userStatus; // Ver.: always
            uint8_t userType;   // Ver.: always
            uint8_t * id;       // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            id         = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterSetRfidCallback(userId, userStatus, userType, id);
            break;
        }
        case ZCL_GET_RFID_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t userId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userId     = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterGetRfidCallback(userId);
            break;
        }
        case ZCL_CLEAR_RFID_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t userId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            userId     = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDoorLockClusterClearRfidCallback(userId);
            break;
        }
        case ZCL_CLEAR_ALL_RFIDS_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfDoorLockClusterClearAllRfidsCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Window Covering, server
EmberAfStatus emberAfWindowCoveringClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_WINDOW_COVERING_UP_OPEN_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfWindowCoveringClusterWindowCoveringUpOpenCallback();
            break;
        }
        case ZCL_WINDOW_COVERING_DOWN_CLOSE_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfWindowCoveringClusterWindowCoveringDownCloseCallback();
            break;
        }
        case ZCL_WINDOW_COVERING_STOP_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfWindowCoveringClusterWindowCoveringStopCallback();
            break;
        }
        case ZCL_WINDOW_COVERING_GO_TO_LIFT_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t liftValue; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            liftValue  = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfWindowCoveringClusterWindowCoveringGoToLiftValueCallback(liftValue);
            break;
        }
        case ZCL_WINDOW_COVERING_GO_TO_LIFT_PERCENTAGE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t percentageLiftValue; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            percentageLiftValue = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled          = emberAfWindowCoveringClusterWindowCoveringGoToLiftPercentageCallback(percentageLiftValue);
            break;
        }
        case ZCL_WINDOW_COVERING_GO_TO_TILT_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tiltValue; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tiltValue  = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfWindowCoveringClusterWindowCoveringGoToTiltValueCallback(tiltValue);
            break;
        }
        case ZCL_WINDOW_COVERING_GO_TO_TILT_PERCENTAGE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t percentageTiltValue; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            percentageTiltValue = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled          = emberAfWindowCoveringClusterWindowCoveringGoToTiltPercentageCallback(percentageTiltValue);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Barrier Control, server
EmberAfStatus emberAfBarrierControlClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_BARRIER_CONTROL_GO_TO_PERCENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t percentOpen; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            percentOpen = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled  = emberAfBarrierControlClusterBarrierControlGoToPercentCallback(percentOpen);
            break;
        }
        case ZCL_BARRIER_CONTROL_STOP_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfBarrierControlClusterBarrierControlStopCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Color Control, server
EmberAfStatus emberAfColorControlClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_MOVE_TO_HUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t hue;             // Ver.: always
            uint8_t direction;       // Ver.: always
            uint16_t transitionTime; // Ver.: always
            uint8_t optionsMask;     // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionsOverride; // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            hue = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            direction = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsMask = 0xFF;
            }
            else
            {
                optionsMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsOverride = 0xFF;
            }
            else
            {
                optionsOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfColorControlClusterMoveToHueCallback(hue, direction, transitionTime, optionsMask, optionsOverride);
            break;
        }
        case ZCL_MOVE_HUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t moveMode;        // Ver.: always
            uint8_t rate;            // Ver.: always
            uint8_t optionsMask;     // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionsOverride; // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsMask = 0xFF;
            }
            else
            {
                optionsMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsOverride = 0xFF;
            }
            else
            {
                optionsOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfColorControlClusterMoveHueCallback(moveMode, rate, optionsMask, optionsOverride);
            break;
        }
        case ZCL_STEP_HUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t stepMode;        // Ver.: always
            uint8_t stepSize;        // Ver.: always
            uint8_t transitionTime;  // Ver.: always
            uint8_t optionsMask;     // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionsOverride; // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            transitionTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsMask = 0xFF;
            }
            else
            {
                optionsMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsOverride = 0xFF;
            }
            else
            {
                optionsOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled =
                emberAfColorControlClusterStepHueCallback(stepMode, stepSize, transitionTime, optionsMask, optionsOverride);
            break;
        }
        case ZCL_MOVE_TO_SATURATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t saturation;      // Ver.: always
            uint16_t transitionTime; // Ver.: always
            uint8_t optionsMask;     // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionsOverride; // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            saturation = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsMask = 0xFF;
            }
            else
            {
                optionsMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsOverride = 0xFF;
            }
            else
            {
                optionsOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled =
                emberAfColorControlClusterMoveToSaturationCallback(saturation, transitionTime, optionsMask, optionsOverride);
            break;
        }
        case ZCL_MOVE_SATURATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t moveMode;        // Ver.: always
            uint8_t rate;            // Ver.: always
            uint8_t optionsMask;     // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionsOverride; // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsMask = 0xFF;
            }
            else
            {
                optionsMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsOverride = 0xFF;
            }
            else
            {
                optionsOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfColorControlClusterMoveSaturationCallback(moveMode, rate, optionsMask, optionsOverride);
            break;
        }
        case ZCL_STEP_SATURATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t stepMode;        // Ver.: always
            uint8_t stepSize;        // Ver.: always
            uint8_t transitionTime;  // Ver.: always
            uint8_t optionsMask;     // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionsOverride; // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            transitionTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsMask = 0xFF;
            }
            else
            {
                optionsMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsOverride = 0xFF;
            }
            else
            {
                optionsOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled =
                emberAfColorControlClusterStepSaturationCallback(stepMode, stepSize, transitionTime, optionsMask, optionsOverride);
            break;
        }
        case ZCL_MOVE_TO_HUE_AND_SATURATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t hue;             // Ver.: always
            uint8_t saturation;      // Ver.: always
            uint16_t transitionTime; // Ver.: always
            uint8_t optionsMask;     // Ver.: since zcl6-errata-14-0129-15
            uint8_t optionsOverride; // Ver.: since zcl6-errata-14-0129-15
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            hue = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            saturation = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsMask = 0xFF;
            }
            else
            {
                optionsMask = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: zcl6-errata-14-0129-15
                optionsOverride = 0xFF;
            }
            else
            {
                optionsOverride = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfColorControlClusterMoveToHueAndSaturationCallback(hue, saturation, transitionTime, optionsMask,
                                                                                  optionsOverride);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: IAS Zone, client
EmberAfStatus emberAfIasZoneClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_ZONE_STATUS_CHANGE_NOTIFICATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t zoneStatus;    // Ver.: always
            uint8_t extendedStatus; // Ver.: always
            uint8_t zoneId;         // Ver.: since ha-1.2-05-3520-29
            uint16_t delay;         // Ver.: since ha-1.2-05-3520-29
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            zoneStatus = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            extendedStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: ha-1.2-05-3520-29
                zoneId = 0xFF;
            }
            else
            {
                zoneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 2u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: ha-1.2-05-3520-29
                delay = 0xFFFF;
            }
            else
            {
                delay = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfIasZoneClusterZoneStatusChangeNotificationCallback(zoneStatus, extendedStatus, zoneId, delay);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: IAS ACE, server
EmberAfStatus emberAfIasAceClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_BYPASS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t numberOfZones;   // Ver.: always
            uint8_t * zoneIds;       // Ver.: always
            uint8_t * armDisarmCode; // Ver.: since ha-1.2.1-05-3520-30
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfZones = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            zoneIds = cmd->buffer + payloadOffset;
            payloadOffset += numberOfZones * sizeof(uint8_t);
            if ((cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: ha-1.2.1-05-3520-30
                armDisarmCode = NULL;
            }
            else
            {
                armDisarmCode = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfIasAceClusterBypassCallback(numberOfZones, zoneIds, armDisarmCode);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Generic Tunnel, client
EmberAfStatus emberAfGenericTunnelClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_MATCH_PROTOCOL_ADDRESS_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * deviceIeeeAddress; // Ver.: always
            uint8_t * protocolAddress;   // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 8u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            deviceIeeeAddress = cmd->buffer + payloadOffset;
            payloadOffset += 8u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            protocolAddress = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled      = emberAfGenericTunnelClusterMatchProtocolAddressResponseCallback(deviceIeeeAddress, protocolAddress);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: 11073 Protocol Tunnel, server
EmberAfStatus emberAf11073ProtocolTunnelClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_TRANSFER_A_P_D_U_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * apdu; // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            apdu       = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAf11073ProtocolTunnelClusterTransferAPDUCallback(apdu);
            break;
        }
        case ZCL_CONNECT_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t connectControl;  // Ver.: always
            uint16_t idleTimeout;    // Ver.: always
            uint8_t * managerTarget; // Ver.: always
            uint8_t managerEndpoint; // Ver.: always
            // Command is fixed length: 12
            if (cmd->bufLen < payloadOffset + 12u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            connectControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            idleTimeout = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            managerTarget = cmd->buffer + payloadOffset;
            payloadOffset += 8u;
            managerEndpoint = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled      = emberAf11073ProtocolTunnelClusterConnectRequestCallback(connectControl, idleTimeout, managerTarget,
                                                                                 managerEndpoint);
            break;
        }
        case ZCL_DISCONNECT_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * managerIEEEAddress; // Ver.: always
            // Command is fixed length: 8
            if (cmd->bufLen < payloadOffset + 8u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            managerIEEEAddress = cmd->buffer + payloadOffset;
            wasHandled         = emberAf11073ProtocolTunnelClusterDisconnectRequestCallback(managerIEEEAddress);
            break;
        }
        case ZCL_CONNECT_STATUS_NOTIFICATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t connectStatus; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            connectStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled    = emberAf11073ProtocolTunnelClusterConnectStatusNotificationCallback(connectStatus);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Price, client
EmberAfStatus emberAfPriceClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_PRICE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                       // Ver.: always
            uint8_t * rateLabel;                       // Ver.: always
            uint32_t issuerEventId;                    // Ver.: always
            uint32_t currentTime;                      // Ver.: always
            uint8_t unitOfMeasure;                     // Ver.: always
            uint16_t currency;                         // Ver.: always
            uint8_t priceTrailingDigitAndPriceTier;    // Ver.: always
            uint8_t numberOfPriceTiersAndRegisterTier; // Ver.: always
            uint32_t startTime;                        // Ver.: always
            uint16_t durationInMinutes;                // Ver.: always
            uint32_t price;                            // Ver.: always
            uint8_t priceRatio;                        // Ver.: always
            uint32_t generationPrice;                  // Ver.: always
            uint8_t generationPriceRatio;              // Ver.: always
            uint32_t alternateCostDelivered;           // Ver.: since se-1.0-07-5356-15
            uint8_t alternateCostUnit;                 // Ver.: since se-1.0-07-5356-15
            uint8_t alternateCostTrailingDigit;        // Ver.: since se-1.0-07-5356-15
            uint8_t numberOfBlockThresholds;           // Ver.: since se-1.1-07-5356-16
            uint8_t priceControl;                      // Ver.: since se-1.1-07-5356-16
            uint8_t numberOfGenerationTiers;           // Ver.: since se-1.2a-07-5356-19
            uint8_t generationTier;                    // Ver.: since se-1.2a-07-5356-19
            uint8_t extendedNumberOfPriceTiers;        // Ver.: since se-1.2a-07-5356-19
            uint8_t extendedPriceTier;                 // Ver.: since se-1.2a-07-5356-19
            uint8_t extendedRegisterTier;              // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            rateLabel = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currentTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            unitOfMeasure = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            priceTrailingDigitAndPriceTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfPriceTiersAndRegisterTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            price = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            priceRatio = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            generationPrice = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            generationPriceRatio = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 4u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.0-07-5356-15
                alternateCostDelivered = 0xFFFFFFFF;
            }
            else
            {
                alternateCostDelivered = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 4u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.0-07-5356-15
                alternateCostUnit = 0xFF;
            }
            else
            {
                alternateCostUnit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.0-07-5356-15
                alternateCostTrailingDigit = 0xFF;
            }
            else
            {
                alternateCostTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1-07-5356-16
                numberOfBlockThresholds = 0xFF;
            }
            else
            {
                numberOfBlockThresholds = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1-07-5356-16
                priceControl = 0x00;
            }
            else
            {
                priceControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                numberOfGenerationTiers = 0x00;
            }
            else
            {
                numberOfGenerationTiers = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                generationTier = 0x00;
            }
            else
            {
                generationTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                extendedNumberOfPriceTiers = 0x00;
            }
            else
            {
                extendedNumberOfPriceTiers = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                extendedPriceTier = 0x00;
            }
            else
            {
                extendedPriceTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                extendedRegisterTier = 0x00;
            }
            else
            {
                extendedRegisterTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfPriceClusterPublishPriceCallback(
                providerId, rateLabel, issuerEventId, currentTime, unitOfMeasure, currency, priceTrailingDigitAndPriceTier,
                numberOfPriceTiersAndRegisterTier, startTime, durationInMinutes, price, priceRatio, generationPrice,
                generationPriceRatio, alternateCostDelivered, alternateCostUnit, alternateCostTrailingDigit,
                numberOfBlockThresholds, priceControl, numberOfGenerationTiers, generationTier, extendedNumberOfPriceTiers,
                extendedPriceTier, extendedRegisterTier);
            break;
        }
        case ZCL_PUBLISH_BLOCK_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;             // Ver.: always
            uint32_t issuerEventId;          // Ver.: always
            uint32_t blockPeriodStartTime;   // Ver.: always
            uint32_t blockPeriodDuration;    // Ver.: always
            uint8_t blockPeriodControl;      // Ver.: always
            uint8_t blockPeriodDurationType; // Ver.: since se-1.2a-07-5356-19
            uint8_t tariffType;              // Ver.: since se-1.2a-07-5356-19
            uint8_t tariffResolutionPeriod;  // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                blockPeriodDurationType = 0xFF;
            }
            else
            {
                blockPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                tariffType = 0xFF;
            }
            else
            {
                tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                tariffResolutionPeriod = 0xFF;
            }
            else
            {
                tariffResolutionPeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfPriceClusterPublishBlockPeriodCallback(providerId, issuerEventId, blockPeriodStartTime,
                                                                       blockPeriodDuration, blockPeriodControl,
                                                                       blockPeriodDurationType, tariffType, tariffResolutionPeriod);
            break;
        }
        case ZCL_PUBLISH_CONVERSION_FACTOR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;                // Ver.: always
            uint32_t startTime;                    // Ver.: always
            uint32_t conversionFactor;             // Ver.: always
            uint8_t conversionFactorTrailingDigit; // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactor = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactorTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishConversionFactorCallback(issuerEventId, startTime, conversionFactor,
                                                                            conversionFactorTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_CALORIFIC_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;              // Ver.: always
            uint32_t startTime;                  // Ver.: always
            uint32_t calorificValue;             // Ver.: always
            uint8_t calorificValueUnit;          // Ver.: always
            uint8_t calorificValueTrailingDigit; // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calorificValue = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calorificValueUnit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            calorificValueTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                  = emberAfPriceClusterPublishCalorificValueCallback(issuerEventId, startTime, calorificValue,
                                                                          calorificValueUnit, calorificValueTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_TARIFF_INFORMATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                  // Ver.: always
            uint32_t issuerEventId;               // Ver.: always
            uint32_t issuerTariffId;              // Ver.: always
            uint32_t startTime;                   // Ver.: always
            uint8_t tariffTypeChargingScheme;     // Ver.: always
            uint8_t * tariffLabel;                // Ver.: always
            uint8_t numberOfPriceTiersInUse;      // Ver.: always
            uint8_t numberOfBlockThresholdsInUse; // Ver.: always
            uint8_t unitOfMeasure;                // Ver.: always
            uint16_t currency;                    // Ver.: always
            uint8_t priceTrailingDigit;           // Ver.: always
            uint32_t standingCharge;              // Ver.: always
            uint8_t tierBlockMode;                // Ver.: always
            uint32_t blockThresholdMultiplier;    // Ver.: always
            uint32_t blockThresholdDivisor;       // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffTypeChargingScheme = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffLabel = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfPriceTiersInUse = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfBlockThresholdsInUse = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            unitOfMeasure = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            priceTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            standingCharge = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tierBlockMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockThresholdMultiplier = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockThresholdDivisor = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled            = emberAfPriceClusterPublishTariffInformationCallback(
                providerId, issuerEventId, issuerTariffId, startTime, tariffTypeChargingScheme, tariffLabel,
                numberOfPriceTiersInUse, numberOfBlockThresholdsInUse, unitOfMeasure, currency, priceTrailingDigit, standingCharge,
                tierBlockMode, blockThresholdMultiplier, blockThresholdDivisor);
            break;
        }
        case ZCL_PUBLISH_BLOCK_THRESHOLDS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerEventId;    // Ver.: always
            uint32_t startTime;        // Ver.: always
            uint32_t issuerTariffId;   // Ver.: always
            uint8_t commandIndex;      // Ver.: always
            uint8_t numberOfCommands;  // Ver.: always
            uint8_t subPayloadControl; // Ver.: always
            uint8_t * payload;         // Ver.: always
            // Command is fixed length: 19
            if (cmd->bufLen < payloadOffset + 19u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            subPayloadControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            payload    = cmd->buffer + payloadOffset;
            wasHandled = emberAfPriceClusterPublishBlockThresholdsCallback(
                providerId, issuerEventId, startTime, issuerTariffId, commandIndex, numberOfCommands, subPayloadControl, payload);
            break;
        }
        case ZCL_PUBLISH_C_O2_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;           // Ver.: always
            uint32_t issuerEventId;        // Ver.: always
            uint32_t startTime;            // Ver.: always
            uint8_t tariffType;            // Ver.: always
            uint32_t cO2Value;             // Ver.: always
            uint8_t cO2ValueUnit;          // Ver.: always
            uint8_t cO2ValueTrailingDigit; // Ver.: always
            // Command is fixed length: 19
            if (cmd->bufLen < payloadOffset + 19u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cO2Value = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            cO2ValueUnit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cO2ValueTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishCO2ValueCallback(providerId, issuerEventId, startTime, tariffType, cO2Value,
                                                                    cO2ValueUnit, cO2ValueTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_TIER_LABELS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;         // Ver.: always
            uint32_t issuerEventId;      // Ver.: always
            uint32_t issuerTariffId;     // Ver.: always
            uint8_t commandIndex;        // Ver.: always
            uint8_t numberOfCommands;    // Ver.: always
            uint8_t numberOfLabels;      // Ver.: always
            uint8_t * tierLabelsPayload; // Ver.: always
            // Command is fixed length: 15
            if (cmd->bufLen < payloadOffset + 15u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfLabels = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tierLabelsPayload = cmd->buffer + payloadOffset;
            wasHandled = emberAfPriceClusterPublishTierLabelsCallback(providerId, issuerEventId, issuerTariffId, commandIndex,
                                                                      numberOfCommands, numberOfLabels, tierLabelsPayload);
            break;
        }
        case ZCL_PUBLISH_BILLING_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;               // Ver.: always
            uint32_t issuerEventId;            // Ver.: always
            uint32_t billingPeriodStartTime;   // Ver.: always
            uint32_t billingPeriodDuration;    // Ver.: always
            uint8_t billingPeriodDurationType; // Ver.: always
            uint8_t tariffType;                // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            billingPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishBillingPeriodCallback(
                providerId, issuerEventId, billingPeriodStartTime, billingPeriodDuration, billingPeriodDurationType, tariffType);
            break;
        }
        case ZCL_PUBLISH_CONSOLIDATED_BILL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;               // Ver.: always
            uint32_t issuerEventId;            // Ver.: always
            uint32_t billingPeriodStartTime;   // Ver.: always
            uint32_t billingPeriodDuration;    // Ver.: always
            uint8_t billingPeriodDurationType; // Ver.: always
            uint8_t tariffType;                // Ver.: always
            uint32_t consolidatedBill;         // Ver.: always
            uint16_t currency;                 // Ver.: always
            uint8_t billTrailingDigit;         // Ver.: always
            // Command is fixed length: 24
            if (cmd->bufLen < payloadOffset + 24u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            billingPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            consolidatedBill = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            currency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            billTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled        = emberAfPriceClusterPublishConsolidatedBillCallback(
                providerId, issuerEventId, billingPeriodStartTime, billingPeriodDuration, billingPeriodDurationType, tariffType,
                consolidatedBill, currency, billTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_CPP_EVENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;        // Ver.: always
            uint32_t issuerEventId;     // Ver.: always
            uint32_t startTime;         // Ver.: always
            uint16_t durationInMinutes; // Ver.: always
            uint8_t tariffType;         // Ver.: always
            uint8_t cppPriceTier;       // Ver.: always
            uint8_t cppAuth;            // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cppPriceTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cppAuth    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishCppEventCallback(providerId, issuerEventId, startTime, durationInMinutes,
                                                                    tariffType, cppPriceTier, cppAuth);
            break;
        }
        case ZCL_PUBLISH_CREDIT_PAYMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                 // Ver.: always
            uint32_t issuerEventId;              // Ver.: always
            uint32_t creditPaymentDueDate;       // Ver.: always
            uint32_t creditPaymentOverDueAmount; // Ver.: always
            uint8_t creditPaymentStatus;         // Ver.: always
            uint32_t creditPayment;              // Ver.: always
            uint32_t creditPaymentDate;          // Ver.: always
            uint8_t * creditPaymentRef;          // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentDueDate = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentOverDueAmount = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPayment = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentDate = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentRef = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled       = emberAfPriceClusterPublishCreditPaymentCallback(providerId, issuerEventId, creditPaymentDueDate,
                                                                         creditPaymentOverDueAmount, creditPaymentStatus,
                                                                         creditPayment, creditPaymentDate, creditPaymentRef);
            break;
        }
        case ZCL_PUBLISH_CURRENCY_CONVERSION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                   // Ver.: always
            uint32_t issuerEventId;                // Ver.: always
            uint32_t startTime;                    // Ver.: always
            uint16_t oldCurrency;                  // Ver.: always
            uint16_t newCurrency;                  // Ver.: always
            uint32_t conversionFactor;             // Ver.: always
            uint8_t conversionFactorTrailingDigit; // Ver.: always
            uint32_t currencyChangeControlFlags;   // Ver.: always
            // Command is fixed length: 25
            if (cmd->bufLen < payloadOffset + 25u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            oldCurrency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            newCurrency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            conversionFactor = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactorTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            currencyChangeControlFlags = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                 = emberAfPriceClusterPublishCurrencyConversionCallback(
                providerId, issuerEventId, startTime, oldCurrency, newCurrency, conversionFactor, conversionFactorTrailingDigit,
                currencyChangeControlFlags);
            break;
        }
        case ZCL_CANCEL_TARIFF_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;     // Ver.: always
            uint32_t issuerTariffId; // Ver.: always
            uint8_t tariffType;      // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterCancelTariffCallback(providerId, issuerTariffId, tariffType);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Price, server
EmberAfStatus emberAfPriceClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_CURRENT_PRICE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t commandOptions; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            commandOptions = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetCurrentPriceCallback(commandOptions);
            break;
        }
        case ZCL_GET_SCHEDULED_PRICES_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t startTime;     // Ver.: always
            uint8_t numberOfEvents; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetScheduledPricesCallback(startTime, numberOfEvents);
            break;
        }
        case ZCL_PRICE_ACKNOWLEDGEMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;    // Ver.: always
            uint32_t issuerEventId; // Ver.: always
            uint32_t priceAckTime;  // Ver.: always
            uint8_t control;        // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            priceAckTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            control    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPriceAcknowledgementCallback(providerId, issuerEventId, priceAckTime, control);
            break;
        }
        case ZCL_GET_BLOCK_PERIODS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t startTime;     // Ver.: always
            uint8_t numberOfEvents; // Ver.: always
            uint8_t tariffType;     // Ver.: always
            // Command is fixed length: 6
            if (cmd->bufLen < payloadOffset + 6u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterGetBlockPeriodsCallback(startTime, numberOfEvents, tariffType);
            break;
        }
        case ZCL_GET_CONVERSION_FACTOR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterGetConversionFactorCallback(earliestStartTime, minIssuerEventId, numberOfCommands);
            break;
        }
        case ZCL_GET_CALORIFIC_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled       = emberAfPriceClusterGetCalorificValueCallback(earliestStartTime, minIssuerEventId, numberOfCommands);
            break;
        }
        case ZCL_GET_TARIFF_INFORMATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfPriceClusterGetTariffInformationCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_GET_PRICE_MATRIX_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerTariffId; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetPriceMatrixCallback(issuerTariffId);
            break;
        }
        case ZCL_GET_BLOCK_THRESHOLDS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerTariffId; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetBlockThresholdsCallback(issuerTariffId);
            break;
        }
        case ZCL_GET_C_O2_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterGetCO2ValueCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_GET_TIER_LABELS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerTariffId; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetTierLabelsCallback(issuerTariffId);
            break;
        }
        case ZCL_GET_BILLING_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfPriceClusterGetBillingPeriodCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_GET_CONSOLIDATED_BILL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfPriceClusterGetConsolidatedBillCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_CPP_EVENT_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId; // Ver.: always
            uint8_t cppAuth;        // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            cppAuth    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterCppEventResponseCallback(issuerEventId, cppAuth);
            break;
        }
        case ZCL_GET_CREDIT_PAYMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t latestEndTime;  // Ver.: always
            uint8_t numberOfRecords; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            latestEndTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfRecords = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled      = emberAfPriceClusterGetCreditPaymentCallback(latestEndTime, numberOfRecords);
            break;
        }
        case ZCL_GET_CURRENCY_CONVERSION_COMMAND_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfPriceClusterGetCurrencyConversionCommandCallback();
            break;
        }
        case ZCL_GET_TARIFF_CANCELLATION_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfPriceClusterGetTariffCancellationCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Demand Response and Load Control, client
EmberAfStatus emberAfDemandResponseLoadControlClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_LOAD_CONTROL_EVENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;                 // Ver.: always
            uint16_t deviceClass;                   // Ver.: always
            uint8_t utilityEnrollmentGroup;         // Ver.: always
            uint32_t startTime;                     // Ver.: always
            uint16_t durationInMinutes;             // Ver.: always
            uint8_t criticalityLevel;               // Ver.: always
            uint8_t coolingTemperatureOffset;       // Ver.: always
            uint8_t heatingTemperatureOffset;       // Ver.: always
            int16_t coolingTemperatureSetPoint;     // Ver.: always
            int16_t heatingTemperatureSetPoint;     // Ver.: always
            int8_t averageLoadAdjustmentPercentage; // Ver.: always
            uint8_t dutyCycle;                      // Ver.: always
            uint8_t eventControl;                   // Ver.: always
            // Command is fixed length: 23
            if (cmd->bufLen < payloadOffset + 23u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            deviceClass = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            utilityEnrollmentGroup = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            criticalityLevel = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            coolingTemperatureOffset = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            heatingTemperatureOffset = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            coolingTemperatureSetPoint = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            heatingTemperatureSetPoint = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            averageLoadAdjustmentPercentage = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dutyCycle = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled   = emberAfDemandResponseLoadControlClusterLoadControlEventCallback(
                issuerEventId, deviceClass, utilityEnrollmentGroup, startTime, durationInMinutes, criticalityLevel,
                coolingTemperatureOffset, heatingTemperatureOffset, coolingTemperatureSetPoint, heatingTemperatureSetPoint,
                averageLoadAdjustmentPercentage, dutyCycle, eventControl);
            break;
        }
        case ZCL_CANCEL_LOAD_CONTROL_EVENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;         // Ver.: always
            uint16_t deviceClass;           // Ver.: always
            uint8_t utilityEnrollmentGroup; // Ver.: always
            uint8_t cancelControl;          // Ver.: always
            uint32_t effectiveTime;         // Ver.: always
            // Command is fixed length: 12
            if (cmd->bufLen < payloadOffset + 12u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            deviceClass = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            utilityEnrollmentGroup = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cancelControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            effectiveTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled    = emberAfDemandResponseLoadControlClusterCancelLoadControlEventCallback(
                issuerEventId, deviceClass, utilityEnrollmentGroup, cancelControl, effectiveTime);
            break;
        }
        case ZCL_CANCEL_ALL_LOAD_CONTROL_EVENTS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t cancelControl; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            cancelControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled    = emberAfDemandResponseLoadControlClusterCancelAllLoadControlEventsCallback(cancelControl);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Demand Response and Load Control, server
EmberAfStatus emberAfDemandResponseLoadControlClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_REPORT_EVENT_STATUS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;                        // Ver.: always
            uint8_t eventStatus;                           // Ver.: always
            uint32_t eventStatusTime;                      // Ver.: always
            uint8_t criticalityLevelApplied;               // Ver.: always
            uint16_t coolingTemperatureSetPointApplied;    // Ver.: always
            uint16_t heatingTemperatureSetPointApplied;    // Ver.: always
            int8_t averageLoadAdjustmentPercentageApplied; // Ver.: always
            uint8_t dutyCycleApplied;                      // Ver.: always
            uint8_t eventControl;                          // Ver.: always
            uint8_t signatureType;                         // Ver.: always
            uint8_t * signature;                           // Ver.: always
            // Command is fixed length: 60
            if (cmd->bufLen < payloadOffset + 60u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            eventStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventStatusTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            criticalityLevelApplied = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            coolingTemperatureSetPointApplied = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            heatingTemperatureSetPointApplied = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            averageLoadAdjustmentPercentageApplied = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dutyCycleApplied = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            signatureType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            signature  = cmd->buffer + payloadOffset;
            wasHandled = emberAfDemandResponseLoadControlClusterReportEventStatusCallback(
                issuerEventId, eventStatus, eventStatusTime, criticalityLevelApplied, coolingTemperatureSetPointApplied,
                heatingTemperatureSetPointApplied, averageLoadAdjustmentPercentageApplied, dutyCycleApplied, eventControl,
                signatureType, signature);
            break;
        }
        case ZCL_GET_SCHEDULED_EVENTS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t startTime;     // Ver.: always
            uint8_t numberOfEvents; // Ver.: always
            uint32_t issuerEventId; // Ver.: since se-1.2b-15-0131-02
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 4u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2b-15-0131-02
                issuerEventId = 0xFFFFFFFF;
            }
            else
            {
                issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled =
                emberAfDemandResponseLoadControlClusterGetScheduledEventsCallback(startTime, numberOfEvents, issuerEventId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Simple Metering, client
EmberAfStatus emberAfSimpleMeteringClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_PROFILE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t endTime;                 // Ver.: always
            uint8_t status;                   // Ver.: always
            uint8_t profileIntervalPeriod;    // Ver.: always
            uint8_t numberOfPeriodsDelivered; // Ver.: always
            uint8_t * intervals;              // Ver.: always
            // Command is fixed length: 7
            if (cmd->bufLen < payloadOffset + 7u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            endTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            profileIntervalPeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfPeriodsDelivered = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            intervals  = cmd->buffer + payloadOffset;
            wasHandled = emberAfSimpleMeteringClusterGetProfileResponseCallback(endTime, status, profileIntervalPeriod,
                                                                                numberOfPeriodsDelivered, intervals);
            break;
        }
        case ZCL_REQUEST_MIRROR_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfSimpleMeteringClusterRequestMirrorCallback();
            break;
        }
        case ZCL_REMOVE_MIRROR_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfSimpleMeteringClusterRemoveMirrorCallback();
            break;
        }
        case ZCL_REQUEST_FAST_POLL_MODE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t appliedUpdatePeriod;  // Ver.: always
            uint32_t fastPollModeEndtime; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            appliedUpdatePeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            fastPollModeEndtime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterRequestFastPollModeResponseCallback(appliedUpdatePeriod, fastPollModeEndtime);
            break;
        }
        case ZCL_SUPPLY_STATUS_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;             // Ver.: always
            uint32_t issuerEventId;          // Ver.: always
            uint32_t implementationDateTime; // Ver.: always
            uint8_t supplyStatus;            // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            implementationDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            supplyStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterSupplyStatusResponseCallback(providerId, issuerEventId, implementationDateTime,
                                                                                  supplyStatus);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Simple Metering, server
EmberAfStatus emberAfSimpleMeteringClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_PROFILE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t intervalChannel; // Ver.: always
            uint32_t endTime;        // Ver.: always
            uint8_t numberOfPeriods; // Ver.: always
            // Command is fixed length: 6
            if (cmd->bufLen < payloadOffset + 6u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            intervalChannel = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            endTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfPeriods = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled      = emberAfSimpleMeteringClusterGetProfileCallback(intervalChannel, endTime, numberOfPeriods);
            break;
        }
        case ZCL_REQUEST_MIRROR_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t endpointId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            endpointId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterRequestMirrorResponseCallback(endpointId);
            break;
        }
        case ZCL_MIRROR_REMOVED_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t endpointId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            endpointId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterMirrorRemovedCallback(endpointId);
            break;
        }
        case ZCL_REQUEST_FAST_POLL_MODE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t fastPollUpdatePeriod; // Ver.: always
            uint8_t duration;             // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            fastPollUpdatePeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            duration   = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterRequestFastPollModeCallback(fastPollUpdatePeriod, duration);
            break;
        }
        case ZCL_START_SAMPLING_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;         // Ver.: always
            uint32_t startSamplingTime;     // Ver.: always
            uint8_t sampleType;             // Ver.: always
            uint16_t sampleRequestInterval; // Ver.: always
            uint16_t maxNumberOfSamples;    // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startSamplingTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            sampleType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            sampleRequestInterval = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            maxNumberOfSamples = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled         = emberAfSimpleMeteringClusterStartSamplingCallback(issuerEventId, startSamplingTime, sampleType,
                                                                           sampleRequestInterval, maxNumberOfSamples);
            break;
        }
        case ZCL_GET_SAMPLED_DATA_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t sampleId;           // Ver.: always
            uint32_t earliestSampleTime; // Ver.: always
            uint8_t sampleType;          // Ver.: always
            uint16_t numberOfSamples;    // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            sampleId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            earliestSampleTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            sampleType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfSamples = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfSimpleMeteringClusterGetSampledDataCallback(sampleId, earliestSampleTime, sampleType, numberOfSamples);
            break;
        }
        case ZCL_MIRROR_REPORT_ATTRIBUTE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t notificationScheme;  // Ver.: always
            uint8_t * notificationFlags; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            notificationScheme = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            notificationFlags = cmd->buffer + payloadOffset;
            wasHandled = emberAfSimpleMeteringClusterMirrorReportAttributeResponseCallback(notificationScheme, notificationFlags);
            break;
        }
        case ZCL_RESET_LOAD_LIMIT_COUNTER_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;    // Ver.: always
            uint32_t issuerEventId; // Ver.: always
            // Command is fixed length: 8
            if (cmd->bufLen < payloadOffset + 8u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled    = emberAfSimpleMeteringClusterResetLoadLimitCounterCallback(providerId, issuerEventId);
            break;
        }
        case ZCL_CHANGE_SUPPLY_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;             // Ver.: always
            uint32_t issuerEventId;          // Ver.: always
            uint32_t requestDateTime;        // Ver.: always
            uint32_t implementationDateTime; // Ver.: always
            uint8_t proposedSupplyStatus;    // Ver.: always
            uint8_t supplyControlBits;       // Ver.: always
            // Command is fixed length: 18
            if (cmd->bufLen < payloadOffset + 18u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            requestDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            implementationDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            proposedSupplyStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            supplyControlBits = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled        = emberAfSimpleMeteringClusterChangeSupplyCallback(
                providerId, issuerEventId, requestDateTime, implementationDateTime, proposedSupplyStatus, supplyControlBits);
            break;
        }
        case ZCL_LOCAL_CHANGE_SUPPLY_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t proposedSupplyStatus; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedSupplyStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled           = emberAfSimpleMeteringClusterLocalChangeSupplyCallback(proposedSupplyStatus);
            break;
        }
        case ZCL_SET_SUPPLY_STATUS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;              // Ver.: always
            uint8_t supplyTamperState;           // Ver.: always
            uint8_t supplyDepletionState;        // Ver.: always
            uint8_t supplyUncontrolledFlowState; // Ver.: always
            uint8_t loadLimitSupplyState;        // Ver.: always
            // Command is fixed length: 8
            if (cmd->bufLen < payloadOffset + 8u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            supplyTamperState = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            supplyDepletionState = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            supplyUncontrolledFlowState = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            loadLimitSupplyState = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterSetSupplyStatusCallback(issuerEventId, supplyTamperState, supplyDepletionState,
                                                                             supplyUncontrolledFlowState, loadLimitSupplyState);
            break;
        }
        case ZCL_SET_UNCONTROLLED_FLOW_THRESHOLD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                // Ver.: always
            uint32_t issuerEventId;             // Ver.: always
            uint16_t uncontrolledFlowThreshold; // Ver.: always
            uint8_t unitOfMeasure;              // Ver.: always
            uint16_t multiplier;                // Ver.: always
            uint16_t divisor;                   // Ver.: always
            uint8_t stabilisationPeriod;        // Ver.: always
            uint16_t measurementPeriod;         // Ver.: always
            // Command is fixed length: 18
            if (cmd->bufLen < payloadOffset + 18u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            uncontrolledFlowThreshold = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            unitOfMeasure = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            multiplier = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            divisor = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            stabilisationPeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            measurementPeriod = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled        = emberAfSimpleMeteringClusterSetUncontrolledFlowThresholdCallback(
                providerId, issuerEventId, uncontrolledFlowThreshold, unitOfMeasure, multiplier, divisor, stabilisationPeriod,
                measurementPeriod);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Messaging, client
EmberAfStatus emberAfMessagingClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_DISPLAY_MESSAGE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t messageId;                     // Ver.: always
            uint8_t messageControl;                 // Ver.: always
            uint32_t startTime;                     // Ver.: always
            uint16_t durationInMinutes;             // Ver.: always
            uint8_t * message;                      // Ver.: always
            uint8_t optionalExtendedMessageControl; // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            message = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                optionalExtendedMessageControl = 0x00;
            }
            else
            {
                optionalExtendedMessageControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfMessagingClusterDisplayMessageCallback(messageId, messageControl, startTime, durationInMinutes,
                                                                       message, optionalExtendedMessageControl);
            break;
        }
        case ZCL_CANCEL_MESSAGE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t messageId;     // Ver.: always
            uint8_t messageControl; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            messageControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfMessagingClusterCancelMessageCallback(messageId, messageControl);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Messaging, server
EmberAfStatus emberAfMessagingClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_LAST_MESSAGE_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfMessagingClusterGetLastMessageCallback();
            break;
        }
        case ZCL_MESSAGE_CONFIRMATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t messageId;                 // Ver.: always
            uint32_t confirmationTime;          // Ver.: always
            uint8_t messageConfirmationControl; // Ver.: since se-1.2a-07-5356-19
            uint8_t * messageResponse;          // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            confirmationTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                messageConfirmationControl = 0xFF;
            }
            else
            {
                messageConfirmationControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                messageResponse = NULL;
            }
            else
            {
                messageResponse = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfMessagingClusterMessageConfirmationCallback(messageId, confirmationTime, messageConfirmationControl,
                                                                            messageResponse);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Tunneling, client
EmberAfStatus emberAfTunnelingClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_REQUEST_TUNNEL_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId;                    // Ver.: always
            uint8_t tunnelStatus;                 // Ver.: always
            uint16_t maximumIncomingTransferSize; // Ver.: since se-1.1a-07-5356-17
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 2u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1a-07-5356-17
                maximumIncomingTransferSize = 0xFFFF;
            }
            else
            {
                maximumIncomingTransferSize = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfTunnelingClusterRequestTunnelResponseCallback(tunnelId, tunnelStatus, maximumIncomingTransferSize);
            break;
        }
        case ZCL_TRANSFER_DATA_SERVER_TO_CLIENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId; // Ver.: always
            uint8_t * data;    // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            data       = cmd->buffer + payloadOffset;
            wasHandled = emberAfTunnelingClusterTransferDataServerToClientCallback(tunnelId, data);
            break;
        }
        case ZCL_TRANSFER_DATA_ERROR_SERVER_TO_CLIENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId;          // Ver.: always
            uint8_t transferDataStatus; // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            transferDataStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled         = emberAfTunnelingClusterTransferDataErrorServerToClientCallback(tunnelId, transferDataStatus);
            break;
        }
        case ZCL_TUNNEL_CLOSURE_NOTIFICATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId   = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfTunnelingClusterTunnelClosureNotificationCallback(tunnelId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Tunneling, server
EmberAfStatus emberAfTunnelingClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_REQUEST_TUNNEL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t protocolId;                   // Ver.: always
            uint16_t manufacturerCode;            // Ver.: always
            uint8_t flowControlSupport;           // Ver.: always
            uint16_t maximumIncomingTransferSize; // Ver.: since se-1.1a-07-5356-17
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            protocolId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            manufacturerCode = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            flowControlSupport = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 2u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1a-07-5356-17
                maximumIncomingTransferSize = 0xFFFF;
            }
            else
            {
                maximumIncomingTransferSize = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfTunnelingClusterRequestTunnelCallback(protocolId, manufacturerCode, flowControlSupport,
                                                                      maximumIncomingTransferSize);
            break;
        }
        case ZCL_CLOSE_TUNNEL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId   = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfTunnelingClusterCloseTunnelCallback(tunnelId);
            break;
        }
        case ZCL_TRANSFER_DATA_CLIENT_TO_SERVER_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId; // Ver.: always
            uint8_t * data;    // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            data       = cmd->buffer + payloadOffset;
            wasHandled = emberAfTunnelingClusterTransferDataClientToServerCallback(tunnelId, data);
            break;
        }
        case ZCL_TRANSFER_DATA_ERROR_CLIENT_TO_SERVER_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId;          // Ver.: always
            uint8_t transferDataStatus; // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            transferDataStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled         = emberAfTunnelingClusterTransferDataErrorClientToServerCallback(tunnelId, transferDataStatus);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Key Establishment, client
EmberAfStatus emberAfKeyEstablishmentClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_TERMINATE_KEY_ESTABLISHMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t statusCode;             // Ver.: always
            uint8_t waitTime;               // Ver.: always
            uint16_t keyEstablishmentSuite; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            statusCode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            waitTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfKeyEstablishmentClusterTerminateKeyEstablishmentCallback(statusCode, waitTime, keyEstablishmentSuite);
            break;
        }
        case ZCL_INITIATE_KEY_ESTABLISHMENT_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t requestedKeyEstablishmentSuite; // Ver.: always
            uint8_t ephemeralDataGenerateTime;       // Ver.: always
            uint8_t confirmKeyGenerateTime;          // Ver.: always
            uint8_t * identity;                      // Ver.: always
            // Command is fixed length: 52
            if (cmd->bufLen < payloadOffset + 52u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            requestedKeyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            ephemeralDataGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            confirmKeyGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            identity   = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterInitiateKeyEstablishmentResponseCallback(
                requestedKeyEstablishmentSuite, ephemeralDataGenerateTime, confirmKeyGenerateTime, identity);
            break;
        }
        case ZCL_EPHEMERAL_DATA_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * ephemeralData; // Ver.: always
            // Command is fixed length: 22
            if (cmd->bufLen < payloadOffset + 22u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            ephemeralData = cmd->buffer + payloadOffset;
            wasHandled    = emberAfKeyEstablishmentClusterEphemeralDataResponseCallback(ephemeralData);
            break;
        }
        case ZCL_CONFIRM_KEY_DATA_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * secureMessageAuthenticationCode; // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            secureMessageAuthenticationCode = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterConfirmKeyDataResponseCallback(secureMessageAuthenticationCode);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Key Establishment, server
EmberAfStatus emberAfKeyEstablishmentClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_INITIATE_KEY_ESTABLISHMENT_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t keyEstablishmentSuite;    // Ver.: always
            uint8_t ephemeralDataGenerateTime; // Ver.: always
            uint8_t confirmKeyGenerateTime;    // Ver.: always
            uint8_t * identity;                // Ver.: always
            // Command is fixed length: 52
            if (cmd->bufLen < payloadOffset + 52u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            ephemeralDataGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            confirmKeyGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            identity   = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterInitiateKeyEstablishmentRequestCallback(
                keyEstablishmentSuite, ephemeralDataGenerateTime, confirmKeyGenerateTime, identity);
            break;
        }
        case ZCL_EPHEMERAL_DATA_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * ephemeralData; // Ver.: always
            // Command is fixed length: 22
            if (cmd->bufLen < payloadOffset + 22u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            ephemeralData = cmd->buffer + payloadOffset;
            wasHandled    = emberAfKeyEstablishmentClusterEphemeralDataRequestCallback(ephemeralData);
            break;
        }
        case ZCL_CONFIRM_KEY_DATA_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * secureMessageAuthenticationCode; // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            secureMessageAuthenticationCode = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterConfirmKeyDataRequestCallback(secureMessageAuthenticationCode);
            break;
        }
        case ZCL_TERMINATE_KEY_ESTABLISHMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t statusCode;             // Ver.: always
            uint8_t waitTime;               // Ver.: always
            uint16_t keyEstablishmentSuite; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            statusCode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            waitTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfKeyEstablishmentClusterTerminateKeyEstablishmentCallback(statusCode, waitTime, keyEstablishmentSuite);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Sample Mfg Specific Cluster, server
EmberAfStatus emberAfSampleMfgSpecificClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (cmd->mfgSpecific)
    {
        if (cmd->mfgCode == 0x1002 && cmd->commandId == ZCL_COMMAND_ONE_COMMAND_ID)
        {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t argOne; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            argOne     = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSampleMfgSpecificClusterCommandOneCallback(argOne);
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Sample Mfg Specific Cluster 2, server
EmberAfStatus emberAfSampleMfgSpecificCluster2ServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (cmd->mfgSpecific)
    {
        if (cmd->mfgCode == 0x1049 && cmd->commandId == ZCL_COMMAND_TWO_COMMAND_ID)
        {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t argOne; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            argOne     = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSampleMfgSpecificCluster2CommandTwoCallback(argOne);
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}
