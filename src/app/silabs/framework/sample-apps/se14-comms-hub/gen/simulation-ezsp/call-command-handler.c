/**
 *
 *    Copyright (c) 2020 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

/**
 *
 *    Copyright (c) 2020 Silicon Labs
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

// This is a set of generated functions that parse the
// the incomming message, and call appropriate command handler.

#include PLATFORM_HEADER
#ifdef EZSP_HOST
// Includes needed for ember related functions for the EZSP host
#include "app/util/ezsp/ezsp-protocol.h"
#include "app/util/ezsp/ezsp-utils.h"
#include "app/util/ezsp/ezsp.h"
#include "app/util/ezsp/serial-interface.h"
#include "stack/include/ember-types.h"
#include "stack/include/error.h"
#else
// Includes needed for ember related functions for the EM250
#include "stack/include/ember.h"
#endif // EZSP_HOST

#include "af-structs.h"
#include "app/framework/util/util.h"
#include "call-command-handler.h"
#include "callback.h"
#include "command-id.h"

static EmberAfStatus status(bool wasHandled, bool clusterExists, bool mfgSpecific)
{
    if (wasHandled)
    {
        return EMBER_ZCL_STATUS_SUCCESS;
    }
    else if (mfgSpecific)
    {
        return EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND;
    }
    else if (clusterExists)
    {
        return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    }
    else
    {
        return EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER;
    }
}

// Main command parsing controller.
EmberAfStatus emberAfClusterSpecificCommandParse(EmberAfClusterCommand * cmd)
{
    EmberAfStatus result = status(false, false, cmd->mfgSpecific);
    if (cmd->direction == (uint8_t) ZCL_DIRECTION_SERVER_TO_CLIENT &&
        emberAfContainsClientWithMfgCode(cmd->apsFrame->destinationEndpoint, cmd->apsFrame->clusterId, cmd->mfgCode))
    {
        switch (cmd->apsFrame->clusterId)
        {
        case ZCL_PRICE_CLUSTER_ID:
            result = emberAfPriceClusterClientCommandParse(cmd);
            break;
        case ZCL_SIMPLE_METERING_CLUSTER_ID:
            result = emberAfSimpleMeteringClusterClientCommandParse(cmd);
            break;
        case ZCL_MESSAGING_CLUSTER_ID:
            result = emberAfMessagingClusterClientCommandParse(cmd);
            break;
        case ZCL_TUNNELING_CLUSTER_ID:
            result = emberAfTunnelingClusterClientCommandParse(cmd);
            break;
        case ZCL_PREPAYMENT_CLUSTER_ID:
            result = emberAfPrepaymentClusterClientCommandParse(cmd);
            break;
        case ZCL_CALENDAR_CLUSTER_ID:
            result = emberAfCalendarClusterClientCommandParse(cmd);
            break;
        case ZCL_DEVICE_MANAGEMENT_CLUSTER_ID:
            result = emberAfDeviceManagementClusterClientCommandParse(cmd);
            break;
        case ZCL_EVENTS_CLUSTER_ID:
            result = emberAfEventsClusterClientCommandParse(cmd);
            break;
        case ZCL_SUB_GHZ_CLUSTER_ID:
            result = emberAfSubGhzClusterClientCommandParse(cmd);
            break;
        case ZCL_KEY_ESTABLISHMENT_CLUSTER_ID:
            result = emberAfKeyEstablishmentClusterClientCommandParse(cmd);
            break;
        default:
            // Unrecognized cluster ID, error status will apply.
            break;
        }
    }
    else if (cmd->direction == (uint8_t) ZCL_DIRECTION_CLIENT_TO_SERVER &&
             emberAfContainsServerWithMfgCode(cmd->apsFrame->destinationEndpoint, cmd->apsFrame->clusterId, cmd->mfgCode))
    {
        switch (cmd->apsFrame->clusterId)
        {
        case ZCL_BASIC_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_TIME_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_PRICE_CLUSTER_ID:
            result = emberAfPriceClusterServerCommandParse(cmd);
            break;
        case ZCL_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_SIMPLE_METERING_CLUSTER_ID:
            result = emberAfSimpleMeteringClusterServerCommandParse(cmd);
            break;
        case ZCL_MESSAGING_CLUSTER_ID:
            result = emberAfMessagingClusterServerCommandParse(cmd);
            break;
        case ZCL_TUNNELING_CLUSTER_ID:
            result = emberAfTunnelingClusterServerCommandParse(cmd);
            break;
        case ZCL_PREPAYMENT_CLUSTER_ID:
            result = emberAfPrepaymentClusterServerCommandParse(cmd);
            break;
        case ZCL_CALENDAR_CLUSTER_ID:
            result = emberAfCalendarClusterServerCommandParse(cmd);
            break;
        case ZCL_DEVICE_MANAGEMENT_CLUSTER_ID:
            result = emberAfDeviceManagementClusterServerCommandParse(cmd);
            break;
        case ZCL_EVENTS_CLUSTER_ID:
            result = emberAfEventsClusterServerCommandParse(cmd);
            break;
        case ZCL_SUB_GHZ_CLUSTER_ID:
            result = emberAfSubGhzClusterServerCommandParse(cmd);
            break;
        case ZCL_KEY_ESTABLISHMENT_CLUSTER_ID:
            result = emberAfKeyEstablishmentClusterServerCommandParse(cmd);
            break;
        default:
            // Unrecognized cluster ID, error status will apply.
            break;
        }
    }
    return result;
}

// Cluster: Price, client
EmberAfStatus emberAfPriceClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_BLOCK_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;             // Ver.: always
            uint32_t issuerEventId;          // Ver.: always
            uint32_t blockPeriodStartTime;   // Ver.: always
            uint32_t blockPeriodDuration;    // Ver.: always
            uint8_t blockPeriodControl;      // Ver.: always
            uint8_t blockPeriodDurationType; // Ver.: since se-1.2a-07-5356-19
            uint8_t tariffType;              // Ver.: since se-1.2a-07-5356-19
            uint8_t tariffResolutionPeriod;  // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                blockPeriodDurationType = 0xFF;
            }
            else
            {
                blockPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                tariffType = 0xFF;
            }
            else
            {
                tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                tariffResolutionPeriod = 0xFF;
            }
            else
            {
                tariffResolutionPeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfPriceClusterPublishBlockPeriodCallback(providerId, issuerEventId, blockPeriodStartTime,
                                                                       blockPeriodDuration, blockPeriodControl,
                                                                       blockPeriodDurationType, tariffType, tariffResolutionPeriod);
            break;
        }
        case ZCL_PUBLISH_CONVERSION_FACTOR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;                // Ver.: always
            uint32_t startTime;                    // Ver.: always
            uint32_t conversionFactor;             // Ver.: always
            uint8_t conversionFactorTrailingDigit; // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactor = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactorTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishConversionFactorCallback(issuerEventId, startTime, conversionFactor,
                                                                            conversionFactorTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_CALORIFIC_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;              // Ver.: always
            uint32_t startTime;                  // Ver.: always
            uint32_t calorificValue;             // Ver.: always
            uint8_t calorificValueUnit;          // Ver.: always
            uint8_t calorificValueTrailingDigit; // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calorificValue = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calorificValueUnit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            calorificValueTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                  = emberAfPriceClusterPublishCalorificValueCallback(issuerEventId, startTime, calorificValue,
                                                                          calorificValueUnit, calorificValueTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_TARIFF_INFORMATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                  // Ver.: always
            uint32_t issuerEventId;               // Ver.: always
            uint32_t issuerTariffId;              // Ver.: always
            uint32_t startTime;                   // Ver.: always
            uint8_t tariffTypeChargingScheme;     // Ver.: always
            uint8_t * tariffLabel;                // Ver.: always
            uint8_t numberOfPriceTiersInUse;      // Ver.: always
            uint8_t numberOfBlockThresholdsInUse; // Ver.: always
            uint8_t unitOfMeasure;                // Ver.: always
            uint16_t currency;                    // Ver.: always
            uint8_t priceTrailingDigit;           // Ver.: always
            uint32_t standingCharge;              // Ver.: always
            uint8_t tierBlockMode;                // Ver.: always
            uint32_t blockThresholdMultiplier;    // Ver.: always
            uint32_t blockThresholdDivisor;       // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffTypeChargingScheme = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffLabel = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfPriceTiersInUse = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfBlockThresholdsInUse = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            unitOfMeasure = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            priceTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            standingCharge = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tierBlockMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockThresholdMultiplier = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockThresholdDivisor = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled            = emberAfPriceClusterPublishTariffInformationCallback(
                providerId, issuerEventId, issuerTariffId, startTime, tariffTypeChargingScheme, tariffLabel,
                numberOfPriceTiersInUse, numberOfBlockThresholdsInUse, unitOfMeasure, currency, priceTrailingDigit, standingCharge,
                tierBlockMode, blockThresholdMultiplier, blockThresholdDivisor);
            break;
        }
        case ZCL_PUBLISH_PRICE_MATRIX_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerEventId;    // Ver.: always
            uint32_t startTime;        // Ver.: always
            uint32_t issuerTariffId;   // Ver.: always
            uint8_t commandIndex;      // Ver.: always
            uint8_t numberOfCommands;  // Ver.: always
            uint8_t subPayloadControl; // Ver.: always
            uint8_t * payload;         // Ver.: always
            // Command is fixed length: 19
            if (cmd->bufLen < payloadOffset + 19u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            subPayloadControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            payload    = cmd->buffer + payloadOffset;
            wasHandled = emberAfPriceClusterPublishPriceMatrixCallback(providerId, issuerEventId, startTime, issuerTariffId,
                                                                       commandIndex, numberOfCommands, subPayloadControl, payload);
            break;
        }
        case ZCL_PUBLISH_BLOCK_THRESHOLDS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerEventId;    // Ver.: always
            uint32_t startTime;        // Ver.: always
            uint32_t issuerTariffId;   // Ver.: always
            uint8_t commandIndex;      // Ver.: always
            uint8_t numberOfCommands;  // Ver.: always
            uint8_t subPayloadControl; // Ver.: always
            uint8_t * payload;         // Ver.: always
            // Command is fixed length: 19
            if (cmd->bufLen < payloadOffset + 19u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            subPayloadControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            payload    = cmd->buffer + payloadOffset;
            wasHandled = emberAfPriceClusterPublishBlockThresholdsCallback(
                providerId, issuerEventId, startTime, issuerTariffId, commandIndex, numberOfCommands, subPayloadControl, payload);
            break;
        }
        case ZCL_PUBLISH_BILLING_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;               // Ver.: always
            uint32_t issuerEventId;            // Ver.: always
            uint32_t billingPeriodStartTime;   // Ver.: always
            uint32_t billingPeriodDuration;    // Ver.: always
            uint8_t billingPeriodDurationType; // Ver.: always
            uint8_t tariffType;                // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            billingPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishBillingPeriodCallback(
                providerId, issuerEventId, billingPeriodStartTime, billingPeriodDuration, billingPeriodDurationType, tariffType);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Price, server
EmberAfStatus emberAfPriceClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_CURRENT_PRICE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t commandOptions; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            commandOptions = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetCurrentPriceCallback(commandOptions);
            break;
        }
        case ZCL_GET_SCHEDULED_PRICES_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t startTime;     // Ver.: always
            uint8_t numberOfEvents; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetScheduledPricesCallback(startTime, numberOfEvents);
            break;
        }
        case ZCL_PRICE_ACKNOWLEDGEMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;    // Ver.: always
            uint32_t issuerEventId; // Ver.: always
            uint32_t priceAckTime;  // Ver.: always
            uint8_t control;        // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            priceAckTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            control    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPriceAcknowledgementCallback(providerId, issuerEventId, priceAckTime, control);
            break;
        }
        case ZCL_GET_BLOCK_PERIODS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t startTime;     // Ver.: always
            uint8_t numberOfEvents; // Ver.: always
            uint8_t tariffType;     // Ver.: always
            // Command is fixed length: 6
            if (cmd->bufLen < payloadOffset + 6u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterGetBlockPeriodsCallback(startTime, numberOfEvents, tariffType);
            break;
        }
        case ZCL_GET_CONVERSION_FACTOR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterGetConversionFactorCallback(earliestStartTime, minIssuerEventId, numberOfCommands);
            break;
        }
        case ZCL_GET_CALORIFIC_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled       = emberAfPriceClusterGetCalorificValueCallback(earliestStartTime, minIssuerEventId, numberOfCommands);
            break;
        }
        case ZCL_GET_TARIFF_INFORMATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfPriceClusterGetTariffInformationCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_GET_PRICE_MATRIX_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerTariffId; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetPriceMatrixCallback(issuerTariffId);
            break;
        }
        case ZCL_GET_BLOCK_THRESHOLDS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerTariffId; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetBlockThresholdsCallback(issuerTariffId);
            break;
        }
        case ZCL_GET_C_O2_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterGetCO2ValueCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_GET_TIER_LABELS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerTariffId; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetTierLabelsCallback(issuerTariffId);
            break;
        }
        case ZCL_GET_BILLING_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfPriceClusterGetBillingPeriodCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_GET_CONSOLIDATED_BILL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfPriceClusterGetConsolidatedBillCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_CPP_EVENT_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId; // Ver.: always
            uint8_t cppAuth;        // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            cppAuth    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterCppEventResponseCallback(issuerEventId, cppAuth);
            break;
        }
        case ZCL_GET_CREDIT_PAYMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t latestEndTime;  // Ver.: always
            uint8_t numberOfRecords; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            latestEndTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfRecords = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled      = emberAfPriceClusterGetCreditPaymentCallback(latestEndTime, numberOfRecords);
            break;
        }
        case ZCL_GET_CURRENCY_CONVERSION_COMMAND_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfPriceClusterGetCurrencyConversionCommandCallback();
            break;
        }
        case ZCL_GET_TARIFF_CANCELLATION_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfPriceClusterGetTariffCancellationCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Simple Metering, client
EmberAfStatus emberAfSimpleMeteringClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_REQUEST_MIRROR_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfSimpleMeteringClusterRequestMirrorCallback();
            break;
        }
        case ZCL_REMOVE_MIRROR_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfSimpleMeteringClusterRemoveMirrorCallback();
            break;
        }
        case ZCL_PUBLISH_SNAPSHOT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t snapshotId;         // Ver.: always
            uint32_t snapshotTime;       // Ver.: always
            uint8_t totalSnapshotsFound; // Ver.: always
            uint8_t commandIndex;        // Ver.: always
            uint8_t totalCommands;       // Ver.: always
            uint32_t snapshotCause;      // Ver.: always
            uint8_t snapshotPayloadType; // Ver.: always
            uint8_t * snapshotPayload;   // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            snapshotId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            totalSnapshotsFound = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotCause = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotPayloadType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotPayload = cmd->buffer + payloadOffset;
            wasHandled      = emberAfSimpleMeteringClusterPublishSnapshotCallback(snapshotId, snapshotTime, totalSnapshotsFound,
                                                                             commandIndex, totalCommands, snapshotCause,
                                                                             snapshotPayloadType, snapshotPayload);
            break;
        }
        case ZCL_GET_SAMPLED_DATA_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t sampleId;              // Ver.: always
            uint32_t sampleStartTime;       // Ver.: always
            uint8_t sampleType;             // Ver.: always
            uint16_t sampleRequestInterval; // Ver.: always
            uint16_t numberOfSamples;       // Ver.: always
            uint8_t * samples;              // Ver.: always
            // Command is fixed length: 11
            if (cmd->bufLen < payloadOffset + 11u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            sampleId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            sampleStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            sampleType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            sampleRequestInterval = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            numberOfSamples = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            samples    = cmd->buffer + payloadOffset;
            wasHandled = emberAfSimpleMeteringClusterGetSampledDataResponseCallback(
                sampleId, sampleStartTime, sampleType, sampleRequestInterval, numberOfSamples, samples);
            break;
        }
        case ZCL_CONFIGURE_MIRROR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;              // Ver.: always
            uint32_t reportingInterval;          // Ver.: always
            uint8_t mirrorNotificationReporting; // Ver.: always
            uint8_t notificationScheme;          // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            reportingInterval = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            mirrorNotificationReporting = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            notificationScheme = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled         = emberAfSimpleMeteringClusterConfigureMirrorCallback(issuerEventId, reportingInterval,
                                                                             mirrorNotificationReporting, notificationScheme);
            break;
        }
        case ZCL_GET_NOTIFIED_MESSAGE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t notificationScheme;           // Ver.: always
            uint16_t notificationFlagAttributeId; // Ver.: always
            uint32_t notificationFlagsN;          // Ver.: always
            // Command is fixed length: 7
            if (cmd->bufLen < payloadOffset + 7u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            notificationScheme = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            notificationFlagAttributeId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            notificationFlagsN = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterGetNotifiedMessageCallback(notificationScheme, notificationFlagAttributeId,
                                                                                notificationFlagsN);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Simple Metering, server
EmberAfStatus emberAfSimpleMeteringClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_SNAPSHOT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t latestEndTime;     // Ver.: always
            uint8_t snapshotOffset;     // Ver.: always
            uint32_t snapshotCause;     // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            latestEndTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotOffset = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotCause = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfSimpleMeteringClusterGetSnapshotCallback(earliestStartTime, latestEndTime, snapshotOffset, snapshotCause);
            break;
        }
        case ZCL_GET_SAMPLED_DATA_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t sampleId;           // Ver.: always
            uint32_t earliestSampleTime; // Ver.: always
            uint8_t sampleType;          // Ver.: always
            uint16_t numberOfSamples;    // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            sampleId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            earliestSampleTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            sampleType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfSamples = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfSimpleMeteringClusterGetSampledDataCallback(sampleId, earliestSampleTime, sampleType, numberOfSamples);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Messaging, client
EmberAfStatus emberAfMessagingClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_DISPLAY_MESSAGE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t messageId;                     // Ver.: always
            uint8_t messageControl;                 // Ver.: always
            uint32_t startTime;                     // Ver.: always
            uint16_t durationInMinutes;             // Ver.: always
            uint8_t * message;                      // Ver.: always
            uint8_t optionalExtendedMessageControl; // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            message = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                optionalExtendedMessageControl = 0x00;
            }
            else
            {
                optionalExtendedMessageControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfMessagingClusterDisplayMessageCallback(messageId, messageControl, startTime, durationInMinutes,
                                                                       message, optionalExtendedMessageControl);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Messaging, server
EmberAfStatus emberAfMessagingClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_LAST_MESSAGE_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfMessagingClusterGetLastMessageCallback();
            break;
        }
        case ZCL_MESSAGE_CONFIRMATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t messageId;                 // Ver.: always
            uint32_t confirmationTime;          // Ver.: always
            uint8_t messageConfirmationControl; // Ver.: since se-1.2a-07-5356-19
            uint8_t * messageResponse;          // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            confirmationTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                messageConfirmationControl = 0xFF;
            }
            else
            {
                messageConfirmationControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                messageResponse = NULL;
            }
            else
            {
                messageResponse = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfMessagingClusterMessageConfirmationCallback(messageId, confirmationTime, messageConfirmationControl,
                                                                            messageResponse);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Tunneling, client
EmberAfStatus emberAfTunnelingClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_REQUEST_TUNNEL_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId;                    // Ver.: always
            uint8_t tunnelStatus;                 // Ver.: always
            uint16_t maximumIncomingTransferSize; // Ver.: since se-1.1a-07-5356-17
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 2u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1a-07-5356-17
                maximumIncomingTransferSize = 0xFFFF;
            }
            else
            {
                maximumIncomingTransferSize = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfTunnelingClusterRequestTunnelResponseCallback(tunnelId, tunnelStatus, maximumIncomingTransferSize);
            break;
        }
        case ZCL_TRANSFER_DATA_SERVER_TO_CLIENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId; // Ver.: always
            uint8_t * data;    // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            data       = cmd->buffer + payloadOffset;
            wasHandled = emberAfTunnelingClusterTransferDataServerToClientCallback(tunnelId, data);
            break;
        }
        case ZCL_TRANSFER_DATA_ERROR_SERVER_TO_CLIENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId;          // Ver.: always
            uint8_t transferDataStatus; // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            transferDataStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled         = emberAfTunnelingClusterTransferDataErrorServerToClientCallback(tunnelId, transferDataStatus);
            break;
        }
        case ZCL_TUNNEL_CLOSURE_NOTIFICATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId   = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfTunnelingClusterTunnelClosureNotificationCallback(tunnelId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Tunneling, server
EmberAfStatus emberAfTunnelingClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_REQUEST_TUNNEL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t protocolId;                   // Ver.: always
            uint16_t manufacturerCode;            // Ver.: always
            uint8_t flowControlSupport;           // Ver.: always
            uint16_t maximumIncomingTransferSize; // Ver.: since se-1.1a-07-5356-17
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            protocolId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            manufacturerCode = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            flowControlSupport = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 2u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1a-07-5356-17
                maximumIncomingTransferSize = 0xFFFF;
            }
            else
            {
                maximumIncomingTransferSize = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfTunnelingClusterRequestTunnelCallback(protocolId, manufacturerCode, flowControlSupport,
                                                                      maximumIncomingTransferSize);
            break;
        }
        case ZCL_CLOSE_TUNNEL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId   = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfTunnelingClusterCloseTunnelCallback(tunnelId);
            break;
        }
        case ZCL_TRANSFER_DATA_CLIENT_TO_SERVER_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId; // Ver.: always
            uint8_t * data;    // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            data       = cmd->buffer + payloadOffset;
            wasHandled = emberAfTunnelingClusterTransferDataClientToServerCallback(tunnelId, data);
            break;
        }
        case ZCL_TRANSFER_DATA_ERROR_CLIENT_TO_SERVER_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId;          // Ver.: always
            uint8_t transferDataStatus; // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            transferDataStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled         = emberAfTunnelingClusterTransferDataErrorClientToServerCallback(tunnelId, transferDataStatus);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Prepayment, client
EmberAfStatus emberAfPrepaymentClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_PREPAY_SNAPSHOT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t snapshotId;           // Ver.: always
            uint32_t snapshotTime;         // Ver.: always
            uint8_t totalSnapshotsFound;   // Ver.: always
            uint8_t commandIndex;          // Ver.: always
            uint8_t totalNumberOfCommands; // Ver.: always
            uint32_t snapshotCause;        // Ver.: always
            uint8_t snapshotPayloadType;   // Ver.: always
            uint8_t * snapshotPayload;     // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            snapshotId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            totalSnapshotsFound = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotCause = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotPayloadType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotPayload = cmd->buffer + payloadOffset;
            wasHandled      = emberAfPrepaymentClusterPublishPrepaySnapshotCallback(snapshotId, snapshotTime, totalSnapshotsFound,
                                                                               commandIndex, totalNumberOfCommands, snapshotCause,
                                                                               snapshotPayloadType, snapshotPayload);
            break;
        }
        case ZCL_PUBLISH_TOP_UP_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t commandIndex;          // Ver.: always
            uint8_t totalNumberOfCommands; // Ver.: always
            uint8_t * topUpPayload;        // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            topUpPayload = cmd->buffer + payloadOffset;
            wasHandled   = emberAfPrepaymentClusterPublishTopUpLogCallback(commandIndex, totalNumberOfCommands, topUpPayload);
            break;
        }
        case ZCL_PUBLISH_DEBT_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t commandIndex;          // Ver.: always
            uint8_t totalNumberOfCommands; // Ver.: always
            uint8_t * debtPayload;         // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            debtPayload = cmd->buffer + payloadOffset;
            wasHandled  = emberAfPrepaymentClusterPublishDebtLogCallback(commandIndex, totalNumberOfCommands, debtPayload);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Prepayment, server
EmberAfStatus emberAfPrepaymentClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_PREPAY_SNAPSHOT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t latestEndTime;     // Ver.: always
            uint8_t snapshotOffset;     // Ver.: always
            uint32_t snapshotCause;     // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            latestEndTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotOffset = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotCause = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfPrepaymentClusterGetPrepaySnapshotCallback(earliestStartTime, latestEndTime, snapshotOffset, snapshotCause);
            break;
        }
        case ZCL_GET_TOP_UP_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t latestEndTime;  // Ver.: always
            uint8_t numberOfRecords; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            latestEndTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfRecords = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled      = emberAfPrepaymentClusterGetTopUpLogCallback(latestEndTime, numberOfRecords);
            break;
        }
        case ZCL_GET_DEBT_REPAYMENT_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t latestEndTime; // Ver.: always
            uint8_t numberOfDebts;  // Ver.: always
            uint8_t debtType;       // Ver.: always
            // Command is fixed length: 6
            if (cmd->bufLen < payloadOffset + 6u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            latestEndTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfDebts = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            debtType   = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPrepaymentClusterGetDebtRepaymentLogCallback(latestEndTime, numberOfDebts, debtType);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Calendar, client
EmberAfStatus emberAfCalendarClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_CALENDAR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;           // Ver.: always
            uint32_t issuerEventId;        // Ver.: always
            uint32_t issuerCalendarId;     // Ver.: always
            uint32_t startTime;            // Ver.: always
            uint8_t calendarType;          // Ver.: always
            uint8_t calendarTimeReference; // Ver.: always
            uint8_t * calendarName;        // Ver.: always
            uint8_t numberOfSeasons;       // Ver.: always
            uint8_t numberOfWeekProfiles;  // Ver.: always
            uint8_t numberOfDayProfiles;   // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            calendarTimeReference = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            calendarName = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfSeasons = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfWeekProfiles = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfDayProfiles = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfCalendarClusterPublishCalendarCallback(providerId, issuerEventId, issuerCalendarId, startTime,
                                                                       calendarType, calendarTimeReference, calendarName,
                                                                       numberOfSeasons, numberOfWeekProfiles, numberOfDayProfiles);
            break;
        }
        case ZCL_PUBLISH_DAY_PROFILE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                  // Ver.: always
            uint32_t issuerEventId;               // Ver.: always
            uint32_t issuerCalendarId;            // Ver.: always
            uint8_t dayId;                        // Ver.: always
            uint8_t totalNumberOfScheduleEntries; // Ver.: always
            uint8_t commandIndex;                 // Ver.: always
            uint8_t totalNumberOfCommands;        // Ver.: always
            uint8_t calendarType;                 // Ver.: always
            uint8_t * dayScheduleEntries;         // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            dayId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfScheduleEntries = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayScheduleEntries = cmd->buffer + payloadOffset;
            wasHandled         = emberAfCalendarClusterPublishDayProfileCallback(providerId, issuerEventId, issuerCalendarId, dayId,
                                                                         totalNumberOfScheduleEntries, commandIndex,
                                                                         totalNumberOfCommands, calendarType, dayScheduleEntries);
            break;
        }
        case ZCL_PUBLISH_WEEK_PROFILE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerEventId;    // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            uint8_t weekId;            // Ver.: always
            uint8_t dayIdRefMonday;    // Ver.: always
            uint8_t dayIdRefTuesday;   // Ver.: always
            uint8_t dayIdRefWednesday; // Ver.: always
            uint8_t dayIdRefThursday;  // Ver.: always
            uint8_t dayIdRefFriday;    // Ver.: always
            uint8_t dayIdRefSaturday;  // Ver.: always
            uint8_t dayIdRefSunday;    // Ver.: always
            // Command is fixed length: 20
            if (cmd->bufLen < payloadOffset + 20u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            weekId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefMonday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefTuesday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefWednesday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefThursday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefFriday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefSaturday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefSunday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfCalendarClusterPublishWeekProfileCallback(
                providerId, issuerEventId, issuerCalendarId, weekId, dayIdRefMonday, dayIdRefTuesday, dayIdRefWednesday,
                dayIdRefThursday, dayIdRefFriday, dayIdRefSaturday, dayIdRefSunday);
            break;
        }
        case ZCL_PUBLISH_SEASONS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;           // Ver.: always
            uint32_t issuerEventId;        // Ver.: always
            uint32_t issuerCalendarId;     // Ver.: always
            uint8_t commandIndex;          // Ver.: always
            uint8_t totalNumberOfCommands; // Ver.: always
            uint8_t * seasonEntries;       // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            seasonEntries = cmd->buffer + payloadOffset;
            wasHandled    = emberAfCalendarClusterPublishSeasonsCallback(providerId, issuerEventId, issuerCalendarId, commandIndex,
                                                                      totalNumberOfCommands, seasonEntries);
            break;
        }
        case ZCL_PUBLISH_SPECIAL_DAYS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;              // Ver.: always
            uint32_t issuerEventId;           // Ver.: always
            uint32_t issuerCalendarId;        // Ver.: always
            uint32_t startTime;               // Ver.: always
            uint8_t calendarType;             // Ver.: always
            uint8_t totalNumberOfSpecialDays; // Ver.: always
            uint8_t commandIndex;             // Ver.: always
            uint8_t totalNumberOfCommands;    // Ver.: always
            uint8_t * specialDayEntries;      // Ver.: always
            // Command is fixed length: 20
            if (cmd->bufLen < payloadOffset + 20u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfSpecialDays = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            specialDayEntries = cmd->buffer + payloadOffset;
            wasHandled = emberAfCalendarClusterPublishSpecialDaysCallback(providerId, issuerEventId, issuerCalendarId, startTime,
                                                                          calendarType, totalNumberOfSpecialDays, commandIndex,
                                                                          totalNumberOfCommands, specialDayEntries);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Calendar, server
EmberAfStatus emberAfCalendarClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_CALENDAR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCalendars;  // Ver.: always
            uint8_t calendarType;       // Ver.: always
            uint32_t providerId;        // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCalendars = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfCalendarClusterGetCalendarCallback(earliestStartTime, minIssuerEventId, numberOfCalendars,
                                                                   calendarType, providerId);
            break;
        }
        case ZCL_GET_DAY_PROFILES_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            uint8_t startDayId;        // Ver.: always
            uint8_t numberOfDays;      // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startDayId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfDays = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled   = emberAfCalendarClusterGetDayProfilesCallback(providerId, issuerCalendarId, startDayId, numberOfDays);
            break;
        }
        case ZCL_GET_WEEK_PROFILES_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            uint8_t startWeekId;       // Ver.: always
            uint8_t numberOfWeeks;     // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startWeekId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfWeeks = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled    = emberAfCalendarClusterGetWeekProfilesCallback(providerId, issuerCalendarId, startWeekId, numberOfWeeks);
            break;
        }
        case ZCL_GET_SEASONS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            // Command is fixed length: 8
            if (cmd->bufLen < payloadOffset + 8u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled       = emberAfCalendarClusterGetSeasonsCallback(providerId, issuerCalendarId);
            break;
        }
        case ZCL_GET_SPECIAL_DAYS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t startTime;        // Ver.: always
            uint8_t numberOfEvents;    // Ver.: always
            uint8_t calendarType;      // Ver.: always
            uint32_t providerId;       // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfCalendarClusterGetSpecialDaysCallback(startTime, numberOfEvents, calendarType, providerId, issuerCalendarId);
            break;
        }
        case ZCL_GET_CALENDAR_CANCELLATION_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfCalendarClusterGetCalendarCancellationCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Device Management, client
EmberAfStatus emberAfDeviceManagementClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_CHANGE_OF_TENANCY_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                   // Ver.: always
            uint32_t issuerEventId;                // Ver.: always
            uint8_t tariffType;                    // Ver.: always
            uint32_t implementationDateTime;       // Ver.: always
            uint32_t proposedTenancyChangeControl; // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            implementationDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            proposedTenancyChangeControl = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                   = emberAfDeviceManagementClusterPublishChangeOfTenancyCallback(
                providerId, issuerEventId, tariffType, implementationDateTime, proposedTenancyChangeControl);
            break;
        }
        case ZCL_PUBLISH_CHANGE_OF_SUPPLIER_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t currentProviderId;                // Ver.: always
            uint32_t issuerEventId;                    // Ver.: always
            uint8_t tariffType;                        // Ver.: always
            uint32_t proposedProviderId;               // Ver.: always
            uint32_t providerChangeImplementationTime; // Ver.: always
            uint32_t providerChangeControl;            // Ver.: always
            uint8_t * proposedProviderName;            // Ver.: always
            uint8_t * proposedProviderContactDetails;  // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currentProviderId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedProviderId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerChangeImplementationTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerChangeControl = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedProviderName = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedProviderContactDetails = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                     = emberAfDeviceManagementClusterPublishChangeOfSupplierCallback(
                currentProviderId, issuerEventId, tariffType, proposedProviderId, providerChangeImplementationTime,
                providerChangeControl, proposedProviderName, proposedProviderContactDetails);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Device Management, server
EmberAfStatus emberAfDeviceManagementClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_CHANGE_OF_TENANCY_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfDeviceManagementClusterGetChangeOfTenancyCallback();
            break;
        }
        case ZCL_GET_CHANGE_OF_SUPPLIER_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfDeviceManagementClusterGetChangeOfSupplierCallback();
            break;
        }
        case ZCL_REQUEST_NEW_PASSWORD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t passwordType; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            passwordType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled   = emberAfDeviceManagementClusterRequestNewPasswordCallback(passwordType);
            break;
        }
        case ZCL_GET_SITE_ID_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfDeviceManagementClusterGetSiteIdCallback();
            break;
        }
        case ZCL_REPORT_EVENT_CONFIGURATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t commandIndex;                // Ver.: always
            uint8_t totalCommands;               // Ver.: always
            uint8_t * eventConfigurationPayload; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventConfigurationPayload = cmd->buffer + payloadOffset;
            wasHandled                = emberAfDeviceManagementClusterReportEventConfigurationCallback(commandIndex, totalCommands,
                                                                                        eventConfigurationPayload);
            break;
        }
        case ZCL_GET_C_I_N_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfDeviceManagementClusterGetCINCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Events, client
EmberAfStatus emberAfEventsClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_EVENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t logId;        // Ver.: always
            uint16_t eventId;     // Ver.: always
            uint32_t eventTime;   // Ver.: always
            uint8_t eventControl; // Ver.: always
            uint8_t * eventData;  // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            logId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventData  = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfEventsClusterPublishEventCallback(logId, eventId, eventTime, eventControl, eventData);
            break;
        }
        case ZCL_PUBLISH_EVENT_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t totalNumberOfEvents; // Ver.: always
            uint8_t commandIndex;         // Ver.: always
            uint8_t totalCommands;        // Ver.: always
            uint8_t logPayloadControl;    // Ver.: always
            uint8_t * logPayload;         // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            totalNumberOfEvents = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            logPayloadControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            logPayload = cmd->buffer + payloadOffset;
            wasHandled = emberAfEventsClusterPublishEventLogCallback(totalNumberOfEvents, commandIndex, totalCommands,
                                                                     logPayloadControl, logPayload);
            break;
        }
        case ZCL_CLEAR_EVENT_LOG_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t clearedEventsLogs; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            clearedEventsLogs = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled        = emberAfEventsClusterClearEventLogResponseCallback(clearedEventsLogs);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Events, server
EmberAfStatus emberAfEventsClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_EVENT_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t eventControlLogId; // Ver.: always
            uint16_t eventId;          // Ver.: always
            uint32_t startTime;        // Ver.: always
            uint32_t endTime;          // Ver.: always
            uint8_t numberOfEvents;    // Ver.: always
            uint16_t eventOffset;      // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventControlLogId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            endTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventOffset = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled  = emberAfEventsClusterGetEventLogCallback(eventControlLogId, eventId, startTime, endTime, numberOfEvents,
                                                                 eventOffset);
            break;
        }
        case ZCL_CLEAR_EVENT_LOG_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t logId; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            logId      = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfEventsClusterClearEventLogRequestCallback(logId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Sub-GHz, client
EmberAfStatus emberAfSubGhzClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_SUSPEND_ZCL_MESSAGES_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t period; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            period     = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSubGhzClusterSuspendZclMessagesCallback(period);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Sub-GHz, server
EmberAfStatus emberAfSubGhzClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_SUSPEND_ZCL_MESSAGES_STATUS_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfSubGhzClusterGetSuspendZclMessagesStatusCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Key Establishment, client
EmberAfStatus emberAfKeyEstablishmentClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_TERMINATE_KEY_ESTABLISHMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t statusCode;             // Ver.: always
            uint8_t waitTime;               // Ver.: always
            uint16_t keyEstablishmentSuite; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            statusCode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            waitTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfKeyEstablishmentClusterTerminateKeyEstablishmentCallback(statusCode, waitTime, keyEstablishmentSuite);
            break;
        }
        case ZCL_INITIATE_KEY_ESTABLISHMENT_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t requestedKeyEstablishmentSuite; // Ver.: always
            uint8_t ephemeralDataGenerateTime;       // Ver.: always
            uint8_t confirmKeyGenerateTime;          // Ver.: always
            uint8_t * identity;                      // Ver.: always
            // Command is fixed length: 52
            if (cmd->bufLen < payloadOffset + 52u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            requestedKeyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            ephemeralDataGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            confirmKeyGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            identity   = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterInitiateKeyEstablishmentResponseCallback(
                requestedKeyEstablishmentSuite, ephemeralDataGenerateTime, confirmKeyGenerateTime, identity);
            break;
        }
        case ZCL_EPHEMERAL_DATA_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * ephemeralData; // Ver.: always
            // Command is fixed length: 22
            if (cmd->bufLen < payloadOffset + 22u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            ephemeralData = cmd->buffer + payloadOffset;
            wasHandled    = emberAfKeyEstablishmentClusterEphemeralDataResponseCallback(ephemeralData);
            break;
        }
        case ZCL_CONFIRM_KEY_DATA_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * secureMessageAuthenticationCode; // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            secureMessageAuthenticationCode = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterConfirmKeyDataResponseCallback(secureMessageAuthenticationCode);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Key Establishment, server
EmberAfStatus emberAfKeyEstablishmentClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_INITIATE_KEY_ESTABLISHMENT_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t keyEstablishmentSuite;    // Ver.: always
            uint8_t ephemeralDataGenerateTime; // Ver.: always
            uint8_t confirmKeyGenerateTime;    // Ver.: always
            uint8_t * identity;                // Ver.: always
            // Command is fixed length: 52
            if (cmd->bufLen < payloadOffset + 52u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            ephemeralDataGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            confirmKeyGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            identity   = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterInitiateKeyEstablishmentRequestCallback(
                keyEstablishmentSuite, ephemeralDataGenerateTime, confirmKeyGenerateTime, identity);
            break;
        }
        case ZCL_EPHEMERAL_DATA_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * ephemeralData; // Ver.: always
            // Command is fixed length: 22
            if (cmd->bufLen < payloadOffset + 22u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            ephemeralData = cmd->buffer + payloadOffset;
            wasHandled    = emberAfKeyEstablishmentClusterEphemeralDataRequestCallback(ephemeralData);
            break;
        }
        case ZCL_CONFIRM_KEY_DATA_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * secureMessageAuthenticationCode; // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            secureMessageAuthenticationCode = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterConfirmKeyDataRequestCallback(secureMessageAuthenticationCode);
            break;
        }
        case ZCL_TERMINATE_KEY_ESTABLISHMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t statusCode;             // Ver.: always
            uint8_t waitTime;               // Ver.: always
            uint16_t keyEstablishmentSuite; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            statusCode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            waitTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfKeyEstablishmentClusterTerminateKeyEstablishmentCallback(statusCode, waitTime, keyEstablishmentSuite);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}
