/**
 *
 *    Copyright (c) 2020 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

/**
 *
 *    Copyright (c) 2020 Silicon Labs
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

// This is a set of generated functions that parse the
// the incomming message, and call appropriate command handler.

#include PLATFORM_HEADER
#ifdef EZSP_HOST
// Includes needed for ember related functions for the EZSP host
#include "app/util/ezsp/ezsp-protocol.h"
#include "app/util/ezsp/ezsp-utils.h"
#include "app/util/ezsp/ezsp.h"
#include "app/util/ezsp/serial-interface.h"
#include "stack/include/ember-types.h"
#include "stack/include/error.h"
#else
// Includes needed for ember related functions for the EM250
#include "stack/include/ember.h"
#endif // EZSP_HOST

#include "af-structs.h"
#include "app/framework/util/util.h"
#include "call-command-handler.h"
#include "callback.h"
#include "command-id.h"

static EmberAfStatus status(bool wasHandled, bool clusterExists, bool mfgSpecific)
{
    if (wasHandled)
    {
        return EMBER_ZCL_STATUS_SUCCESS;
    }
    else if (mfgSpecific)
    {
        return EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND;
    }
    else if (clusterExists)
    {
        return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    }
    else
    {
        return EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER;
    }
}

// Main command parsing controller.
EmberAfStatus emberAfClusterSpecificCommandParse(EmberAfClusterCommand * cmd)
{
    EmberAfStatus result = status(false, false, cmd->mfgSpecific);
    if (cmd->direction == (uint8_t) ZCL_DIRECTION_SERVER_TO_CLIENT &&
        emberAfContainsClientWithMfgCode(cmd->apsFrame->destinationEndpoint, cmd->apsFrame->clusterId, cmd->mfgCode))
    {
        switch (cmd->apsFrame->clusterId)
        {
        case ZCL_TIME_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_PRICE_CLUSTER_ID:
            result = emberAfPriceClusterClientCommandParse(cmd);
            break;
        case ZCL_MESSAGING_CLUSTER_ID:
            result = emberAfMessagingClusterClientCommandParse(cmd);
            break;
        case ZCL_TUNNELING_CLUSTER_ID:
            result = emberAfTunnelingClusterClientCommandParse(cmd);
            break;
        case ZCL_CALENDAR_CLUSTER_ID:
            result = emberAfCalendarClusterClientCommandParse(cmd);
            break;
        case ZCL_DEVICE_MANAGEMENT_CLUSTER_ID:
            result = emberAfDeviceManagementClusterClientCommandParse(cmd);
            break;
        case ZCL_SUB_GHZ_CLUSTER_ID:
            result = emberAfSubGhzClusterClientCommandParse(cmd);
            break;
        case ZCL_KEY_ESTABLISHMENT_CLUSTER_ID:
            result = emberAfKeyEstablishmentClusterClientCommandParse(cmd);
            break;
        default:
            // Unrecognized cluster ID, error status will apply.
            break;
        }
    }
    else if (cmd->direction == (uint8_t) ZCL_DIRECTION_CLIENT_TO_SERVER &&
             emberAfContainsServerWithMfgCode(cmd->apsFrame->destinationEndpoint, cmd->apsFrame->clusterId, cmd->mfgCode))
    {
        switch (cmd->apsFrame->clusterId)
        {
        case ZCL_BASIC_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_EVENTS_CLUSTER_ID:
            result = emberAfEventsClusterServerCommandParse(cmd);
            break;
        case ZCL_KEY_ESTABLISHMENT_CLUSTER_ID:
            result = emberAfKeyEstablishmentClusterServerCommandParse(cmd);
            break;
        default:
            // Unrecognized cluster ID, error status will apply.
            break;
        }
    }
    return result;
}

// Cluster: Price, client
EmberAfStatus emberAfPriceClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_PRICE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                       // Ver.: always
            uint8_t * rateLabel;                       // Ver.: always
            uint32_t issuerEventId;                    // Ver.: always
            uint32_t currentTime;                      // Ver.: always
            uint8_t unitOfMeasure;                     // Ver.: always
            uint16_t currency;                         // Ver.: always
            uint8_t priceTrailingDigitAndPriceTier;    // Ver.: always
            uint8_t numberOfPriceTiersAndRegisterTier; // Ver.: always
            uint32_t startTime;                        // Ver.: always
            uint16_t durationInMinutes;                // Ver.: always
            uint32_t price;                            // Ver.: always
            uint8_t priceRatio;                        // Ver.: always
            uint32_t generationPrice;                  // Ver.: always
            uint8_t generationPriceRatio;              // Ver.: always
            uint32_t alternateCostDelivered;           // Ver.: since se-1.0-07-5356-15
            uint8_t alternateCostUnit;                 // Ver.: since se-1.0-07-5356-15
            uint8_t alternateCostTrailingDigit;        // Ver.: since se-1.0-07-5356-15
            uint8_t numberOfBlockThresholds;           // Ver.: since se-1.1-07-5356-16
            uint8_t priceControl;                      // Ver.: since se-1.1-07-5356-16
            uint8_t numberOfGenerationTiers;           // Ver.: since se-1.2a-07-5356-19
            uint8_t generationTier;                    // Ver.: since se-1.2a-07-5356-19
            uint8_t extendedNumberOfPriceTiers;        // Ver.: since se-1.2a-07-5356-19
            uint8_t extendedPriceTier;                 // Ver.: since se-1.2a-07-5356-19
            uint8_t extendedRegisterTier;              // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            rateLabel = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currentTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            unitOfMeasure = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            priceTrailingDigitAndPriceTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfPriceTiersAndRegisterTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            price = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            priceRatio = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            generationPrice = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            generationPriceRatio = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 4u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.0-07-5356-15
                alternateCostDelivered = 0xFFFFFFFF;
            }
            else
            {
                alternateCostDelivered = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 4u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.0-07-5356-15
                alternateCostUnit = 0xFF;
            }
            else
            {
                alternateCostUnit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.0-07-5356-15
                alternateCostTrailingDigit = 0xFF;
            }
            else
            {
                alternateCostTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1-07-5356-16
                numberOfBlockThresholds = 0xFF;
            }
            else
            {
                numberOfBlockThresholds = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1-07-5356-16
                priceControl = 0x00;
            }
            else
            {
                priceControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                numberOfGenerationTiers = 0x00;
            }
            else
            {
                numberOfGenerationTiers = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                generationTier = 0x00;
            }
            else
            {
                generationTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                extendedNumberOfPriceTiers = 0x00;
            }
            else
            {
                extendedNumberOfPriceTiers = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                extendedPriceTier = 0x00;
            }
            else
            {
                extendedPriceTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                extendedRegisterTier = 0x00;
            }
            else
            {
                extendedRegisterTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfPriceClusterPublishPriceCallback(
                providerId, rateLabel, issuerEventId, currentTime, unitOfMeasure, currency, priceTrailingDigitAndPriceTier,
                numberOfPriceTiersAndRegisterTier, startTime, durationInMinutes, price, priceRatio, generationPrice,
                generationPriceRatio, alternateCostDelivered, alternateCostUnit, alternateCostTrailingDigit,
                numberOfBlockThresholds, priceControl, numberOfGenerationTiers, generationTier, extendedNumberOfPriceTiers,
                extendedPriceTier, extendedRegisterTier);
            break;
        }
        case ZCL_PUBLISH_BLOCK_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;             // Ver.: always
            uint32_t issuerEventId;          // Ver.: always
            uint32_t blockPeriodStartTime;   // Ver.: always
            uint32_t blockPeriodDuration;    // Ver.: always
            uint8_t blockPeriodControl;      // Ver.: always
            uint8_t blockPeriodDurationType; // Ver.: since se-1.2a-07-5356-19
            uint8_t tariffType;              // Ver.: since se-1.2a-07-5356-19
            uint8_t tariffResolutionPeriod;  // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                blockPeriodDurationType = 0xFF;
            }
            else
            {
                blockPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                tariffType = 0xFF;
            }
            else
            {
                tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                tariffResolutionPeriod = 0xFF;
            }
            else
            {
                tariffResolutionPeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfPriceClusterPublishBlockPeriodCallback(providerId, issuerEventId, blockPeriodStartTime,
                                                                       blockPeriodDuration, blockPeriodControl,
                                                                       blockPeriodDurationType, tariffType, tariffResolutionPeriod);
            break;
        }
        case ZCL_PUBLISH_CONVERSION_FACTOR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;                // Ver.: always
            uint32_t startTime;                    // Ver.: always
            uint32_t conversionFactor;             // Ver.: always
            uint8_t conversionFactorTrailingDigit; // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactor = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactorTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishConversionFactorCallback(issuerEventId, startTime, conversionFactor,
                                                                            conversionFactorTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_CALORIFIC_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;              // Ver.: always
            uint32_t startTime;                  // Ver.: always
            uint32_t calorificValue;             // Ver.: always
            uint8_t calorificValueUnit;          // Ver.: always
            uint8_t calorificValueTrailingDigit; // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calorificValue = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calorificValueUnit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            calorificValueTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                  = emberAfPriceClusterPublishCalorificValueCallback(issuerEventId, startTime, calorificValue,
                                                                          calorificValueUnit, calorificValueTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_TARIFF_INFORMATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                  // Ver.: always
            uint32_t issuerEventId;               // Ver.: always
            uint32_t issuerTariffId;              // Ver.: always
            uint32_t startTime;                   // Ver.: always
            uint8_t tariffTypeChargingScheme;     // Ver.: always
            uint8_t * tariffLabel;                // Ver.: always
            uint8_t numberOfPriceTiersInUse;      // Ver.: always
            uint8_t numberOfBlockThresholdsInUse; // Ver.: always
            uint8_t unitOfMeasure;                // Ver.: always
            uint16_t currency;                    // Ver.: always
            uint8_t priceTrailingDigit;           // Ver.: always
            uint32_t standingCharge;              // Ver.: always
            uint8_t tierBlockMode;                // Ver.: always
            uint32_t blockThresholdMultiplier;    // Ver.: always
            uint32_t blockThresholdDivisor;       // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffTypeChargingScheme = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffLabel = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfPriceTiersInUse = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfBlockThresholdsInUse = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            unitOfMeasure = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            priceTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            standingCharge = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tierBlockMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockThresholdMultiplier = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockThresholdDivisor = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled            = emberAfPriceClusterPublishTariffInformationCallback(
                providerId, issuerEventId, issuerTariffId, startTime, tariffTypeChargingScheme, tariffLabel,
                numberOfPriceTiersInUse, numberOfBlockThresholdsInUse, unitOfMeasure, currency, priceTrailingDigit, standingCharge,
                tierBlockMode, blockThresholdMultiplier, blockThresholdDivisor);
            break;
        }
        case ZCL_PUBLISH_BLOCK_THRESHOLDS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerEventId;    // Ver.: always
            uint32_t startTime;        // Ver.: always
            uint32_t issuerTariffId;   // Ver.: always
            uint8_t commandIndex;      // Ver.: always
            uint8_t numberOfCommands;  // Ver.: always
            uint8_t subPayloadControl; // Ver.: always
            uint8_t * payload;         // Ver.: always
            // Command is fixed length: 19
            if (cmd->bufLen < payloadOffset + 19u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            subPayloadControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            payload    = cmd->buffer + payloadOffset;
            wasHandled = emberAfPriceClusterPublishBlockThresholdsCallback(
                providerId, issuerEventId, startTime, issuerTariffId, commandIndex, numberOfCommands, subPayloadControl, payload);
            break;
        }
        case ZCL_PUBLISH_C_O2_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;           // Ver.: always
            uint32_t issuerEventId;        // Ver.: always
            uint32_t startTime;            // Ver.: always
            uint8_t tariffType;            // Ver.: always
            uint32_t cO2Value;             // Ver.: always
            uint8_t cO2ValueUnit;          // Ver.: always
            uint8_t cO2ValueTrailingDigit; // Ver.: always
            // Command is fixed length: 19
            if (cmd->bufLen < payloadOffset + 19u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cO2Value = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            cO2ValueUnit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cO2ValueTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishCO2ValueCallback(providerId, issuerEventId, startTime, tariffType, cO2Value,
                                                                    cO2ValueUnit, cO2ValueTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_TIER_LABELS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;         // Ver.: always
            uint32_t issuerEventId;      // Ver.: always
            uint32_t issuerTariffId;     // Ver.: always
            uint8_t commandIndex;        // Ver.: always
            uint8_t numberOfCommands;    // Ver.: always
            uint8_t numberOfLabels;      // Ver.: always
            uint8_t * tierLabelsPayload; // Ver.: always
            // Command is fixed length: 15
            if (cmd->bufLen < payloadOffset + 15u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfLabels = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tierLabelsPayload = cmd->buffer + payloadOffset;
            wasHandled = emberAfPriceClusterPublishTierLabelsCallback(providerId, issuerEventId, issuerTariffId, commandIndex,
                                                                      numberOfCommands, numberOfLabels, tierLabelsPayload);
            break;
        }
        case ZCL_PUBLISH_BILLING_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;               // Ver.: always
            uint32_t issuerEventId;            // Ver.: always
            uint32_t billingPeriodStartTime;   // Ver.: always
            uint32_t billingPeriodDuration;    // Ver.: always
            uint8_t billingPeriodDurationType; // Ver.: always
            uint8_t tariffType;                // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            billingPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishBillingPeriodCallback(
                providerId, issuerEventId, billingPeriodStartTime, billingPeriodDuration, billingPeriodDurationType, tariffType);
            break;
        }
        case ZCL_PUBLISH_CONSOLIDATED_BILL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;               // Ver.: always
            uint32_t issuerEventId;            // Ver.: always
            uint32_t billingPeriodStartTime;   // Ver.: always
            uint32_t billingPeriodDuration;    // Ver.: always
            uint8_t billingPeriodDurationType; // Ver.: always
            uint8_t tariffType;                // Ver.: always
            uint32_t consolidatedBill;         // Ver.: always
            uint16_t currency;                 // Ver.: always
            uint8_t billTrailingDigit;         // Ver.: always
            // Command is fixed length: 24
            if (cmd->bufLen < payloadOffset + 24u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            billingPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            consolidatedBill = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            currency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            billTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled        = emberAfPriceClusterPublishConsolidatedBillCallback(
                providerId, issuerEventId, billingPeriodStartTime, billingPeriodDuration, billingPeriodDurationType, tariffType,
                consolidatedBill, currency, billTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_CPP_EVENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;        // Ver.: always
            uint32_t issuerEventId;     // Ver.: always
            uint32_t startTime;         // Ver.: always
            uint16_t durationInMinutes; // Ver.: always
            uint8_t tariffType;         // Ver.: always
            uint8_t cppPriceTier;       // Ver.: always
            uint8_t cppAuth;            // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cppPriceTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cppAuth    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishCppEventCallback(providerId, issuerEventId, startTime, durationInMinutes,
                                                                    tariffType, cppPriceTier, cppAuth);
            break;
        }
        case ZCL_PUBLISH_CREDIT_PAYMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                 // Ver.: always
            uint32_t issuerEventId;              // Ver.: always
            uint32_t creditPaymentDueDate;       // Ver.: always
            uint32_t creditPaymentOverDueAmount; // Ver.: always
            uint8_t creditPaymentStatus;         // Ver.: always
            uint32_t creditPayment;              // Ver.: always
            uint32_t creditPaymentDate;          // Ver.: always
            uint8_t * creditPaymentRef;          // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentDueDate = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentOverDueAmount = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPayment = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentDate = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentRef = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled       = emberAfPriceClusterPublishCreditPaymentCallback(providerId, issuerEventId, creditPaymentDueDate,
                                                                         creditPaymentOverDueAmount, creditPaymentStatus,
                                                                         creditPayment, creditPaymentDate, creditPaymentRef);
            break;
        }
        case ZCL_PUBLISH_CURRENCY_CONVERSION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                   // Ver.: always
            uint32_t issuerEventId;                // Ver.: always
            uint32_t startTime;                    // Ver.: always
            uint16_t oldCurrency;                  // Ver.: always
            uint16_t newCurrency;                  // Ver.: always
            uint32_t conversionFactor;             // Ver.: always
            uint8_t conversionFactorTrailingDigit; // Ver.: always
            uint32_t currencyChangeControlFlags;   // Ver.: always
            // Command is fixed length: 25
            if (cmd->bufLen < payloadOffset + 25u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            oldCurrency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            newCurrency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            conversionFactor = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactorTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            currencyChangeControlFlags = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                 = emberAfPriceClusterPublishCurrencyConversionCallback(
                providerId, issuerEventId, startTime, oldCurrency, newCurrency, conversionFactor, conversionFactorTrailingDigit,
                currencyChangeControlFlags);
            break;
        }
        case ZCL_CANCEL_TARIFF_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;     // Ver.: always
            uint32_t issuerTariffId; // Ver.: always
            uint8_t tariffType;      // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterCancelTariffCallback(providerId, issuerTariffId, tariffType);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Messaging, client
EmberAfStatus emberAfMessagingClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_DISPLAY_MESSAGE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t messageId;                     // Ver.: always
            uint8_t messageControl;                 // Ver.: always
            uint32_t startTime;                     // Ver.: always
            uint16_t durationInMinutes;             // Ver.: always
            uint8_t * message;                      // Ver.: always
            uint8_t optionalExtendedMessageControl; // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            message = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                optionalExtendedMessageControl = 0x00;
            }
            else
            {
                optionalExtendedMessageControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfMessagingClusterDisplayMessageCallback(messageId, messageControl, startTime, durationInMinutes,
                                                                       message, optionalExtendedMessageControl);
            break;
        }
        case ZCL_CANCEL_MESSAGE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t messageId;     // Ver.: always
            uint8_t messageControl; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            messageControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfMessagingClusterCancelMessageCallback(messageId, messageControl);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Tunneling, client
EmberAfStatus emberAfTunnelingClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_REQUEST_TUNNEL_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId;                    // Ver.: always
            uint8_t tunnelStatus;                 // Ver.: always
            uint16_t maximumIncomingTransferSize; // Ver.: since se-1.1a-07-5356-17
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 2u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1a-07-5356-17
                maximumIncomingTransferSize = 0xFFFF;
            }
            else
            {
                maximumIncomingTransferSize = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfTunnelingClusterRequestTunnelResponseCallback(tunnelId, tunnelStatus, maximumIncomingTransferSize);
            break;
        }
        case ZCL_TRANSFER_DATA_SERVER_TO_CLIENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId; // Ver.: always
            uint8_t * data;    // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            data       = cmd->buffer + payloadOffset;
            wasHandled = emberAfTunnelingClusterTransferDataServerToClientCallback(tunnelId, data);
            break;
        }
        case ZCL_TRANSFER_DATA_ERROR_SERVER_TO_CLIENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId;          // Ver.: always
            uint8_t transferDataStatus; // Ver.: always
            // Command is fixed length: 3
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            transferDataStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled         = emberAfTunnelingClusterTransferDataErrorServerToClientCallback(tunnelId, transferDataStatus);
            break;
        }
        case ZCL_TUNNEL_CLOSURE_NOTIFICATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t tunnelId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tunnelId   = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfTunnelingClusterTunnelClosureNotificationCallback(tunnelId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Calendar, client
EmberAfStatus emberAfCalendarClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_CALENDAR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;           // Ver.: always
            uint32_t issuerEventId;        // Ver.: always
            uint32_t issuerCalendarId;     // Ver.: always
            uint32_t startTime;            // Ver.: always
            uint8_t calendarType;          // Ver.: always
            uint8_t calendarTimeReference; // Ver.: always
            uint8_t * calendarName;        // Ver.: always
            uint8_t numberOfSeasons;       // Ver.: always
            uint8_t numberOfWeekProfiles;  // Ver.: always
            uint8_t numberOfDayProfiles;   // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            calendarTimeReference = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            calendarName = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfSeasons = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfWeekProfiles = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfDayProfiles = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfCalendarClusterPublishCalendarCallback(providerId, issuerEventId, issuerCalendarId, startTime,
                                                                       calendarType, calendarTimeReference, calendarName,
                                                                       numberOfSeasons, numberOfWeekProfiles, numberOfDayProfiles);
            break;
        }
        case ZCL_PUBLISH_DAY_PROFILE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                  // Ver.: always
            uint32_t issuerEventId;               // Ver.: always
            uint32_t issuerCalendarId;            // Ver.: always
            uint8_t dayId;                        // Ver.: always
            uint8_t totalNumberOfScheduleEntries; // Ver.: always
            uint8_t commandIndex;                 // Ver.: always
            uint8_t totalNumberOfCommands;        // Ver.: always
            uint8_t calendarType;                 // Ver.: always
            uint8_t * dayScheduleEntries;         // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            dayId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfScheduleEntries = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayScheduleEntries = cmd->buffer + payloadOffset;
            wasHandled         = emberAfCalendarClusterPublishDayProfileCallback(providerId, issuerEventId, issuerCalendarId, dayId,
                                                                         totalNumberOfScheduleEntries, commandIndex,
                                                                         totalNumberOfCommands, calendarType, dayScheduleEntries);
            break;
        }
        case ZCL_PUBLISH_WEEK_PROFILE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerEventId;    // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            uint8_t weekId;            // Ver.: always
            uint8_t dayIdRefMonday;    // Ver.: always
            uint8_t dayIdRefTuesday;   // Ver.: always
            uint8_t dayIdRefWednesday; // Ver.: always
            uint8_t dayIdRefThursday;  // Ver.: always
            uint8_t dayIdRefFriday;    // Ver.: always
            uint8_t dayIdRefSaturday;  // Ver.: always
            uint8_t dayIdRefSunday;    // Ver.: always
            // Command is fixed length: 20
            if (cmd->bufLen < payloadOffset + 20u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            weekId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefMonday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefTuesday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefWednesday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefThursday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefFriday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefSaturday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dayIdRefSunday = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfCalendarClusterPublishWeekProfileCallback(
                providerId, issuerEventId, issuerCalendarId, weekId, dayIdRefMonday, dayIdRefTuesday, dayIdRefWednesday,
                dayIdRefThursday, dayIdRefFriday, dayIdRefSaturday, dayIdRefSunday);
            break;
        }
        case ZCL_PUBLISH_SEASONS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;           // Ver.: always
            uint32_t issuerEventId;        // Ver.: always
            uint32_t issuerCalendarId;     // Ver.: always
            uint8_t commandIndex;          // Ver.: always
            uint8_t totalNumberOfCommands; // Ver.: always
            uint8_t * seasonEntries;       // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            seasonEntries = cmd->buffer + payloadOffset;
            wasHandled    = emberAfCalendarClusterPublishSeasonsCallback(providerId, issuerEventId, issuerCalendarId, commandIndex,
                                                                      totalNumberOfCommands, seasonEntries);
            break;
        }
        case ZCL_PUBLISH_SPECIAL_DAYS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;              // Ver.: always
            uint32_t issuerEventId;           // Ver.: always
            uint32_t issuerCalendarId;        // Ver.: always
            uint32_t startTime;               // Ver.: always
            uint8_t calendarType;             // Ver.: always
            uint8_t totalNumberOfSpecialDays; // Ver.: always
            uint8_t commandIndex;             // Ver.: always
            uint8_t totalNumberOfCommands;    // Ver.: always
            uint8_t * specialDayEntries;      // Ver.: always
            // Command is fixed length: 20
            if (cmd->bufLen < payloadOffset + 20u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfSpecialDays = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            specialDayEntries = cmd->buffer + payloadOffset;
            wasHandled = emberAfCalendarClusterPublishSpecialDaysCallback(providerId, issuerEventId, issuerCalendarId, startTime,
                                                                          calendarType, totalNumberOfSpecialDays, commandIndex,
                                                                          totalNumberOfCommands, specialDayEntries);
            break;
        }
        case ZCL_CANCEL_CALENDAR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            uint8_t calendarType;      // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled   = emberAfCalendarClusterCancelCalendarCallback(providerId, issuerCalendarId, calendarType);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Device Management, client
EmberAfStatus emberAfDeviceManagementClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_CHANGE_OF_TENANCY_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                   // Ver.: always
            uint32_t issuerEventId;                // Ver.: always
            uint8_t tariffType;                    // Ver.: always
            uint32_t implementationDateTime;       // Ver.: always
            uint32_t proposedTenancyChangeControl; // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            implementationDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            proposedTenancyChangeControl = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                   = emberAfDeviceManagementClusterPublishChangeOfTenancyCallback(
                providerId, issuerEventId, tariffType, implementationDateTime, proposedTenancyChangeControl);
            break;
        }
        case ZCL_PUBLISH_CHANGE_OF_SUPPLIER_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t currentProviderId;                // Ver.: always
            uint32_t issuerEventId;                    // Ver.: always
            uint8_t tariffType;                        // Ver.: always
            uint32_t proposedProviderId;               // Ver.: always
            uint32_t providerChangeImplementationTime; // Ver.: always
            uint32_t providerChangeControl;            // Ver.: always
            uint8_t * proposedProviderName;            // Ver.: always
            uint8_t * proposedProviderContactDetails;  // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currentProviderId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedProviderId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerChangeImplementationTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerChangeControl = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedProviderName = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedProviderContactDetails = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                     = emberAfDeviceManagementClusterPublishChangeOfSupplierCallback(
                currentProviderId, issuerEventId, tariffType, proposedProviderId, providerChangeImplementationTime,
                providerChangeControl, proposedProviderName, proposedProviderContactDetails);
            break;
        }
        case ZCL_REQUEST_NEW_PASSWORD_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;          // Ver.: always
            uint32_t implementationDateTime; // Ver.: always
            uint16_t durationInMinutes;      // Ver.: always
            uint8_t passwordType;            // Ver.: always
            uint8_t * password;              // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            implementationDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            passwordType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            password   = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDeviceManagementClusterRequestNewPasswordResponseCallback(
                issuerEventId, implementationDateTime, durationInMinutes, passwordType, password);
            break;
        }
        case ZCL_UPDATE_SITE_ID_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId; // Ver.: always
            uint32_t siteIdTime;    // Ver.: always
            uint32_t providerId;    // Ver.: always
            uint8_t * siteId;       // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            siteIdTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            siteId     = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDeviceManagementClusterUpdateSiteIdCallback(issuerEventId, siteIdTime, providerId, siteId);
            break;
        }
        case ZCL_SET_EVENT_CONFIGURATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;              // Ver.: always
            uint32_t startDateTime;              // Ver.: always
            uint8_t eventConfiguration;          // Ver.: always
            uint8_t configurationControl;        // Ver.: always
            uint8_t * eventConfigurationPayload; // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            eventConfiguration = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            configurationControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventConfigurationPayload = cmd->buffer + payloadOffset;
            wasHandled                = emberAfDeviceManagementClusterSetEventConfigurationCallback(
                issuerEventId, startDateTime, eventConfiguration, configurationControl, eventConfigurationPayload);
            break;
        }
        case ZCL_GET_EVENT_CONFIGURATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t eventId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventId    = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDeviceManagementClusterGetEventConfigurationCallback(eventId);
            break;
        }
        case ZCL_UPDATE_C_I_N_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;      // Ver.: always
            uint32_t implementationTime; // Ver.: always
            uint32_t providerId;         // Ver.: always
            uint8_t * customerIdNumber;  // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            implementationTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            customerIdNumber = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfDeviceManagementClusterUpdateCINCallback(issuerEventId, implementationTime, providerId, customerIdNumber);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Events, server
EmberAfStatus emberAfEventsClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_EVENT_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t eventControlLogId; // Ver.: always
            uint16_t eventId;          // Ver.: always
            uint32_t startTime;        // Ver.: always
            uint32_t endTime;          // Ver.: always
            uint8_t numberOfEvents;    // Ver.: always
            uint16_t eventOffset;      // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventControlLogId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            endTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventOffset = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled  = emberAfEventsClusterGetEventLogCallback(eventControlLogId, eventId, startTime, endTime, numberOfEvents,
                                                                 eventOffset);
            break;
        }
        case ZCL_CLEAR_EVENT_LOG_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t logId; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            logId      = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfEventsClusterClearEventLogRequestCallback(logId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Sub-GHz, client
EmberAfStatus emberAfSubGhzClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_SUSPEND_ZCL_MESSAGES_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t period; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            period     = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSubGhzClusterSuspendZclMessagesCallback(period);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Key Establishment, client
EmberAfStatus emberAfKeyEstablishmentClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_TERMINATE_KEY_ESTABLISHMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t statusCode;             // Ver.: always
            uint8_t waitTime;               // Ver.: always
            uint16_t keyEstablishmentSuite; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            statusCode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            waitTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfKeyEstablishmentClusterTerminateKeyEstablishmentCallback(statusCode, waitTime, keyEstablishmentSuite);
            break;
        }
        case ZCL_INITIATE_KEY_ESTABLISHMENT_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t requestedKeyEstablishmentSuite; // Ver.: always
            uint8_t ephemeralDataGenerateTime;       // Ver.: always
            uint8_t confirmKeyGenerateTime;          // Ver.: always
            uint8_t * identity;                      // Ver.: always
            // Command is fixed length: 52
            if (cmd->bufLen < payloadOffset + 52u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            requestedKeyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            ephemeralDataGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            confirmKeyGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            identity   = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterInitiateKeyEstablishmentResponseCallback(
                requestedKeyEstablishmentSuite, ephemeralDataGenerateTime, confirmKeyGenerateTime, identity);
            break;
        }
        case ZCL_EPHEMERAL_DATA_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * ephemeralData; // Ver.: always
            // Command is fixed length: 22
            if (cmd->bufLen < payloadOffset + 22u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            ephemeralData = cmd->buffer + payloadOffset;
            wasHandled    = emberAfKeyEstablishmentClusterEphemeralDataResponseCallback(ephemeralData);
            break;
        }
        case ZCL_CONFIRM_KEY_DATA_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * secureMessageAuthenticationCode; // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            secureMessageAuthenticationCode = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterConfirmKeyDataResponseCallback(secureMessageAuthenticationCode);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Key Establishment, server
EmberAfStatus emberAfKeyEstablishmentClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_INITIATE_KEY_ESTABLISHMENT_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t keyEstablishmentSuite;    // Ver.: always
            uint8_t ephemeralDataGenerateTime; // Ver.: always
            uint8_t confirmKeyGenerateTime;    // Ver.: always
            uint8_t * identity;                // Ver.: always
            // Command is fixed length: 52
            if (cmd->bufLen < payloadOffset + 52u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            ephemeralDataGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            confirmKeyGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            identity   = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterInitiateKeyEstablishmentRequestCallback(
                keyEstablishmentSuite, ephemeralDataGenerateTime, confirmKeyGenerateTime, identity);
            break;
        }
        case ZCL_EPHEMERAL_DATA_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * ephemeralData; // Ver.: always
            // Command is fixed length: 22
            if (cmd->bufLen < payloadOffset + 22u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            ephemeralData = cmd->buffer + payloadOffset;
            wasHandled    = emberAfKeyEstablishmentClusterEphemeralDataRequestCallback(ephemeralData);
            break;
        }
        case ZCL_CONFIRM_KEY_DATA_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * secureMessageAuthenticationCode; // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            secureMessageAuthenticationCode = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterConfirmKeyDataRequestCallback(secureMessageAuthenticationCode);
            break;
        }
        case ZCL_TERMINATE_KEY_ESTABLISHMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t statusCode;             // Ver.: always
            uint8_t waitTime;               // Ver.: always
            uint16_t keyEstablishmentSuite; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            statusCode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            waitTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfKeyEstablishmentClusterTerminateKeyEstablishmentCallback(statusCode, waitTime, keyEstablishmentSuite);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}
