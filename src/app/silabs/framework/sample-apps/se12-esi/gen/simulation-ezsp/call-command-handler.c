/**
 *
 *    Copyright (c) 2020 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

/**
 *
 *    Copyright (c) 2020 Silicon Labs
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

// This is a set of generated functions that parse the
// the incomming message, and call appropriate command handler.

#include PLATFORM_HEADER
#ifdef EZSP_HOST
// Includes needed for ember related functions for the EZSP host
#include "app/util/ezsp/ezsp-protocol.h"
#include "app/util/ezsp/ezsp-utils.h"
#include "app/util/ezsp/ezsp.h"
#include "app/util/ezsp/serial-interface.h"
#include "stack/include/ember-types.h"
#include "stack/include/error.h"
#else
// Includes needed for ember related functions for the EM250
#include "stack/include/ember.h"
#endif // EZSP_HOST

#include "af-structs.h"
#include "app/framework/util/util.h"
#include "call-command-handler.h"
#include "callback.h"
#include "command-id.h"

static EmberAfStatus status(bool wasHandled, bool clusterExists, bool mfgSpecific)
{
    if (wasHandled)
    {
        return EMBER_ZCL_STATUS_SUCCESS;
    }
    else if (mfgSpecific)
    {
        return EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND;
    }
    else if (clusterExists)
    {
        return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    }
    else
    {
        return EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER;
    }
}

// Main command parsing controller.
EmberAfStatus emberAfClusterSpecificCommandParse(EmberAfClusterCommand * cmd)
{
    EmberAfStatus result = status(false, false, cmd->mfgSpecific);
    if (cmd->direction == (uint8_t) ZCL_DIRECTION_SERVER_TO_CLIENT &&
        emberAfContainsClientWithMfgCode(cmd->apsFrame->destinationEndpoint, cmd->apsFrame->clusterId, cmd->mfgCode))
    {
        switch (cmd->apsFrame->clusterId)
        {
        case ZCL_PRICE_CLUSTER_ID:
            result = emberAfPriceClusterClientCommandParse(cmd);
            break;
        case ZCL_SIMPLE_METERING_CLUSTER_ID:
            result = emberAfSimpleMeteringClusterClientCommandParse(cmd);
            break;
        case ZCL_PREPAYMENT_CLUSTER_ID:
            result = emberAfPrepaymentClusterClientCommandParse(cmd);
            break;
        case ZCL_ENERGY_MANAGEMENT_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_DEVICE_MANAGEMENT_CLUSTER_ID:
            result = emberAfDeviceManagementClusterClientCommandParse(cmd);
            break;
        case ZCL_EVENTS_CLUSTER_ID:
            result = emberAfEventsClusterClientCommandParse(cmd);
            break;
        case ZCL_KEY_ESTABLISHMENT_CLUSTER_ID:
            result = emberAfKeyEstablishmentClusterClientCommandParse(cmd);
            break;
        default:
            // Unrecognized cluster ID, error status will apply.
            break;
        }
    }
    else if (cmd->direction == (uint8_t) ZCL_DIRECTION_CLIENT_TO_SERVER &&
             emberAfContainsServerWithMfgCode(cmd->apsFrame->destinationEndpoint, cmd->apsFrame->clusterId, cmd->mfgCode))
    {
        switch (cmd->apsFrame->clusterId)
        {
        case ZCL_BASIC_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_TIME_CLUSTER_ID:
            result = status(false, true, cmd->mfgSpecific);
            break;
        case ZCL_PRICE_CLUSTER_ID:
            result = emberAfPriceClusterServerCommandParse(cmd);
            break;
        case ZCL_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_ID:
            result = emberAfDemandResponseLoadControlClusterServerCommandParse(cmd);
            break;
        case ZCL_SIMPLE_METERING_CLUSTER_ID:
            result = emberAfSimpleMeteringClusterServerCommandParse(cmd);
            break;
        case ZCL_MESSAGING_CLUSTER_ID:
            result = emberAfMessagingClusterServerCommandParse(cmd);
            break;
        case ZCL_CALENDAR_CLUSTER_ID:
            result = emberAfCalendarClusterServerCommandParse(cmd);
            break;
        case ZCL_DEVICE_MANAGEMENT_CLUSTER_ID:
            result = emberAfDeviceManagementClusterServerCommandParse(cmd);
            break;
        case ZCL_EVENTS_CLUSTER_ID:
            result = emberAfEventsClusterServerCommandParse(cmd);
            break;
        case ZCL_KEY_ESTABLISHMENT_CLUSTER_ID:
            result = emberAfKeyEstablishmentClusterServerCommandParse(cmd);
            break;
        default:
            // Unrecognized cluster ID, error status will apply.
            break;
        }
    }
    return result;
}

// Cluster: Price, client
EmberAfStatus emberAfPriceClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_PRICE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                       // Ver.: always
            uint8_t * rateLabel;                       // Ver.: always
            uint32_t issuerEventId;                    // Ver.: always
            uint32_t currentTime;                      // Ver.: always
            uint8_t unitOfMeasure;                     // Ver.: always
            uint16_t currency;                         // Ver.: always
            uint8_t priceTrailingDigitAndPriceTier;    // Ver.: always
            uint8_t numberOfPriceTiersAndRegisterTier; // Ver.: always
            uint32_t startTime;                        // Ver.: always
            uint16_t durationInMinutes;                // Ver.: always
            uint32_t price;                            // Ver.: always
            uint8_t priceRatio;                        // Ver.: always
            uint32_t generationPrice;                  // Ver.: always
            uint8_t generationPriceRatio;              // Ver.: always
            uint32_t alternateCostDelivered;           // Ver.: since se-1.0-07-5356-15
            uint8_t alternateCostUnit;                 // Ver.: since se-1.0-07-5356-15
            uint8_t alternateCostTrailingDigit;        // Ver.: since se-1.0-07-5356-15
            uint8_t numberOfBlockThresholds;           // Ver.: since se-1.1-07-5356-16
            uint8_t priceControl;                      // Ver.: since se-1.1-07-5356-16
            uint8_t numberOfGenerationTiers;           // Ver.: since se-1.2a-07-5356-19
            uint8_t generationTier;                    // Ver.: since se-1.2a-07-5356-19
            uint8_t extendedNumberOfPriceTiers;        // Ver.: since se-1.2a-07-5356-19
            uint8_t extendedPriceTier;                 // Ver.: since se-1.2a-07-5356-19
            uint8_t extendedRegisterTier;              // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            rateLabel = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currentTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            unitOfMeasure = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            priceTrailingDigitAndPriceTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfPriceTiersAndRegisterTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            price = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            priceRatio = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            generationPrice = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            generationPriceRatio = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 4u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.0-07-5356-15
                alternateCostDelivered = 0xFFFFFFFF;
            }
            else
            {
                alternateCostDelivered = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 4u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.0-07-5356-15
                alternateCostUnit = 0xFF;
            }
            else
            {
                alternateCostUnit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.0-07-5356-15
                alternateCostTrailingDigit = 0xFF;
            }
            else
            {
                alternateCostTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1-07-5356-16
                numberOfBlockThresholds = 0xFF;
            }
            else
            {
                numberOfBlockThresholds = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.1-07-5356-16
                priceControl = 0x00;
            }
            else
            {
                priceControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                numberOfGenerationTiers = 0x00;
            }
            else
            {
                numberOfGenerationTiers = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                generationTier = 0x00;
            }
            else
            {
                generationTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                extendedNumberOfPriceTiers = 0x00;
            }
            else
            {
                extendedNumberOfPriceTiers = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                extendedPriceTier = 0x00;
            }
            else
            {
                extendedPriceTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                extendedRegisterTier = 0x00;
            }
            else
            {
                extendedRegisterTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfPriceClusterPublishPriceCallback(
                providerId, rateLabel, issuerEventId, currentTime, unitOfMeasure, currency, priceTrailingDigitAndPriceTier,
                numberOfPriceTiersAndRegisterTier, startTime, durationInMinutes, price, priceRatio, generationPrice,
                generationPriceRatio, alternateCostDelivered, alternateCostUnit, alternateCostTrailingDigit,
                numberOfBlockThresholds, priceControl, numberOfGenerationTiers, generationTier, extendedNumberOfPriceTiers,
                extendedPriceTier, extendedRegisterTier);
            break;
        }
        case ZCL_PUBLISH_BLOCK_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;             // Ver.: always
            uint32_t issuerEventId;          // Ver.: always
            uint32_t blockPeriodStartTime;   // Ver.: always
            uint32_t blockPeriodDuration;    // Ver.: always
            uint8_t blockPeriodControl;      // Ver.: always
            uint8_t blockPeriodDurationType; // Ver.: since se-1.2a-07-5356-19
            uint8_t tariffType;              // Ver.: since se-1.2a-07-5356-19
            uint8_t tariffResolutionPeriod;  // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockPeriodControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                blockPeriodDurationType = 0xFF;
            }
            else
            {
                blockPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                tariffType = 0xFF;
            }
            else
            {
                tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                tariffResolutionPeriod = 0xFF;
            }
            else
            {
                tariffResolutionPeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfPriceClusterPublishBlockPeriodCallback(providerId, issuerEventId, blockPeriodStartTime,
                                                                       blockPeriodDuration, blockPeriodControl,
                                                                       blockPeriodDurationType, tariffType, tariffResolutionPeriod);
            break;
        }
        case ZCL_PUBLISH_CONVERSION_FACTOR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;                // Ver.: always
            uint32_t startTime;                    // Ver.: always
            uint32_t conversionFactor;             // Ver.: always
            uint8_t conversionFactorTrailingDigit; // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactor = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactorTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishConversionFactorCallback(issuerEventId, startTime, conversionFactor,
                                                                            conversionFactorTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_CALORIFIC_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;              // Ver.: always
            uint32_t startTime;                  // Ver.: always
            uint32_t calorificValue;             // Ver.: always
            uint8_t calorificValueUnit;          // Ver.: always
            uint8_t calorificValueTrailingDigit; // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calorificValue = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            calorificValueUnit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            calorificValueTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                  = emberAfPriceClusterPublishCalorificValueCallback(issuerEventId, startTime, calorificValue,
                                                                          calorificValueUnit, calorificValueTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_TARIFF_INFORMATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                  // Ver.: always
            uint32_t issuerEventId;               // Ver.: always
            uint32_t issuerTariffId;              // Ver.: always
            uint32_t startTime;                   // Ver.: always
            uint8_t tariffTypeChargingScheme;     // Ver.: always
            uint8_t * tariffLabel;                // Ver.: always
            uint8_t numberOfPriceTiersInUse;      // Ver.: always
            uint8_t numberOfBlockThresholdsInUse; // Ver.: always
            uint8_t unitOfMeasure;                // Ver.: always
            uint16_t currency;                    // Ver.: always
            uint8_t priceTrailingDigit;           // Ver.: always
            uint32_t standingCharge;              // Ver.: always
            uint8_t tierBlockMode;                // Ver.: always
            uint32_t blockThresholdMultiplier;    // Ver.: always
            uint32_t blockThresholdDivisor;       // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffTypeChargingScheme = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffLabel = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfPriceTiersInUse = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfBlockThresholdsInUse = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            unitOfMeasure = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            priceTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            standingCharge = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tierBlockMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockThresholdMultiplier = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            if (cmd->bufLen < payloadOffset + 3u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            blockThresholdDivisor = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled            = emberAfPriceClusterPublishTariffInformationCallback(
                providerId, issuerEventId, issuerTariffId, startTime, tariffTypeChargingScheme, tariffLabel,
                numberOfPriceTiersInUse, numberOfBlockThresholdsInUse, unitOfMeasure, currency, priceTrailingDigit, standingCharge,
                tierBlockMode, blockThresholdMultiplier, blockThresholdDivisor);
            break;
        }
        case ZCL_PUBLISH_BLOCK_THRESHOLDS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerEventId;    // Ver.: always
            uint32_t startTime;        // Ver.: always
            uint32_t issuerTariffId;   // Ver.: always
            uint8_t commandIndex;      // Ver.: always
            uint8_t numberOfCommands;  // Ver.: always
            uint8_t subPayloadControl; // Ver.: always
            uint8_t * payload;         // Ver.: always
            // Command is fixed length: 19
            if (cmd->bufLen < payloadOffset + 19u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            subPayloadControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            payload    = cmd->buffer + payloadOffset;
            wasHandled = emberAfPriceClusterPublishBlockThresholdsCallback(
                providerId, issuerEventId, startTime, issuerTariffId, commandIndex, numberOfCommands, subPayloadControl, payload);
            break;
        }
        case ZCL_PUBLISH_C_O2_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;           // Ver.: always
            uint32_t issuerEventId;        // Ver.: always
            uint32_t startTime;            // Ver.: always
            uint8_t tariffType;            // Ver.: always
            uint32_t cO2Value;             // Ver.: always
            uint8_t cO2ValueUnit;          // Ver.: always
            uint8_t cO2ValueTrailingDigit; // Ver.: always
            // Command is fixed length: 19
            if (cmd->bufLen < payloadOffset + 19u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cO2Value = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            cO2ValueUnit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cO2ValueTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishCO2ValueCallback(providerId, issuerEventId, startTime, tariffType, cO2Value,
                                                                    cO2ValueUnit, cO2ValueTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_TIER_LABELS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;         // Ver.: always
            uint32_t issuerEventId;      // Ver.: always
            uint32_t issuerTariffId;     // Ver.: always
            uint8_t commandIndex;        // Ver.: always
            uint8_t numberOfCommands;    // Ver.: always
            uint8_t numberOfLabels;      // Ver.: always
            uint8_t * tierLabelsPayload; // Ver.: always
            // Command is fixed length: 15
            if (cmd->bufLen < payloadOffset + 15u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfLabels = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tierLabelsPayload = cmd->buffer + payloadOffset;
            wasHandled = emberAfPriceClusterPublishTierLabelsCallback(providerId, issuerEventId, issuerTariffId, commandIndex,
                                                                      numberOfCommands, numberOfLabels, tierLabelsPayload);
            break;
        }
        case ZCL_PUBLISH_BILLING_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;               // Ver.: always
            uint32_t issuerEventId;            // Ver.: always
            uint32_t billingPeriodStartTime;   // Ver.: always
            uint32_t billingPeriodDuration;    // Ver.: always
            uint8_t billingPeriodDurationType; // Ver.: always
            uint8_t tariffType;                // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            billingPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishBillingPeriodCallback(
                providerId, issuerEventId, billingPeriodStartTime, billingPeriodDuration, billingPeriodDurationType, tariffType);
            break;
        }
        case ZCL_PUBLISH_CONSOLIDATED_BILL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;               // Ver.: always
            uint32_t issuerEventId;            // Ver.: always
            uint32_t billingPeriodStartTime;   // Ver.: always
            uint32_t billingPeriodDuration;    // Ver.: always
            uint8_t billingPeriodDurationType; // Ver.: always
            uint8_t tariffType;                // Ver.: always
            uint32_t consolidatedBill;         // Ver.: always
            uint16_t currency;                 // Ver.: always
            uint8_t billTrailingDigit;         // Ver.: always
            // Command is fixed length: 24
            if (cmd->bufLen < payloadOffset + 24u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            billingPeriodDuration = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            billingPeriodDurationType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            consolidatedBill = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            currency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            billTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled        = emberAfPriceClusterPublishConsolidatedBillCallback(
                providerId, issuerEventId, billingPeriodStartTime, billingPeriodDuration, billingPeriodDurationType, tariffType,
                consolidatedBill, currency, billTrailingDigit);
            break;
        }
        case ZCL_PUBLISH_CPP_EVENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;        // Ver.: always
            uint32_t issuerEventId;     // Ver.: always
            uint32_t startTime;         // Ver.: always
            uint16_t durationInMinutes; // Ver.: always
            uint8_t tariffType;         // Ver.: always
            uint8_t cppPriceTier;       // Ver.: always
            uint8_t cppAuth;            // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cppPriceTier = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            cppAuth    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPublishCppEventCallback(providerId, issuerEventId, startTime, durationInMinutes,
                                                                    tariffType, cppPriceTier, cppAuth);
            break;
        }
        case ZCL_PUBLISH_CREDIT_PAYMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                 // Ver.: always
            uint32_t issuerEventId;              // Ver.: always
            uint32_t creditPaymentDueDate;       // Ver.: always
            uint32_t creditPaymentOverDueAmount; // Ver.: always
            uint8_t creditPaymentStatus;         // Ver.: always
            uint32_t creditPayment;              // Ver.: always
            uint32_t creditPaymentDate;          // Ver.: always
            uint8_t * creditPaymentRef;          // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentDueDate = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentOverDueAmount = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPayment = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentDate = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            creditPaymentRef = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled       = emberAfPriceClusterPublishCreditPaymentCallback(providerId, issuerEventId, creditPaymentDueDate,
                                                                         creditPaymentOverDueAmount, creditPaymentStatus,
                                                                         creditPayment, creditPaymentDate, creditPaymentRef);
            break;
        }
        case ZCL_PUBLISH_CURRENCY_CONVERSION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                   // Ver.: always
            uint32_t issuerEventId;                // Ver.: always
            uint32_t startTime;                    // Ver.: always
            uint16_t oldCurrency;                  // Ver.: always
            uint16_t newCurrency;                  // Ver.: always
            uint32_t conversionFactor;             // Ver.: always
            uint8_t conversionFactorTrailingDigit; // Ver.: always
            uint32_t currencyChangeControlFlags;   // Ver.: always
            // Command is fixed length: 25
            if (cmd->bufLen < payloadOffset + 25u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            oldCurrency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            newCurrency = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            conversionFactor = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            conversionFactorTrailingDigit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            currencyChangeControlFlags = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                 = emberAfPriceClusterPublishCurrencyConversionCallback(
                providerId, issuerEventId, startTime, oldCurrency, newCurrency, conversionFactor, conversionFactorTrailingDigit,
                currencyChangeControlFlags);
            break;
        }
        case ZCL_CANCEL_TARIFF_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;     // Ver.: always
            uint32_t issuerTariffId; // Ver.: always
            uint8_t tariffType;      // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterCancelTariffCallback(providerId, issuerTariffId, tariffType);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Price, server
EmberAfStatus emberAfPriceClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_CURRENT_PRICE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t commandOptions; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            commandOptions = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetCurrentPriceCallback(commandOptions);
            break;
        }
        case ZCL_GET_SCHEDULED_PRICES_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t startTime;     // Ver.: always
            uint8_t numberOfEvents; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetScheduledPricesCallback(startTime, numberOfEvents);
            break;
        }
        case ZCL_PRICE_ACKNOWLEDGEMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;    // Ver.: always
            uint32_t issuerEventId; // Ver.: always
            uint32_t priceAckTime;  // Ver.: always
            uint8_t control;        // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            priceAckTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            control    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterPriceAcknowledgementCallback(providerId, issuerEventId, priceAckTime, control);
            break;
        }
        case ZCL_GET_BLOCK_PERIODS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t startTime;     // Ver.: always
            uint8_t numberOfEvents; // Ver.: always
            uint8_t tariffType;     // Ver.: always
            // Command is fixed length: 6
            if (cmd->bufLen < payloadOffset + 6u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterGetBlockPeriodsCallback(startTime, numberOfEvents, tariffType);
            break;
        }
        case ZCL_GET_CONVERSION_FACTOR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterGetConversionFactorCallback(earliestStartTime, minIssuerEventId, numberOfCommands);
            break;
        }
        case ZCL_GET_CALORIFIC_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled       = emberAfPriceClusterGetCalorificValueCallback(earliestStartTime, minIssuerEventId, numberOfCommands);
            break;
        }
        case ZCL_GET_TARIFF_INFORMATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfPriceClusterGetTariffInformationCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_GET_PRICE_MATRIX_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerTariffId; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetPriceMatrixCallback(issuerTariffId);
            break;
        }
        case ZCL_GET_BLOCK_THRESHOLDS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerTariffId; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetBlockThresholdsCallback(issuerTariffId);
            break;
        }
        case ZCL_GET_C_O2_VALUE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterGetCO2ValueCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_GET_TIER_LABELS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerTariffId; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerTariffId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled     = emberAfPriceClusterGetTierLabelsCallback(issuerTariffId);
            break;
        }
        case ZCL_GET_BILLING_PERIOD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfPriceClusterGetBillingPeriodCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_GET_CONSOLIDATED_BILL_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCommands;   // Ver.: always
            uint8_t tariffType;         // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfPriceClusterGetConsolidatedBillCallback(earliestStartTime, minIssuerEventId, numberOfCommands, tariffType);
            break;
        }
        case ZCL_CPP_EVENT_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId; // Ver.: always
            uint8_t cppAuth;        // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            cppAuth    = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPriceClusterCppEventResponseCallback(issuerEventId, cppAuth);
            break;
        }
        case ZCL_GET_CREDIT_PAYMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t latestEndTime;  // Ver.: always
            uint8_t numberOfRecords; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            latestEndTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfRecords = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled      = emberAfPriceClusterGetCreditPaymentCallback(latestEndTime, numberOfRecords);
            break;
        }
        case ZCL_GET_CURRENCY_CONVERSION_COMMAND_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfPriceClusterGetCurrencyConversionCommandCallback();
            break;
        }
        case ZCL_GET_TARIFF_CANCELLATION_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfPriceClusterGetTariffCancellationCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Demand Response and Load Control, server
EmberAfStatus emberAfDemandResponseLoadControlClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_REPORT_EVENT_STATUS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;                        // Ver.: always
            uint8_t eventStatus;                           // Ver.: always
            uint32_t eventStatusTime;                      // Ver.: always
            uint8_t criticalityLevelApplied;               // Ver.: always
            uint16_t coolingTemperatureSetPointApplied;    // Ver.: always
            uint16_t heatingTemperatureSetPointApplied;    // Ver.: always
            int8_t averageLoadAdjustmentPercentageApplied; // Ver.: always
            uint8_t dutyCycleApplied;                      // Ver.: always
            uint8_t eventControl;                          // Ver.: always
            uint8_t signatureType;                         // Ver.: always
            uint8_t * signature;                           // Ver.: always
            // Command is fixed length: 60
            if (cmd->bufLen < payloadOffset + 60u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            eventStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventStatusTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            criticalityLevelApplied = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            coolingTemperatureSetPointApplied = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            heatingTemperatureSetPointApplied = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            averageLoadAdjustmentPercentageApplied = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            dutyCycleApplied = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            signatureType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            signature  = cmd->buffer + payloadOffset;
            wasHandled = emberAfDemandResponseLoadControlClusterReportEventStatusCallback(
                issuerEventId, eventStatus, eventStatusTime, criticalityLevelApplied, coolingTemperatureSetPointApplied,
                heatingTemperatureSetPointApplied, averageLoadAdjustmentPercentageApplied, dutyCycleApplied, eventControl,
                signatureType, signature);
            break;
        }
        case ZCL_GET_SCHEDULED_EVENTS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t startTime;     // Ver.: always
            uint8_t numberOfEvents; // Ver.: always
            uint32_t issuerEventId; // Ver.: since se-1.2b-15-0131-02
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if ((cmd->bufLen < payloadOffset + 4u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2b-15-0131-02
                issuerEventId = 0xFFFFFFFF;
            }
            else
            {
                issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled =
                emberAfDemandResponseLoadControlClusterGetScheduledEventsCallback(startTime, numberOfEvents, issuerEventId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Simple Metering, client
EmberAfStatus emberAfSimpleMeteringClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_PROFILE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t endTime;                 // Ver.: always
            uint8_t status;                   // Ver.: always
            uint8_t profileIntervalPeriod;    // Ver.: always
            uint8_t numberOfPeriodsDelivered; // Ver.: always
            uint8_t * intervals;              // Ver.: always
            // Command is fixed length: 7
            if (cmd->bufLen < payloadOffset + 7u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            endTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            status = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            profileIntervalPeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfPeriodsDelivered = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            intervals  = cmd->buffer + payloadOffset;
            wasHandled = emberAfSimpleMeteringClusterGetProfileResponseCallback(endTime, status, profileIntervalPeriod,
                                                                                numberOfPeriodsDelivered, intervals);
            break;
        }
        case ZCL_REQUEST_MIRROR_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfSimpleMeteringClusterRequestMirrorCallback();
            break;
        }
        case ZCL_REMOVE_MIRROR_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfSimpleMeteringClusterRemoveMirrorCallback();
            break;
        }
        case ZCL_REQUEST_FAST_POLL_MODE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t appliedUpdatePeriod;  // Ver.: always
            uint32_t fastPollModeEndtime; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            appliedUpdatePeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            fastPollModeEndtime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterRequestFastPollModeResponseCallback(appliedUpdatePeriod, fastPollModeEndtime);
            break;
        }
        case ZCL_SCHEDULE_SNAPSHOT_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;            // Ver.: always
            uint8_t * snapshotResponsePayload; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotResponsePayload = cmd->buffer + payloadOffset;
            wasHandled = emberAfSimpleMeteringClusterScheduleSnapshotResponseCallback(issuerEventId, snapshotResponsePayload);
            break;
        }
        case ZCL_TAKE_SNAPSHOT_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t snapshotId;          // Ver.: always
            uint8_t snapshotConfirmation; // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            snapshotId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotConfirmation = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled           = emberAfSimpleMeteringClusterTakeSnapshotResponseCallback(snapshotId, snapshotConfirmation);
            break;
        }
        case ZCL_PUBLISH_SNAPSHOT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t snapshotId;         // Ver.: always
            uint32_t snapshotTime;       // Ver.: always
            uint8_t totalSnapshotsFound; // Ver.: always
            uint8_t commandIndex;        // Ver.: always
            uint8_t totalCommands;       // Ver.: always
            uint32_t snapshotCause;      // Ver.: always
            uint8_t snapshotPayloadType; // Ver.: always
            uint8_t * snapshotPayload;   // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            snapshotId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            totalSnapshotsFound = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotCause = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotPayloadType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotPayload = cmd->buffer + payloadOffset;
            wasHandled      = emberAfSimpleMeteringClusterPublishSnapshotCallback(snapshotId, snapshotTime, totalSnapshotsFound,
                                                                             commandIndex, totalCommands, snapshotCause,
                                                                             snapshotPayloadType, snapshotPayload);
            break;
        }
        case ZCL_CONFIGURE_MIRROR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;              // Ver.: always
            uint32_t reportingInterval;          // Ver.: always
            uint8_t mirrorNotificationReporting; // Ver.: always
            uint8_t notificationScheme;          // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            reportingInterval = emberAfGetInt24u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 3u;
            mirrorNotificationReporting = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            notificationScheme = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled         = emberAfSimpleMeteringClusterConfigureMirrorCallback(issuerEventId, reportingInterval,
                                                                             mirrorNotificationReporting, notificationScheme);
            break;
        }
        case ZCL_GET_NOTIFIED_MESSAGE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t notificationScheme;           // Ver.: always
            uint16_t notificationFlagAttributeId; // Ver.: always
            uint32_t notificationFlagsN;          // Ver.: always
            // Command is fixed length: 7
            if (cmd->bufLen < payloadOffset + 7u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            notificationScheme = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            notificationFlagAttributeId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            notificationFlagsN = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterGetNotifiedMessageCallback(notificationScheme, notificationFlagAttributeId,
                                                                                notificationFlagsN);
            break;
        }
        case ZCL_SUPPLY_STATUS_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;             // Ver.: always
            uint32_t issuerEventId;          // Ver.: always
            uint32_t implementationDateTime; // Ver.: always
            uint8_t supplyStatus;            // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            implementationDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            supplyStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterSupplyStatusResponseCallback(providerId, issuerEventId, implementationDateTime,
                                                                                  supplyStatus);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Simple Metering, server
EmberAfStatus emberAfSimpleMeteringClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_PROFILE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t intervalChannel; // Ver.: always
            uint32_t endTime;        // Ver.: always
            uint8_t numberOfPeriods; // Ver.: always
            // Command is fixed length: 6
            if (cmd->bufLen < payloadOffset + 6u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            intervalChannel = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            endTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfPeriods = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled      = emberAfSimpleMeteringClusterGetProfileCallback(intervalChannel, endTime, numberOfPeriods);
            break;
        }
        case ZCL_REQUEST_MIRROR_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t endpointId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            endpointId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterRequestMirrorResponseCallback(endpointId);
            break;
        }
        case ZCL_MIRROR_REMOVED_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t endpointId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            endpointId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterMirrorRemovedCallback(endpointId);
            break;
        }
        case ZCL_REQUEST_FAST_POLL_MODE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t fastPollUpdatePeriod; // Ver.: always
            uint8_t duration;             // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            fastPollUpdatePeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            duration   = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterRequestFastPollModeCallback(fastPollUpdatePeriod, duration);
            break;
        }
        case ZCL_SCHEDULE_SNAPSHOT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;            // Ver.: always
            uint8_t commandIndex;              // Ver.: always
            uint8_t commandCount;              // Ver.: always
            uint8_t * snapshotSchedulePayload; // Ver.: always
            // Command is fixed length: 6
            if (cmd->bufLen < payloadOffset + 6u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            commandCount = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotSchedulePayload = cmd->buffer + payloadOffset;
            wasHandled = emberAfSimpleMeteringClusterScheduleSnapshotCallback(issuerEventId, commandIndex, commandCount,
                                                                              snapshotSchedulePayload);
            break;
        }
        case ZCL_TAKE_SNAPSHOT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t snapshotCause; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            snapshotCause = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled    = emberAfSimpleMeteringClusterTakeSnapshotCallback(snapshotCause);
            break;
        }
        case ZCL_GET_SNAPSHOT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t latestEndTime;     // Ver.: always
            uint8_t snapshotOffset;     // Ver.: always
            uint32_t snapshotCause;     // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            latestEndTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotOffset = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotCause = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfSimpleMeteringClusterGetSnapshotCallback(earliestStartTime, latestEndTime, snapshotOffset, snapshotCause);
            break;
        }
        case ZCL_START_SAMPLING_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;         // Ver.: always
            uint32_t startSamplingTime;     // Ver.: always
            uint8_t sampleType;             // Ver.: always
            uint16_t sampleRequestInterval; // Ver.: always
            uint16_t maxNumberOfSamples;    // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startSamplingTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            sampleType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            sampleRequestInterval = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            maxNumberOfSamples = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled         = emberAfSimpleMeteringClusterStartSamplingCallback(issuerEventId, startSamplingTime, sampleType,
                                                                           sampleRequestInterval, maxNumberOfSamples);
            break;
        }
        case ZCL_GET_SAMPLED_DATA_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t sampleId;           // Ver.: always
            uint32_t earliestSampleTime; // Ver.: always
            uint8_t sampleType;          // Ver.: always
            uint16_t numberOfSamples;    // Ver.: always
            // Command is fixed length: 9
            if (cmd->bufLen < payloadOffset + 9u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            sampleId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            earliestSampleTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            sampleType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfSamples = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfSimpleMeteringClusterGetSampledDataCallback(sampleId, earliestSampleTime, sampleType, numberOfSamples);
            break;
        }
        case ZCL_MIRROR_REPORT_ATTRIBUTE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t notificationScheme;  // Ver.: always
            uint8_t * notificationFlags; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            notificationScheme = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            notificationFlags = cmd->buffer + payloadOffset;
            wasHandled = emberAfSimpleMeteringClusterMirrorReportAttributeResponseCallback(notificationScheme, notificationFlags);
            break;
        }
        case ZCL_RESET_LOAD_LIMIT_COUNTER_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;    // Ver.: always
            uint32_t issuerEventId; // Ver.: always
            // Command is fixed length: 8
            if (cmd->bufLen < payloadOffset + 8u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled    = emberAfSimpleMeteringClusterResetLoadLimitCounterCallback(providerId, issuerEventId);
            break;
        }
        case ZCL_CHANGE_SUPPLY_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;             // Ver.: always
            uint32_t issuerEventId;          // Ver.: always
            uint32_t requestDateTime;        // Ver.: always
            uint32_t implementationDateTime; // Ver.: always
            uint8_t proposedSupplyStatus;    // Ver.: always
            uint8_t supplyControlBits;       // Ver.: always
            // Command is fixed length: 18
            if (cmd->bufLen < payloadOffset + 18u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            requestDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            implementationDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            proposedSupplyStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            supplyControlBits = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled        = emberAfSimpleMeteringClusterChangeSupplyCallback(
                providerId, issuerEventId, requestDateTime, implementationDateTime, proposedSupplyStatus, supplyControlBits);
            break;
        }
        case ZCL_LOCAL_CHANGE_SUPPLY_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t proposedSupplyStatus; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedSupplyStatus = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled           = emberAfSimpleMeteringClusterLocalChangeSupplyCallback(proposedSupplyStatus);
            break;
        }
        case ZCL_SET_SUPPLY_STATUS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;              // Ver.: always
            uint8_t supplyTamperState;           // Ver.: always
            uint8_t supplyDepletionState;        // Ver.: always
            uint8_t supplyUncontrolledFlowState; // Ver.: always
            uint8_t loadLimitSupplyState;        // Ver.: always
            // Command is fixed length: 8
            if (cmd->bufLen < payloadOffset + 8u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            supplyTamperState = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            supplyDepletionState = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            supplyUncontrolledFlowState = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            loadLimitSupplyState = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfSimpleMeteringClusterSetSupplyStatusCallback(issuerEventId, supplyTamperState, supplyDepletionState,
                                                                             supplyUncontrolledFlowState, loadLimitSupplyState);
            break;
        }
        case ZCL_SET_UNCONTROLLED_FLOW_THRESHOLD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                // Ver.: always
            uint32_t issuerEventId;             // Ver.: always
            uint16_t uncontrolledFlowThreshold; // Ver.: always
            uint8_t unitOfMeasure;              // Ver.: always
            uint16_t multiplier;                // Ver.: always
            uint16_t divisor;                   // Ver.: always
            uint8_t stabilisationPeriod;        // Ver.: always
            uint16_t measurementPeriod;         // Ver.: always
            // Command is fixed length: 18
            if (cmd->bufLen < payloadOffset + 18u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            uncontrolledFlowThreshold = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            unitOfMeasure = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            multiplier = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            divisor = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            stabilisationPeriod = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            measurementPeriod = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled        = emberAfSimpleMeteringClusterSetUncontrolledFlowThresholdCallback(
                providerId, issuerEventId, uncontrolledFlowThreshold, unitOfMeasure, multiplier, divisor, stabilisationPeriod,
                measurementPeriod);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Messaging, server
EmberAfStatus emberAfMessagingClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_LAST_MESSAGE_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfMessagingClusterGetLastMessageCallback();
            break;
        }
        case ZCL_MESSAGE_CONFIRMATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t messageId;                 // Ver.: always
            uint32_t confirmationTime;          // Ver.: always
            uint8_t messageConfirmationControl; // Ver.: since se-1.2a-07-5356-19
            uint8_t * messageResponse;          // Ver.: since se-1.2a-07-5356-19
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            messageId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            confirmationTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if ((cmd->bufLen < payloadOffset + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                messageConfirmationControl = 0xFF;
            }
            else
            {
                messageConfirmationControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
                payloadOffset += 1u;
            }
            if ((cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u))
            {
                // Argument is not always present:
                // - it is present only in versions higher than: se-1.2a-07-5356-19
                messageResponse = NULL;
            }
            else
            {
                messageResponse = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            }
            wasHandled = emberAfMessagingClusterMessageConfirmationCallback(messageId, confirmationTime, messageConfirmationControl,
                                                                            messageResponse);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Prepayment, client
EmberAfStatus emberAfPrepaymentClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_PREPAY_SNAPSHOT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t snapshotId;           // Ver.: always
            uint32_t snapshotTime;         // Ver.: always
            uint8_t totalSnapshotsFound;   // Ver.: always
            uint8_t commandIndex;          // Ver.: always
            uint8_t totalNumberOfCommands; // Ver.: always
            uint32_t snapshotCause;        // Ver.: always
            uint8_t snapshotPayloadType;   // Ver.: always
            uint8_t * snapshotPayload;     // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            snapshotId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            totalSnapshotsFound = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotCause = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            snapshotPayloadType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            snapshotPayload = cmd->buffer + payloadOffset;
            wasHandled      = emberAfPrepaymentClusterPublishPrepaySnapshotCallback(snapshotId, snapshotTime, totalSnapshotsFound,
                                                                               commandIndex, totalNumberOfCommands, snapshotCause,
                                                                               snapshotPayloadType, snapshotPayload);
            break;
        }
        case ZCL_CHANGE_PAYMENT_MODE_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t friendlyCredit;            // Ver.: always
            uint32_t friendlyCreditCalendarId; // Ver.: always
            uint32_t emergencyCreditLimit;     // Ver.: always
            uint32_t emergencyCreditThreshold; // Ver.: always
            // Command is fixed length: 13
            if (cmd->bufLen < payloadOffset + 13u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            friendlyCredit = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            friendlyCreditCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            emergencyCreditLimit = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            emergencyCreditThreshold = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfPrepaymentClusterChangePaymentModeResponseCallback(friendlyCredit, friendlyCreditCalendarId,
                                                                                   emergencyCreditLimit, emergencyCreditThreshold);
            break;
        }
        case ZCL_PUBLISH_TOP_UP_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t commandIndex;          // Ver.: always
            uint8_t totalNumberOfCommands; // Ver.: always
            uint8_t * topUpPayload;        // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            topUpPayload = cmd->buffer + payloadOffset;
            wasHandled   = emberAfPrepaymentClusterPublishTopUpLogCallback(commandIndex, totalNumberOfCommands, topUpPayload);
            break;
        }
        case ZCL_PUBLISH_DEBT_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t commandIndex;          // Ver.: always
            uint8_t totalNumberOfCommands; // Ver.: always
            uint8_t * debtPayload;         // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalNumberOfCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            debtPayload = cmd->buffer + payloadOffset;
            wasHandled  = emberAfPrepaymentClusterPublishDebtLogCallback(commandIndex, totalNumberOfCommands, debtPayload);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Calendar, server
EmberAfStatus emberAfCalendarClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_CALENDAR_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t earliestStartTime; // Ver.: always
            uint32_t minIssuerEventId;  // Ver.: always
            uint8_t numberOfCalendars;  // Ver.: always
            uint8_t calendarType;       // Ver.: always
            uint32_t providerId;        // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            earliestStartTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            minIssuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfCalendars = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfCalendarClusterGetCalendarCallback(earliestStartTime, minIssuerEventId, numberOfCalendars,
                                                                   calendarType, providerId);
            break;
        }
        case ZCL_GET_DAY_PROFILES_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            uint8_t startDayId;        // Ver.: always
            uint8_t numberOfDays;      // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startDayId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfDays = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled   = emberAfCalendarClusterGetDayProfilesCallback(providerId, issuerCalendarId, startDayId, numberOfDays);
            break;
        }
        case ZCL_GET_WEEK_PROFILES_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            uint8_t startWeekId;       // Ver.: always
            uint8_t numberOfWeeks;     // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startWeekId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            numberOfWeeks = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled    = emberAfCalendarClusterGetWeekProfilesCallback(providerId, issuerCalendarId, startWeekId, numberOfWeeks);
            break;
        }
        case ZCL_GET_SEASONS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;       // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            // Command is fixed length: 8
            if (cmd->bufLen < payloadOffset + 8u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled       = emberAfCalendarClusterGetSeasonsCallback(providerId, issuerCalendarId);
            break;
        }
        case ZCL_GET_SPECIAL_DAYS_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t startTime;        // Ver.: always
            uint8_t numberOfEvents;    // Ver.: always
            uint8_t calendarType;      // Ver.: always
            uint32_t providerId;       // Ver.: always
            uint32_t issuerCalendarId; // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            calendarType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerCalendarId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfCalendarClusterGetSpecialDaysCallback(startTime, numberOfEvents, calendarType, providerId, issuerCalendarId);
            break;
        }
        case ZCL_GET_CALENDAR_CANCELLATION_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfCalendarClusterGetCalendarCancellationCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Device Management, client
EmberAfStatus emberAfDeviceManagementClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_CHANGE_OF_TENANCY_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t providerId;                   // Ver.: always
            uint32_t issuerEventId;                // Ver.: always
            uint8_t tariffType;                    // Ver.: always
            uint32_t implementationDateTime;       // Ver.: always
            uint32_t proposedTenancyChangeControl; // Ver.: always
            // Command is fixed length: 17
            if (cmd->bufLen < payloadOffset + 17u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            implementationDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            proposedTenancyChangeControl = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                   = emberAfDeviceManagementClusterPublishChangeOfTenancyCallback(
                providerId, issuerEventId, tariffType, implementationDateTime, proposedTenancyChangeControl);
            break;
        }
        case ZCL_PUBLISH_CHANGE_OF_SUPPLIER_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t currentProviderId;                // Ver.: always
            uint32_t issuerEventId;                    // Ver.: always
            uint8_t tariffType;                        // Ver.: always
            uint32_t proposedProviderId;               // Ver.: always
            uint32_t providerChangeImplementationTime; // Ver.: always
            uint32_t providerChangeControl;            // Ver.: always
            uint8_t * proposedProviderName;            // Ver.: always
            uint8_t * proposedProviderContactDetails;  // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            currentProviderId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            tariffType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedProviderId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerChangeImplementationTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerChangeControl = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedProviderName = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset) + 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            proposedProviderContactDetails = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled                     = emberAfDeviceManagementClusterPublishChangeOfSupplierCallback(
                currentProviderId, issuerEventId, tariffType, proposedProviderId, providerChangeImplementationTime,
                providerChangeControl, proposedProviderName, proposedProviderContactDetails);
            break;
        }
        case ZCL_REQUEST_NEW_PASSWORD_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;          // Ver.: always
            uint32_t implementationDateTime; // Ver.: always
            uint16_t durationInMinutes;      // Ver.: always
            uint8_t passwordType;            // Ver.: always
            uint8_t * password;              // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            implementationDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            durationInMinutes = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            passwordType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            password   = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDeviceManagementClusterRequestNewPasswordResponseCallback(
                issuerEventId, implementationDateTime, durationInMinutes, passwordType, password);
            break;
        }
        case ZCL_UPDATE_SITE_ID_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId; // Ver.: always
            uint32_t siteIdTime;    // Ver.: always
            uint32_t providerId;    // Ver.: always
            uint8_t * siteId;       // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            siteIdTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            siteId     = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDeviceManagementClusterUpdateSiteIdCallback(issuerEventId, siteIdTime, providerId, siteId);
            break;
        }
        case ZCL_SET_EVENT_CONFIGURATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;              // Ver.: always
            uint32_t startDateTime;              // Ver.: always
            uint8_t eventConfiguration;          // Ver.: always
            uint8_t configurationControl;        // Ver.: always
            uint8_t * eventConfigurationPayload; // Ver.: always
            // Command is fixed length: 10
            if (cmd->bufLen < payloadOffset + 10u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            startDateTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            eventConfiguration = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            configurationControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventConfigurationPayload = cmd->buffer + payloadOffset;
            wasHandled                = emberAfDeviceManagementClusterSetEventConfigurationCallback(
                issuerEventId, startDateTime, eventConfiguration, configurationControl, eventConfigurationPayload);
            break;
        }
        case ZCL_GET_EVENT_CONFIGURATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t eventId; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventId    = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfDeviceManagementClusterGetEventConfigurationCallback(eventId);
            break;
        }
        case ZCL_UPDATE_C_I_N_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint32_t issuerEventId;      // Ver.: always
            uint32_t implementationTime; // Ver.: always
            uint32_t providerId;         // Ver.: always
            uint8_t * customerIdNumber;  // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            issuerEventId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            implementationTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            providerId = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            customerIdNumber = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfDeviceManagementClusterUpdateCINCallback(issuerEventId, implementationTime, providerId, customerIdNumber);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Device Management, server
EmberAfStatus emberAfDeviceManagementClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_CHANGE_OF_TENANCY_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfDeviceManagementClusterGetChangeOfTenancyCallback();
            break;
        }
        case ZCL_GET_CHANGE_OF_SUPPLIER_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfDeviceManagementClusterGetChangeOfSupplierCallback();
            break;
        }
        case ZCL_REQUEST_NEW_PASSWORD_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t passwordType; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            passwordType = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled   = emberAfDeviceManagementClusterRequestNewPasswordCallback(passwordType);
            break;
        }
        case ZCL_GET_SITE_ID_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfDeviceManagementClusterGetSiteIdCallback();
            break;
        }
        case ZCL_REPORT_EVENT_CONFIGURATION_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t commandIndex;                // Ver.: always
            uint8_t totalCommands;               // Ver.: always
            uint8_t * eventConfigurationPayload; // Ver.: always
            // Command is fixed length: 2
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventConfigurationPayload = cmd->buffer + payloadOffset;
            wasHandled                = emberAfDeviceManagementClusterReportEventConfigurationCallback(commandIndex, totalCommands,
                                                                                        eventConfigurationPayload);
            break;
        }
        case ZCL_GET_C_I_N_COMMAND_ID: {
            // Command is fixed length: 0
            wasHandled = emberAfDeviceManagementClusterGetCINCallback();
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Events, client
EmberAfStatus emberAfEventsClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_PUBLISH_EVENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t logId;        // Ver.: always
            uint16_t eventId;     // Ver.: always
            uint32_t eventTime;   // Ver.: always
            uint8_t eventControl; // Ver.: always
            uint8_t * eventData;  // Ver.: always
            // Command is not a fixed length
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            logId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + 2u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            if (cmd->bufLen < payloadOffset + emberAfStringLength(cmd->buffer + payloadOffset) + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventData  = emberAfGetString(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfEventsClusterPublishEventCallback(logId, eventId, eventTime, eventControl, eventData);
            break;
        }
        case ZCL_PUBLISH_EVENT_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t totalNumberOfEvents; // Ver.: always
            uint8_t commandIndex;         // Ver.: always
            uint8_t totalCommands;        // Ver.: always
            uint8_t logPayloadControl;    // Ver.: always
            uint8_t * logPayload;         // Ver.: always
            // Command is fixed length: 5
            if (cmd->bufLen < payloadOffset + 5u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            totalNumberOfEvents = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            commandIndex = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            totalCommands = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            logPayloadControl = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            logPayload = cmd->buffer + payloadOffset;
            wasHandled = emberAfEventsClusterPublishEventLogCallback(totalNumberOfEvents, commandIndex, totalCommands,
                                                                     logPayloadControl, logPayload);
            break;
        }
        case ZCL_CLEAR_EVENT_LOG_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t clearedEventsLogs; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            clearedEventsLogs = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled        = emberAfEventsClusterClearEventLogResponseCallback(clearedEventsLogs);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Events, server
EmberAfStatus emberAfEventsClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_GET_EVENT_LOG_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t eventControlLogId; // Ver.: always
            uint16_t eventId;          // Ver.: always
            uint32_t startTime;        // Ver.: always
            uint32_t endTime;          // Ver.: always
            uint8_t numberOfEvents;    // Ver.: always
            uint16_t eventOffset;      // Ver.: always
            // Command is fixed length: 14
            if (cmd->bufLen < payloadOffset + 14u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            eventControlLogId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            startTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            endTime = emberAfGetInt32u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 4u;
            numberOfEvents = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            eventOffset = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled  = emberAfEventsClusterGetEventLogCallback(eventControlLogId, eventId, startTime, endTime, numberOfEvents,
                                                                 eventOffset);
            break;
        }
        case ZCL_CLEAR_EVENT_LOG_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t logId; // Ver.: always
            // Command is fixed length: 1
            if (cmd->bufLen < payloadOffset + 1u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            logId      = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled = emberAfEventsClusterClearEventLogRequestCallback(logId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Key Establishment, client
EmberAfStatus emberAfKeyEstablishmentClusterClientCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_TERMINATE_KEY_ESTABLISHMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t statusCode;             // Ver.: always
            uint8_t waitTime;               // Ver.: always
            uint16_t keyEstablishmentSuite; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            statusCode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            waitTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfKeyEstablishmentClusterTerminateKeyEstablishmentCallback(statusCode, waitTime, keyEstablishmentSuite);
            break;
        }
        case ZCL_INITIATE_KEY_ESTABLISHMENT_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t requestedKeyEstablishmentSuite; // Ver.: always
            uint8_t ephemeralDataGenerateTime;       // Ver.: always
            uint8_t confirmKeyGenerateTime;          // Ver.: always
            uint8_t * identity;                      // Ver.: always
            // Command is fixed length: 52
            if (cmd->bufLen < payloadOffset + 52u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            requestedKeyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            ephemeralDataGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            confirmKeyGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            identity   = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterInitiateKeyEstablishmentResponseCallback(
                requestedKeyEstablishmentSuite, ephemeralDataGenerateTime, confirmKeyGenerateTime, identity);
            break;
        }
        case ZCL_EPHEMERAL_DATA_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * ephemeralData; // Ver.: always
            // Command is fixed length: 22
            if (cmd->bufLen < payloadOffset + 22u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            ephemeralData = cmd->buffer + payloadOffset;
            wasHandled    = emberAfKeyEstablishmentClusterEphemeralDataResponseCallback(ephemeralData);
            break;
        }
        case ZCL_CONFIRM_KEY_DATA_RESPONSE_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * secureMessageAuthenticationCode; // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            secureMessageAuthenticationCode = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterConfirmKeyDataResponseCallback(secureMessageAuthenticationCode);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}

// Cluster: Key Establishment, server
EmberAfStatus emberAfKeyEstablishmentClusterServerCommandParse(EmberAfClusterCommand * cmd)
{
    bool wasHandled = false;
    if (!cmd->mfgSpecific)
    {
        switch (cmd->commandId)
        {
        case ZCL_INITIATE_KEY_ESTABLISHMENT_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint16_t keyEstablishmentSuite;    // Ver.: always
            uint8_t ephemeralDataGenerateTime; // Ver.: always
            uint8_t confirmKeyGenerateTime;    // Ver.: always
            uint8_t * identity;                // Ver.: always
            // Command is fixed length: 52
            if (cmd->bufLen < payloadOffset + 52u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 2u;
            ephemeralDataGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            confirmKeyGenerateTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            identity   = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterInitiateKeyEstablishmentRequestCallback(
                keyEstablishmentSuite, ephemeralDataGenerateTime, confirmKeyGenerateTime, identity);
            break;
        }
        case ZCL_EPHEMERAL_DATA_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * ephemeralData; // Ver.: always
            // Command is fixed length: 22
            if (cmd->bufLen < payloadOffset + 22u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            ephemeralData = cmd->buffer + payloadOffset;
            wasHandled    = emberAfKeyEstablishmentClusterEphemeralDataRequestCallback(ephemeralData);
            break;
        }
        case ZCL_CONFIRM_KEY_DATA_REQUEST_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t * secureMessageAuthenticationCode; // Ver.: always
            // Command is fixed length: 16
            if (cmd->bufLen < payloadOffset + 16u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            secureMessageAuthenticationCode = cmd->buffer + payloadOffset;
            wasHandled = emberAfKeyEstablishmentClusterConfirmKeyDataRequestCallback(secureMessageAuthenticationCode);
            break;
        }
        case ZCL_TERMINATE_KEY_ESTABLISHMENT_COMMAND_ID: {
            uint16_t payloadOffset = cmd->payloadStartIndex;
            uint8_t statusCode;             // Ver.: always
            uint8_t waitTime;               // Ver.: always
            uint16_t keyEstablishmentSuite; // Ver.: always
            // Command is fixed length: 4
            if (cmd->bufLen < payloadOffset + 4u)
            {
                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
            }
            statusCode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            waitTime = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
            payloadOffset += 1u;
            keyEstablishmentSuite = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
            wasHandled =
                emberAfKeyEstablishmentClusterTerminateKeyEstablishmentCallback(statusCode, waitTime, keyEstablishmentSuite);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            break;
        }
        }
    }
    return status(wasHandled, true, cmd->mfgSpecific);
}
