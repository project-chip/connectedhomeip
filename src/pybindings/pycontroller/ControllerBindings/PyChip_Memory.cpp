#include <credentials/CHIPCert.h>
#include <credentials/CHIPOperationalCredentials.h>
#include <crypto/CHIPCryptoPAL.h>
#include <messaging/ExchangeACL.h>
#include <support/CHIPMem.h>
#include <support/Span.h>
#include <transport/AdminPairingTable.h>

#include <controller/CHIPDeviceController.h>
#include <functional>
#include <pybind11/pybind11.h>
#include <string>

#ifndef BINDER_PYBIND11_TYPE_CASTER
#define BINDER_PYBIND11_TYPE_CASTER
PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
PYBIND11_DECLARE_HOLDER_TYPE(T, T *)
PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_PyChip_Memory(std::function<pybind11::module &(std::string const & namespace_)> & M)
{
    // chip::Platform::MemoryInit(void *, unsigned long) file:support/CHIPMem.h line:67
    M("chip::Platform")
        .def(
            "MemoryInit", []() -> int { return chip::Platform::MemoryInit(); }, "");
    M("chip::Platform")
        .def(
            "MemoryInit", [](void * a0) -> int { return chip::Platform::MemoryInit(a0); }, "", pybind11::arg("buf"));
    M("chip::Platform")
        .def("MemoryInit", (int (*)(void *, unsigned long)) & chip::Platform::MemoryInit,
             "This function is called by CHIP layer to initialize memory and resources\n required for proper functionality of the "
             "CHIP memory allocator.\n This function is platform specific and might be empty in certain cases.\n For example, this "
             "function is doing nothing when the C Standard Library malloc()\n and free() functions are used for memory "
             "allocation.\n\n \n      A pointer to a dedicated memory buffer, which should be used as\n                      a "
             "memory pool for CHIP memory allocation.\n                      This input is optional (defaults to NULL) and "
             "shouldn't be used\n                      if a dedicated memory buffer is not used.\n\n \n  Size of a dedicated "
             "memory buffer. This input is optional (defaults to 0)\n                      and shouldn't be used if dedicated "
             "memory buffer is not used.\n                      When a dedicated memory buffer is used the function checks and\n   "
             "                   generates an error if buffer size is not big enough to support\n                      CHIP use "
             "cases.\n\n   #CHIP_ERROR_BUFFER_TOO_SMALL  If dedicated input buffer size is not sufficient\n                        "
             "                 to support CHIP use cases.\n   #CHIP_NO_ERROR                On success.\n   other                  "
             "        An error generated by platform-specific memory\n                                         initialization "
             "function.\n\n \n\nC++: chip::Platform::MemoryInit(void *, unsigned long) --> int",
             pybind11::arg("buf"), pybind11::arg("bufSize"));

    // chip::Platform::MemoryShutdown() file:support/CHIPMem.h line:77
    M("chip::Platform")
        .def("MemoryShutdown", (void (*)()) & chip::Platform::MemoryShutdown,
             "This function is called by the CHIP layer to releases all resources that were allocated\n by MemoryInit() "
             "function.\n This function can be an empty call if there is no need to release resources. For example,\n this is the "
             "case when the C Standard Library malloc() and free() functions are used\n for memory allocation.\n\n \n\nC++: "
             "chip::Platform::MemoryShutdown() --> void");

    // chip::Platform::MemoryAlloc(unsigned long) file:support/CHIPMem.h line:88
    M("chip::Platform")
        .def("MemoryAlloc", (void * (*) (unsigned long) ) & chip::Platform::MemoryAlloc,
             "This function is called by the CHIP layer to allocate a block of memory of \"size\" bytes.\n\n \n             "
             "Specifies requested memory size in bytes.\n\n   Pointer to a memory block in case of success.\n   NULL-pointer if "
             "memory allocation fails.\n\n \n\nC++: chip::Platform::MemoryAlloc(unsigned long) --> void *",
             pybind11::return_value_policy::automatic, pybind11::arg("size"));

    // chip::Platform::MemoryCalloc(unsigned long, unsigned long) file:support/CHIPMem.h line:102
    M("chip::Platform")
        .def(
            "MemoryCalloc", (void * (*) (unsigned long, unsigned long) ) & chip::Platform::MemoryCalloc,
            "This function is called by the CHIP layer to allocate a block of memory for an array of num\n elements, each of them "
            "size bytes long, and initializes all its bits to zero.\n The effective result is the allocation of a zero-initialized "
            "memory block of (num*size) bytes.\n\n \n              Specifies number of elements to allocate.\n \n\n             "
            "Specifies size of each element in bytes.\n\n   Pointer to a memory block in case of success.\n   NULL-pointer if "
            "memory allocation fails.\n\n \n\nC++: chip::Platform::MemoryCalloc(unsigned long, unsigned long) --> void *",
            pybind11::return_value_policy::automatic, pybind11::arg("num"), pybind11::arg("size"));

    // chip::Platform::MemoryRealloc(void *, unsigned long) file:support/CHIPMem.h line:122
    M("chip::Platform")
        .def("MemoryRealloc", (void * (*) (void *, unsigned long) ) & chip::Platform::MemoryRealloc,
             "This function is called by the Chip layer to change the size of the memory block pointed to by p.\n The function may "
             "move the memory block to a new location (whose address is returned by the function).\n The content of the memory "
             "block is preserved up to the lesser of the new and old sizes, even if the\n block is moved to a new location. If the "
             "new size is larger, the value of the newly allocated portion\n is indeterminate.\n\n In case that p is a null "
             "pointer, the function behaves like malloc, assigning a new block of size bytes\n and returning a pointer to its "
             "beginning.\n\n \n                Pointer to a memory block previously allocated with MemoryAlloc, MemoryCalloc\n     "
             "                         or MemoryRealloc.\n \n\n             Specifies new size for the memory block, in "
             "bytes..\n\n   Pointer to a memory block in case of success.\n   NULL-pointer if memory allocation fails.\n\n "
             "\n\nC++: chip::Platform::MemoryRealloc(void *, unsigned long) --> void *",
             pybind11::return_value_policy::automatic, pybind11::arg("p"), pybind11::arg("size"));

    // chip::Platform::MemoryFree(void *) file:support/CHIPMem.h line:130
    M("chip::Platform")
        .def("MemoryFree", (void (*)(void *)) & chip::Platform::MemoryFree,
             "This function is called by the Chip layer to release a memory block allocated by\n the MemoryAlloc(), MemoryCalloc "
             "or MemoryRealloc.\n \n\n                Pointer to a memory block that should be released.\n\n \n\nC++: "
             "chip::Platform::MemoryFree(void *) --> void",
             pybind11::arg("p"));

    // chip::Platform::MemoryInternalCheckPointer(const void *, unsigned long) file:support/CHIPMem.h line:167
    M("chip::Platform")
        .def("MemoryInternalCheckPointer", (bool (*)(const void *, unsigned long)) & chip::Platform::MemoryInternalCheckPointer,
             "C++: chip::Platform::MemoryInternalCheckPointer(const void *, unsigned long) --> bool", pybind11::arg("p"),
             pybind11::arg("min_size"));

    // chip::Platform::MemoryDebugCheckPointer(const void *, unsigned long) file:support/CHIPMem.h line:195
    M("chip::Platform")
        .def(
            "MemoryDebugCheckPointer", [](const void * a0) -> bool { return chip::Platform::MemoryDebugCheckPointer(a0); }, "",
            pybind11::arg("p"));
    M("chip::Platform")
        .def(
            "MemoryDebugCheckPointer", (bool (*)(const void *, unsigned long)) & chip::Platform::MemoryDebugCheckPointer,
            "In debug builds, test the validity of a pointer obtained from a chip::Platform memory allocation.\n\n \n              "
            "  Pointer to a memory block previously allocated with MemoryAlloc, MemoryCalloc,\n                              "
            "MemoryRealloc, or New, and not freed.\n \n\n         Gives a size that the allocated block is expected to be able to "
            "hold.\n\n  configured with #CHIP_CONFIG_MEMORY_DEBUG_CHECKS, this function returns `true` without performing\n any "
            "check, inlined with the expectation that the compiler can remove any associated failure code.\n\n With "
            "#CHIP_CONFIG_MEMORY_DEBUG_CHECKS enabled:\n\n This function is guaranteed to return `false` if  is `nullptr`. The "
            "function returns `true` if  is a valid\n pointer to an allocation *and* the implementation memory manager is in a "
            "fully functioning state.\n\n \n For non-null  the function *may* return `true` even if the pointer is invalid. That "
            "is, a particular\n       implementation or configuration is not guaranteed to catch any particular faulty state.\n "
            "\n\n For non-null  the function return value *may* be incorrect if the memory manager is in a faulty state\n       "
            "(e.g. corrupt heap), even if the faulty state does not directly involve \n \n\n For non-null  the function *may* "
            "abort the program rather than return at all if the memory manager is in\n       a faulty state, even if  is valid.\n "
            "\n\n For a non-null  checking *may* be slow.\n\n \n  An implementation- and configuration-defined estimate of whether "
            " is a valid allocated pointer.\n\nC++: chip::Platform::MemoryDebugCheckPointer(const void *, unsigned long) --> bool",
            pybind11::arg("p"), pybind11::arg("min_size"));
}
