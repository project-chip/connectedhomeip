/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <cstdint>
#include <string>
#include <type_traits>

#include <app-common/zap-generated/cluster-objects.h>
#include <app/data-model/DecodableList.h>
#include <app/data-model/Nullable.h>
#include <commands/clusters/ModelCommand.h>
#include <commands/common/CommandInvoker.h>
#include <lib/core/CHIPSafeCasts.h>
#include <lib/support/BytesToHex.h>
#include <lib/support/Span.h>
#include <lib/support/TypeTraits.h>
#include <zap-generated/CHIPClientCallbacks.h>
#include <zap-generated/CHIPClusters.h>

// Value logging functions.  The non-generated ones depend on the
// generated ones, so are placed here.
namespace {

CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Scenes::Structs::SceneExtensionFieldSet::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::PowerProfileRecord::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::ScheduledPhase::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::TransferredPhase::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::NetworkCommissioning::Structs::ThreadInterfaceScanResult::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::NetworkCommissioning::Structs::WiFiInterfaceScanResult::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::SoftwareDiagnostics::Structs::SoftwareFault::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType & value);
CHIP_ERROR
LogValue(const char * label, size_t indent,
         const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ModeSelect::Structs::SemanticTag::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::IasAce::Structs::IasAceZoneStatusResult::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TvChannel::Structs::TvChannelLineupInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::MediaPlayback::Structs::MediaPlaybackPosition::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentLaunchAdditionalInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentLaunchParamater::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentLaunchBrandingInformation::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentLaunchDimension::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentLaunchStyleInformation::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ApplicationLauncher::Structs::ApplicationLauncherApp::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NestedStruct::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NestedStructList::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::DoubleNestedStructList::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType & value);
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GroupKeyManagement::Structs::GroupState::DecodableType & value);

#if CHIP_PROGRESS_LOGGING
std::string IndentStr(size_t indent)
{
    std::string str;
    for (size_t i = 0; i < indent; ++i)
    {
        str.append("  ");
    }
    return str;
}
#endif // CHIP_PROGRESS_LOGGING

template <typename X,
          typename std::enable_if_t<
              std::is_integral<X>::value && !std::is_same<std::remove_cv_t<std::remove_reference_t<X>>, bool>::value, int> = 0>
CHIP_ERROR LogValue(const char * label, size_t indent, X value)
{
    ChipLogProgress(chipTool, "%s%s: %s", IndentStr(indent).c_str(), label, std::to_string(value).c_str());
    return CHIP_NO_ERROR;
}

CHIP_ERROR LogValue(const char * label, size_t indent, bool value)
{
    ChipLogProgress(chipTool, "%s%s: %s", IndentStr(indent).c_str(), label, value ? "TRUE" : "FALSE");
    return CHIP_NO_ERROR;
}

template <typename X, typename std::enable_if_t<std::is_enum<X>::value, int> = 0>
CHIP_ERROR LogValue(const char * label, size_t indent, X value)
{
    return LogValue(label, indent, chip::to_underlying(value));
}

CHIP_ERROR LogValue(const char * label, size_t indent, chip::CharSpan value)
{
    ChipLogProgress(chipTool, "%s%s: %.*s", IndentStr(indent).c_str(), label, static_cast<int>(value.size()), value.data());
    return CHIP_NO_ERROR;
}

CHIP_ERROR LogValue(const char * label, size_t indent, chip::ByteSpan value)
{
    ChipLogProgress(chipTool, "%s%s: %zu", IndentStr(indent).c_str(), label, value.size());
    return CHIP_NO_ERROR;
}

template <typename X>
CHIP_ERROR LogValue(const char * label, size_t indent, chip::BitFlags<X> value)
{
    return LogValue(label, indent, value.Raw());
}

template <typename T>
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::DataModel::DecodableList<T> & value)
{
    size_t count   = 0;
    CHIP_ERROR err = value.ComputeSize(&count);
    if (err != CHIP_NO_ERROR)
    {
        return err;
    }
    ChipLogProgress(chipTool, "%s%s: %zu entries", IndentStr(indent).c_str(), label, count);

    auto iter = value.begin();
    size_t i  = 0;
    while (iter.Next())
    {
        ++i;
        std::string itemLabel = std::string("[") + std::to_string(i) + "]";
        ReturnErrorOnFailure(LogValue(itemLabel.c_str(), indent + 1, iter.GetValue()));
    }
    if (iter.GetStatus() != CHIP_NO_ERROR)
    {
        ChipLogProgress(chipTool, "%sList truncated due to invalid value", IndentStr(indent + 1).c_str());
    }
    return iter.GetStatus();
}

template <typename T>
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::app::DataModel::Nullable<T> & value)
{
    if (!value.IsNull())
    {
        return LogValue(label, indent, value.Value());
    }
    ChipLogProgress(chipTool, "%s%s: null", IndentStr(indent).c_str(), label);
    return CHIP_NO_ERROR;
}

template <typename T>
CHIP_ERROR LogValue(const char * label, size_t indent, const chip::Optional<T> & value)
{
    if (value.HasValue())
    {
        return LogValue(label, indent, value.Value());
    }

    return CHIP_NO_ERROR;
}

// We output helpers for all structs here, including ones we might not actually
// be logging.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Scenes::Structs::SceneExtensionFieldSet::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ClusterId", indent + 1, value.clusterId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ClusterId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Length", indent + 1, value.length);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Length'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Value", indent + 1, value.value);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Value'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::PowerProfileRecord::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("PowerProfileId", indent + 1, value.powerProfileId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PowerProfileId'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("EnergyPhaseId", indent + 1, value.energyPhaseId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EnergyPhaseId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PowerProfileRemoteControl", indent + 1, value.powerProfileRemoteControl);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PowerProfileRemoteControl'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PowerProfileState", indent + 1, value.powerProfileState);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PowerProfileState'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::ScheduledPhase::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("EnergyPhaseId", indent + 1, value.energyPhaseId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EnergyPhaseId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ScheduledTime", indent + 1, value.scheduledTime);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ScheduledTime'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::PowerProfile::Structs::TransferredPhase::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("EnergyPhaseId", indent + 1, value.energyPhaseId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EnergyPhaseId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MacroPhaseId", indent + 1, value.macroPhaseId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MacroPhaseId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ExpectedDuration", indent + 1, value.expectedDuration);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExpectedDuration'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PeakPower", indent + 1, value.peakPower);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PeakPower'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Energy", indent + 1, value.energy);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Energy'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MaxActivationDelay", indent + 1, value.maxActivationDelay);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MaxActivationDelay'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Type", indent + 1, value.type);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Type'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Revision", indent + 1, value.revision);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Revision'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ActionID", indent + 1, value.actionID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ActionID'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Type", indent + 1, value.type);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Type'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("EndpointListID", indent + 1, value.endpointListID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EndpointListID'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("SupportedCommands", indent + 1, value.supportedCommands);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'SupportedCommands'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Status", indent + 1, value.status);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Status'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("EndpointListID", indent + 1, value.endpointListID);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'EndpointListID'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Type", indent + 1, value.type);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Type'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Endpoints", indent + 1, value.endpoints);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Endpoints'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FailSafeExpiryLengthMs", indent + 1, value.failSafeExpiryLengthMs);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FailSafeExpiryLengthMs'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::NetworkCommissioning::Structs::ThreadInterfaceScanResult::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("DiscoveryResponse", indent + 1, value.discoveryResponse);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'DiscoveryResponse'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::NetworkCommissioning::Structs::WiFiInterfaceScanResult::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Security", indent + 1, value.security);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Security'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Ssid", indent + 1, value.ssid);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Ssid'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Bssid", indent + 1, value.bssid);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Bssid'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Channel", indent + 1, value.channel);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Channel'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FrequencyBand", indent + 1, value.frequencyBand);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FrequencyBand'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FabricConnected", indent + 1, value.fabricConnected);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricConnected'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OffPremiseServicesReachableIPv4", indent + 1, value.offPremiseServicesReachableIPv4);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OffPremiseServicesReachableIPv4'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OffPremiseServicesReachableIPv6", indent + 1, value.offPremiseServicesReachableIPv6);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OffPremiseServicesReachableIPv6'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("HardwareAddress", indent + 1, value.hardwareAddress);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'HardwareAddress'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Type", indent + 1, value.type);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Type'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::SoftwareDiagnostics::Structs::SoftwareFault::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Id", indent + 1, value.id);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Id'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FaultRecording", indent + 1, value.faultRecording);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FaultRecording'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Id", indent + 1, value.id);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Id'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("StackFreeCurrent", indent + 1, value.stackFreeCurrent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'StackFreeCurrent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("StackFreeMinimum", indent + 1, value.stackFreeMinimum);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'StackFreeMinimum'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("StackSize", indent + 1, value.stackSize);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'StackSize'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ExtAddress", indent + 1, value.extAddress);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExtAddress'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Age", indent + 1, value.age);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Age'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Rloc16", indent + 1, value.rloc16);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Rloc16'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LinkFrameCounter", indent + 1, value.linkFrameCounter);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LinkFrameCounter'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MleFrameCounter", indent + 1, value.mleFrameCounter);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MleFrameCounter'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Lqi", indent + 1, value.lqi);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Lqi'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("AverageRssi", indent + 1, value.averageRssi);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'AverageRssi'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LastRssi", indent + 1, value.lastRssi);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LastRssi'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FrameErrorRate", indent + 1, value.frameErrorRate);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FrameErrorRate'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MessageErrorRate", indent + 1, value.messageErrorRate);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MessageErrorRate'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("RxOnWhenIdle", indent + 1, value.rxOnWhenIdle);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'RxOnWhenIdle'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FullThreadDevice", indent + 1, value.fullThreadDevice);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FullThreadDevice'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FullNetworkData", indent + 1, value.fullNetworkData);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FullNetworkData'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("IsChild", indent + 1, value.isChild);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'IsChild'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR
LogValue(const char * label, size_t indent,
         const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ActiveTimestampPresent", indent + 1, value.activeTimestampPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ActiveTimestampPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PendingTimestampPresent", indent + 1, value.pendingTimestampPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PendingTimestampPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MasterKeyPresent", indent + 1, value.masterKeyPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MasterKeyPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NetworkNamePresent", indent + 1, value.networkNamePresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NetworkNamePresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ExtendedPanIdPresent", indent + 1, value.extendedPanIdPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExtendedPanIdPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MeshLocalPrefixPresent", indent + 1, value.meshLocalPrefixPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MeshLocalPrefixPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("DelayPresent", indent + 1, value.delayPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'DelayPresent'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PanIdPresent", indent + 1, value.panIdPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PanIdPresent'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ChannelPresent", indent + 1, value.channelPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ChannelPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PskcPresent", indent + 1, value.pskcPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PskcPresent'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("SecurityPolicyPresent", indent + 1, value.securityPolicyPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'SecurityPolicyPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ChannelMaskPresent", indent + 1, value.channelMaskPresent);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ChannelMaskPresent'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ExtAddress", indent + 1, value.extAddress);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExtAddress'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Rloc16", indent + 1, value.rloc16);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Rloc16'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("RouterId", indent + 1, value.routerId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'RouterId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NextHop", indent + 1, value.nextHop);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NextHop'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PathCost", indent + 1, value.pathCost);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PathCost'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LQIIn", indent + 1, value.LQIIn);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LQIIn'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LQIOut", indent + 1, value.LQIOut);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LQIOut'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Age", indent + 1, value.age);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Age'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Allocated", indent + 1, value.allocated);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Allocated'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LinkEstablished", indent + 1, value.linkEstablished);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LinkEstablished'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("RotationTime", indent + 1, value.rotationTime);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'RotationTime'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Flags", indent + 1, value.flags);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Flags'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("RootPublicKey", indent + 1, value.rootPublicKey);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'RootPublicKey'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("VendorId", indent + 1, value.vendorId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'VendorId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("FabricId", indent + 1, value.fabricId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NodeId", indent + 1, value.nodeId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NodeId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Label", indent + 1, value.label);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Label'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Noc", indent + 1, value.noc);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Noc'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Label", indent + 1, value.label);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Label'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Value", indent + 1, value.value);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Value'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Label", indent + 1, value.label);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Label'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Mode", indent + 1, value.mode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Mode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("SemanticTag", indent + 1, value.semanticTag);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'SemanticTag'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ModeSelect::Structs::SemanticTag::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("MfgCode", indent + 1, value.mfgCode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MfgCode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Value", indent + 1, value.value);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Value'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::IasAce::Structs::IasAceZoneStatusResult::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ZoneId", indent + 1, value.zoneId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ZoneId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ZoneStatus", indent + 1, value.zoneStatus);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ZoneStatus'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("MajorNumber", indent + 1, value.majorNumber);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MajorNumber'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("MinorNumber", indent + 1, value.minorNumber);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'MinorNumber'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("CallSign", indent + 1, value.callSign);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'CallSign'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("AffiliateCallSign", indent + 1, value.affiliateCallSign);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'AffiliateCallSign'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TvChannel::Structs::TvChannelLineupInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("OperatorName", indent + 1, value.operatorName);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OperatorName'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LineupName", indent + 1, value.lineupName);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LineupName'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("PostalCode", indent + 1, value.postalCode);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'PostalCode'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("LineupInfoType", indent + 1, value.lineupInfoType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'LineupInfoType'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Identifier", indent + 1, value.identifier);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Identifier'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::MediaPlayback::Structs::MediaPlaybackPosition::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("UpdatedAt", indent + 1, value.updatedAt);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'UpdatedAt'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Position", indent + 1, value.position);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Position'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Index", indent + 1, value.index);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Index'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("InputType", indent + 1, value.inputType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'InputType'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Description", indent + 1, value.description);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Description'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentLaunchAdditionalInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Value", indent + 1, value.value);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Value'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentLaunchParamater::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Type", indent + 1, value.type);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Type'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Value", indent + 1, value.value);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Value'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ExternalIDList", indent + 1, value.externalIDList);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ExternalIDList'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentLaunchBrandingInformation::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ProviderName", indent + 1, value.providerName);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ProviderName'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Background", indent + 1, value.background);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Background'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Logo", indent + 1, value.logo);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Logo'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ProgressBar", indent + 1, value.progressBar);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ProgressBar'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Splash", indent + 1, value.splash);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Splash'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("WaterMark", indent + 1, value.waterMark);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'WaterMark'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentLaunchDimension::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Width", indent + 1, value.width);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Width'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Height", indent + 1, value.height);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Height'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Metric", indent + 1, value.metric);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Metric'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ContentLauncher::Structs::ContentLaunchStyleInformation::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("ImageUrl", indent + 1, value.imageUrl);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ImageUrl'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Color", indent + 1, value.color);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Color'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Size", indent + 1, value.size);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Size'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("Index", indent + 1, value.index);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Index'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OutputType", indent + 1, value.outputType);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OutputType'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("Name", indent + 1, value.name);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'Name'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::ApplicationLauncher::Structs::ApplicationLauncherApp::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("CatalogVendorId", indent + 1, value.catalogVendorId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'CatalogVendorId'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("ApplicationId", indent + 1, value.applicationId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'ApplicationId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("A", indent + 1, value.a);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'A'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("B", indent + 1, value.b);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'B'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("C", indent + 1, value.c);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'C'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("D", indent + 1, value.d);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'D'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("E", indent + 1, value.e);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'E'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("F", indent + 1, value.f);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'F'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("NullableInt", indent + 1, value.nullableInt);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableInt'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OptionalInt", indent + 1, value.optionalInt);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OptionalInt'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableOptionalInt", indent + 1, value.nullableOptionalInt);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableOptionalInt'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableString", indent + 1, value.nullableString);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableString'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OptionalString", indent + 1, value.optionalString);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OptionalString'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableOptionalString", indent + 1, value.nullableOptionalString);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableOptionalString'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableStruct", indent + 1, value.nullableStruct);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableStruct'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OptionalStruct", indent + 1, value.optionalStruct);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OptionalStruct'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableOptionalStruct", indent + 1, value.nullableOptionalStruct);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableOptionalStruct'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableList", indent + 1, value.nullableList);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableList'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OptionalList", indent + 1, value.optionalList);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OptionalList'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("NullableOptionalList", indent + 1, value.nullableOptionalList);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'NullableOptionalList'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NestedStruct::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("A", indent + 1, value.a);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'A'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("B", indent + 1, value.b);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'B'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("C", indent + 1, value.c);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'C'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::NestedStructList::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("A", indent + 1, value.a);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'A'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("B", indent + 1, value.b);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'B'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("C", indent + 1, value.c);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'C'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("D", indent + 1, value.d);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'D'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("E", indent + 1, value.e);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'E'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("F", indent + 1, value.f);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'F'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("G", indent + 1, value.g);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'G'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::DoubleNestedStructList::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("A", indent + 1, value.a);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'A'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("FabricIndex", indent + 1, value.fabricIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'FabricIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("OperationalCert", indent + 1, value.operationalCert);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'OperationalCert'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("VendorId", indent + 1, value.vendorId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'VendorId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("GroupKeyIndex", indent + 1, value.groupKeyIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'GroupKeyIndex'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("GroupKeyRoot", indent + 1, value.groupKeyRoot);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'GroupKeyRoot'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("GroupKeyEpochStartTime", indent + 1, value.groupKeyEpochStartTime);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'GroupKeyEpochStartTime'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("GroupKeySecurityPolicy", indent + 1, value.groupKeySecurityPolicy);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'GroupKeySecurityPolicy'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
CHIP_ERROR LogValue(const char * label, size_t indent,
                    const chip::app::Clusters::GroupKeyManagement::Structs::GroupState::DecodableType & value)
{
    ChipLogProgress(chipTool, "%s%s: {", IndentStr(indent).c_str(), label);
    {
        CHIP_ERROR err = LogValue("VendorId", indent + 1, value.vendorId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'VendorId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("VendorGroupId", indent + 1, value.vendorGroupId);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'VendorGroupId'", IndentStr(indent + 1).c_str());
            return err;
        }
    }
    {
        CHIP_ERROR err = LogValue("GroupKeySetIndex", indent + 1, value.groupKeySetIndex);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogProgress(chipTool, "%sStruct truncated due to invalid value for 'GroupKeySetIndex'",
                            IndentStr(indent + 1).c_str());
            return err;
        }
    }
    ChipLogProgress(chipTool, "%s}", IndentStr(indent).c_str());
    return CHIP_NO_ERROR;
}
#pragma GCC diagnostic pop

} // anonymous namespace

static void OnDefaultSuccessResponseWithoutExit(void * context)
{
    ChipLogProgress(chipTool, "Default Success Response");
}

static void OnDefaultSuccessResponse(void * context)
{
    ChipLogProgress(chipTool, "Default Success Response");

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnDefaultFailureResponse(void * context, uint8_t status)
{
    ChipLogProgress(chipTool, "Default Failure Response: 0x%02x", status);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_ERROR_INTERNAL);
}

static void OnDefaultSuccess(void * context, const chip::app::DataModel::NullObjectType & data)
{
    OnDefaultSuccessResponse(context);
};

static void OnDefaultFailure(void * context, EmberAfStatus status)
{
    OnDefaultFailureResponse(context, status);
};

static void OnBooleanAttributeReport(void * context, bool value)
{
    ChipLogProgress(chipTool, "Boolean attribute Response: %d", value);
}

static void OnBooleanAttributeResponse(void * context, bool value)
{
    OnBooleanAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnInt8uAttributeReport(void * context, uint8_t value)
{
    ChipLogProgress(chipTool, "Int8u attribute Response: %" PRIu8, value);
}

static void OnInt8uAttributeResponse(void * context, uint8_t value)
{
    OnInt8uAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnInt16uAttributeReport(void * context, uint16_t value)
{
    ChipLogProgress(chipTool, "Int16u attribute Response: %" PRIu16, value);
}

static void OnInt16uAttributeResponse(void * context, uint16_t value)
{
    OnInt16uAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnInt32uAttributeReport(void * context, uint32_t value)
{
    ChipLogProgress(chipTool, "Int32u attribute Response: %" PRIu32, value);
}

static void OnInt32uAttributeResponse(void * context, uint32_t value)
{
    OnInt32uAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnInt64uAttributeReport(void * context, uint64_t value)
{
    ChipLogProgress(chipTool, "Int64u attribute Response: %" PRIu64, value);
}

static void OnInt64uAttributeResponse(void * context, uint64_t value)
{
    OnInt64uAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnInt8sAttributeReport(void * context, int8_t value)
{
    ChipLogProgress(chipTool, "Int8s attribute Response: %" PRId8, value);
}

static void OnInt8sAttributeResponse(void * context, int8_t value)
{
    OnInt8sAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnInt16sAttributeReport(void * context, int16_t value)
{
    ChipLogProgress(chipTool, "Int16s attribute Response: %" PRId16, value);
}

static void OnInt16sAttributeResponse(void * context, int16_t value)
{
    OnInt16sAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnInt32sAttributeReport(void * context, int32_t value)
{
    ChipLogProgress(chipTool, "Int32s attribute Response: %" PRId32, value);
}

static void OnInt32sAttributeResponse(void * context, int32_t value)
{
    OnInt32sAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnInt64sAttributeReport(void * context, int64_t value)
{
    ChipLogProgress(chipTool, "Int64s attribute Response: %" PRId64, value);
}

static void OnInt64sAttributeResponse(void * context, int64_t value)
{
    OnInt64sAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnOctetStringAttributeReport(void * context, const chip::ByteSpan value)
{
    char buffer[CHIP_CONFIG_LOG_MESSAGE_MAX_SIZE];
    if (CHIP_NO_ERROR ==
        chip::Encoding::BytesToUppercaseHexString(value.data(), value.size(), &buffer[0], CHIP_CONFIG_LOG_MESSAGE_MAX_SIZE))
    {
        ChipLogProgress(chipTool, "OctetString attribute Response: %s", buffer);
    }
    else
    {
        ChipLogProgress(chipTool, "OctetString attribute Response len: %zu", value.size());
    }
}

static void OnOctetStringAttributeResponse(void * context, const chip::ByteSpan value)
{
    OnOctetStringAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void OnCharStringAttributeReport(void * context, const chip::CharSpan value)
{
    ChipLogProgress(chipTool, "CharString attribute Response: %.*s", static_cast<int>(value.size()), value.data());
}

static void OnCharStringAttributeResponse(void * context, const chip::CharSpan value)
{
    OnCharStringAttributeReport(context, value);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(CHIP_NO_ERROR);
}

static void
OnApplicationLauncherApplicationLauncherListListAttributeResponse(void * context,
                                                                  const chip::app::DataModel::DecodableList<uint16_t> & list)
{
    CHIP_ERROR err = LogValue("OnApplicationLauncherApplicationLauncherListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnAudioOutputAudioOutputListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnAudioOutputAudioOutputListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnBridgedActionsActionListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnBridgedActionsActionListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnBridgedActionsEndpointListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType> &
        list)
{
    CHIP_ERROR err = LogValue("OnBridgedActionsEndpointListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void
OnContentLauncherAcceptsHeaderListListAttributeResponse(void * context,
                                                        const chip::app::DataModel::DecodableList<chip::ByteSpan> & list)
{
    CHIP_ERROR err = LogValue("OnContentLauncherAcceptsHeaderListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnContentLauncherSupportedStreamingTypesListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::ContentLauncher::ContentLaunchStreamingType> & list)
{
    CHIP_ERROR err = LogValue("OnContentLauncherSupportedStreamingTypesListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnDescriptorDeviceListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnDescriptorDeviceListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnDescriptorServerListListAttributeResponse(void * context,
                                                        const chip::app::DataModel::DecodableList<chip::ClusterId> & list)
{
    CHIP_ERROR err = LogValue("OnDescriptorServerListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnDescriptorClientListListAttributeResponse(void * context,
                                                        const chip::app::DataModel::DecodableList<chip::ClusterId> & list)
{
    CHIP_ERROR err = LogValue("OnDescriptorClientListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnDescriptorPartsListListAttributeResponse(void * context,
                                                       const chip::app::DataModel::DecodableList<chip::EndpointId> & list)
{
    CHIP_ERROR err = LogValue("OnDescriptorPartsListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnFixedLabelLabelListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnFixedLabelLabelListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnGeneralCommissioningBasicCommissioningInfoListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnGeneralCommissioningBasicCommissioningInfoListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnGeneralDiagnosticsNetworkInterfacesListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnGeneralDiagnosticsNetworkInterfacesListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnGeneralDiagnosticsActiveHardwareFaultsListAttributeResponse(void * context,
                                                                          const chip::app::DataModel::DecodableList<uint8_t> & list)
{
    CHIP_ERROR err = LogValue("OnGeneralDiagnosticsActiveHardwareFaultsListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnGeneralDiagnosticsActiveRadioFaultsListAttributeResponse(void * context,
                                                                       const chip::app::DataModel::DecodableList<uint8_t> & list)
{
    CHIP_ERROR err = LogValue("OnGeneralDiagnosticsActiveRadioFaultsListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnGeneralDiagnosticsActiveNetworkFaultsListAttributeResponse(void * context,
                                                                         const chip::app::DataModel::DecodableList<uint8_t> & list)
{
    CHIP_ERROR err = LogValue("OnGeneralDiagnosticsActiveNetworkFaultsListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnGroupKeyManagementGroupsListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupState::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnGroupKeyManagementGroupsListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnGroupKeyManagementGroupKeysListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnGroupKeyManagementGroupKeysListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnMediaInputMediaInputListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnMediaInputMediaInputListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnModeSelectSupportedModesListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnModeSelectSupportedModesListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnOperationalCredentialsFabricsListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnOperationalCredentialsFabricsListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnOperationalCredentialsTrustedRootCertificatesListAttributeResponse(
    void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & list)
{
    CHIP_ERROR err = LogValue("OnOperationalCredentialsTrustedRootCertificatesListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnPowerSourceActiveBatteryFaultsListAttributeResponse(void * context,
                                                                  const chip::app::DataModel::DecodableList<uint8_t> & list)
{
    CHIP_ERROR err = LogValue("OnPowerSourceActiveBatteryFaultsListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnSoftwareDiagnosticsThreadMetricsListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType> &
        list)
{
    CHIP_ERROR err = LogValue("OnSoftwareDiagnosticsThreadMetricsListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnTvChannelTvChannelListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnTvChannelTvChannelListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnTargetNavigatorTargetNavigatorListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnTargetNavigatorTargetNavigatorListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnTestClusterListInt8uListAttributeResponse(void * context, const chip::app::DataModel::DecodableList<uint8_t> & list)
{
    CHIP_ERROR err = LogValue("OnTestClusterListInt8uListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnTestClusterListOctetStringListAttributeResponse(void * context,
                                                              const chip::app::DataModel::DecodableList<chip::ByteSpan> & list)
{
    CHIP_ERROR err = LogValue("OnTestClusterListOctetStringListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnTestClusterListStructOctetStringListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnTestClusterListStructOctetStringListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnTestClusterListNullablesAndOptionalsStructListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnTestClusterListNullablesAndOptionalsStructListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnThreadNetworkDiagnosticsNeighborTableListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnThreadNetworkDiagnosticsNeighborTableListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnThreadNetworkDiagnosticsRouteTableListListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType> &
        list)
{
    CHIP_ERROR err = LogValue("OnThreadNetworkDiagnosticsRouteTableListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnThreadNetworkDiagnosticsSecurityPolicyListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnThreadNetworkDiagnosticsSecurityPolicyListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeResponse(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType> & list)
{
    CHIP_ERROR err = LogValue("OnThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeResponse(
    void * context, const chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault> & list)
{
    CHIP_ERROR err = LogValue("OnThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeResponse", 0, list);

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
}

static void OnAccountLoginGetSetupPINResponseSuccess(
    void * context, const chip::app::Clusters::AccountLogin::Commands::GetSetupPINResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetSetupPINResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("setupPIN", 1, data.setupPIN);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnApplicationLauncherLaunchAppResponseSuccess(
    void * context, const chip::app::Clusters::ApplicationLauncher::Commands::LaunchAppResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received LaunchAppResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("data", 1, data.data);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnContentLauncherLaunchContentResponseSuccess(
    void * context, const chip::app::Clusters::ContentLauncher::Commands::LaunchContentResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received LaunchContentResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("data", 1, data.data);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("contentLaunchStatus", 1, data.contentLaunchStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnContentLauncherLaunchURLResponseSuccess(
    void * context, const chip::app::Clusters::ContentLauncher::Commands::LaunchURLResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received LaunchURLResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("data", 1, data.data);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("contentLaunchStatus", 1, data.contentLaunchStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDiagnosticLogsRetrieveLogsResponseSuccess(
    void * context, const chip::app::Clusters::DiagnosticLogs::Commands::RetrieveLogsResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received RetrieveLogsResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("content", 1, data.content);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("timeStamp", 1, data.timeStamp);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("timeSinceBoot", 1, data.timeSinceBoot);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnDoorLockClearAllPinsResponseSuccess(void * context,
                                      const chip::app::Clusters::DoorLock::Commands::ClearAllPinsResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ClearAllPinsResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnDoorLockClearAllRfidsResponseSuccess(void * context,
                                       const chip::app::Clusters::DoorLock::Commands::ClearAllRfidsResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ClearAllRfidsResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockClearHolidayScheduleResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::ClearHolidayScheduleResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ClearHolidayScheduleResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockClearPinResponseSuccess(void * context,
                                              const chip::app::Clusters::DoorLock::Commands::ClearPinResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ClearPinResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnDoorLockClearRfidResponseSuccess(void * context,
                                   const chip::app::Clusters::DoorLock::Commands::ClearRfidResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ClearRfidResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockClearWeekdayScheduleResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::ClearWeekdayScheduleResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ClearWeekdayScheduleResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockClearYeardayScheduleResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::ClearYeardayScheduleResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ClearYeardayScheduleResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockGetHolidayScheduleResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::GetHolidayScheduleResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetHolidayScheduleResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("scheduleId", 1, data.scheduleId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("localStartTime", 1, data.localStartTime);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("localEndTime", 1, data.localEndTime);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("operatingModeDuringHoliday", 1, data.operatingModeDuringHoliday);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnDoorLockGetLogRecordResponseSuccess(void * context,
                                      const chip::app::Clusters::DoorLock::Commands::GetLogRecordResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetLogRecordResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("logEntryId", 1, data.logEntryId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("timestamp", 1, data.timestamp);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("eventType", 1, data.eventType);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("source", 1, data.source);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("eventIdOrAlarmCode", 1, data.eventIdOrAlarmCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userId", 1, data.userId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("pin", 1, data.pin);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockGetPinResponseSuccess(void * context,
                                            const chip::app::Clusters::DoorLock::Commands::GetPinResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetPinResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userId", 1, data.userId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userStatus", 1, data.userStatus);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userType", 1, data.userType);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("pin", 1, data.pin);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockGetRfidResponseSuccess(void * context,
                                             const chip::app::Clusters::DoorLock::Commands::GetRfidResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetRfidResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userId", 1, data.userId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userStatus", 1, data.userStatus);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userType", 1, data.userType);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("rfid", 1, data.rfid);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnDoorLockGetUserTypeResponseSuccess(void * context,
                                     const chip::app::Clusters::DoorLock::Commands::GetUserTypeResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetUserTypeResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userId", 1, data.userId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userType", 1, data.userType);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockGetWeekdayScheduleResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::GetWeekdayScheduleResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetWeekdayScheduleResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("scheduleId", 1, data.scheduleId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userId", 1, data.userId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("daysMask", 1, data.daysMask);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("startHour", 1, data.startHour);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("startMinute", 1, data.startMinute);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("endHour", 1, data.endHour);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("endMinute", 1, data.endMinute);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockGetYeardayScheduleResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::GetYeardayScheduleResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetYeardayScheduleResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("scheduleId", 1, data.scheduleId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userId", 1, data.userId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("localStartTime", 1, data.localStartTime);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("localEndTime", 1, data.localEndTime);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockLockDoorResponseSuccess(void * context,
                                              const chip::app::Clusters::DoorLock::Commands::LockDoorResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received LockDoorResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockSetHolidayScheduleResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::SetHolidayScheduleResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SetHolidayScheduleResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockSetPinResponseSuccess(void * context,
                                            const chip::app::Clusters::DoorLock::Commands::SetPinResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SetPinResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockSetRfidResponseSuccess(void * context,
                                             const chip::app::Clusters::DoorLock::Commands::SetRfidResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SetRfidResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnDoorLockSetUserTypeResponseSuccess(void * context,
                                     const chip::app::Clusters::DoorLock::Commands::SetUserTypeResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SetUserTypeResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockSetWeekdayScheduleResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::SetWeekdayScheduleResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SetWeekdayScheduleResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockSetYeardayScheduleResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::SetYeardayScheduleResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SetYeardayScheduleResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnDoorLockUnlockDoorResponseSuccess(void * context,
                                    const chip::app::Clusters::DoorLock::Commands::UnlockDoorResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received UnlockDoorResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnDoorLockUnlockWithTimeoutResponseSuccess(
    void * context, const chip::app::Clusters::DoorLock::Commands::UnlockWithTimeoutResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received UnlockWithTimeoutResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGeneralCommissioningArmFailSafeResponseSuccess(
    void * context, const chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ArmFailSafeResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGeneralCommissioningCommissioningCompleteResponseSuccess(
    void * context, const chip::app::Clusters::GeneralCommissioning::Commands::CommissioningCompleteResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received CommissioningCompleteResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGeneralCommissioningSetRegulatoryConfigResponseSuccess(
    void * context, const chip::app::Clusters::GeneralCommissioning::Commands::SetRegulatoryConfigResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SetRegulatoryConfigResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGroupsAddGroupResponseSuccess(void * context,
                                            const chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received AddGroupResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGroupsGetGroupMembershipResponseSuccess(
    void * context, const chip::app::Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetGroupMembershipResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("capacity", 1, data.capacity);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupList", 1, data.groupList);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnGroupsRemoveGroupResponseSuccess(void * context,
                                   const chip::app::Clusters::Groups::Commands::RemoveGroupResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received RemoveGroupResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnGroupsViewGroupResponseSuccess(void * context,
                                             const chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ViewGroupResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupName", 1, data.groupName);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnIdentifyIdentifyQueryResponseSuccess(void * context,
                                       const chip::app::Clusters::Identify::Commands::IdentifyQueryResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received IdentifyQueryResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("timeout", 1, data.timeout);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnKeypadInputSendKeyResponseSuccess(void * context,
                                    const chip::app::Clusters::KeypadInput::Commands::SendKeyResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received SendKeyResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnMediaPlaybackMediaFastForwardResponseSuccess(
    void * context, const chip::app::Clusters::MediaPlayback::Commands::MediaFastForwardResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaFastForwardResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnMediaPlaybackMediaNextResponseSuccess(void * context,
                                        const chip::app::Clusters::MediaPlayback::Commands::MediaNextResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaNextResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnMediaPlaybackMediaPauseResponseSuccess(
    void * context, const chip::app::Clusters::MediaPlayback::Commands::MediaPauseResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaPauseResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnMediaPlaybackMediaPlayResponseSuccess(void * context,
                                        const chip::app::Clusters::MediaPlayback::Commands::MediaPlayResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaPlayResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnMediaPlaybackMediaPreviousResponseSuccess(
    void * context, const chip::app::Clusters::MediaPlayback::Commands::MediaPreviousResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaPreviousResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnMediaPlaybackMediaRewindResponseSuccess(
    void * context, const chip::app::Clusters::MediaPlayback::Commands::MediaRewindResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaRewindResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnMediaPlaybackMediaSeekResponseSuccess(void * context,
                                        const chip::app::Clusters::MediaPlayback::Commands::MediaSeekResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaSeekResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnMediaPlaybackMediaSkipBackwardResponseSuccess(
    void * context, const chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackwardResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaSkipBackwardResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnMediaPlaybackMediaSkipForwardResponseSuccess(
    void * context, const chip::app::Clusters::MediaPlayback::Commands::MediaSkipForwardResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaSkipForwardResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnMediaPlaybackMediaStartOverResponseSuccess(
    void * context, const chip::app::Clusters::MediaPlayback::Commands::MediaStartOverResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaStartOverResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnMediaPlaybackMediaStopResponseSuccess(void * context,
                                        const chip::app::Clusters::MediaPlayback::Commands::MediaStopResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received MediaStopResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("mediaPlaybackStatus", 1, data.mediaPlaybackStatus);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningAddThreadNetworkResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::AddThreadNetworkResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received AddThreadNetworkResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningAddWiFiNetworkResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::AddWiFiNetworkResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received AddWiFiNetworkResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningDisableNetworkResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::DisableNetworkResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received DisableNetworkResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningEnableNetworkResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::EnableNetworkResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received EnableNetworkResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningRemoveNetworkResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::RemoveNetworkResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received RemoveNetworkResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningScanNetworksResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::ScanNetworksResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ScanNetworksResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("wifiScanResults", 1, data.wifiScanResults);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("threadScanResults", 1, data.threadScanResults);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningUpdateThreadNetworkResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::UpdateThreadNetworkResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received UpdateThreadNetworkResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnNetworkCommissioningUpdateWiFiNetworkResponseSuccess(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::UpdateWiFiNetworkResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received UpdateWiFiNetworkResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorCode", 1, data.errorCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOtaSoftwareUpdateProviderApplyUpdateResponseSuccess(
    void * context, const chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::ApplyUpdateResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ApplyUpdateResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("action", 1, data.action);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("delayedActionTime", 1, data.delayedActionTime);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOtaSoftwareUpdateProviderQueryImageResponseSuccess(
    void * context, const chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::QueryImageResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received QueryImageResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("delayedActionTime", 1, data.delayedActionTime);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("imageURI", 1, data.imageURI);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("softwareVersion", 1, data.softwareVersion);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("softwareVersionString", 1, data.softwareVersionString);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("updateToken", 1, data.updateToken);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("userConsentNeeded", 1, data.userConsentNeeded);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("metadataForRequestor", 1, data.metadataForRequestor);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOperationalCredentialsAttestationResponseSuccess(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::AttestationResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received AttestationResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("attestationElements", 1, data.attestationElements);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("signature", 1, data.signature);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOperationalCredentialsCertificateChainResponseSuccess(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::CertificateChainResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received CertificateChainResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("certificate", 1, data.certificate);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOperationalCredentialsNOCResponseSuccess(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received NOCResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("statusCode", 1, data.statusCode);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("fabricIndex", 1, data.fabricIndex);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("debugText", 1, data.debugText);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnOperationalCredentialsOpCSRResponseSuccess(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::OpCSRResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received OpCSRResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("NOCSRElements", 1, data.NOCSRElements);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("attestationSignature", 1, data.attestationSignature);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnScenesAddSceneResponseSuccess(void * context,
                                            const chip::app::Clusters::Scenes::Commands::AddSceneResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received AddSceneResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneId", 1, data.sceneId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnScenesGetSceneMembershipResponseSuccess(
    void * context, const chip::app::Clusters::Scenes::Commands::GetSceneMembershipResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received GetSceneMembershipResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("capacity", 1, data.capacity);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneCount", 1, data.sceneCount);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneList", 1, data.sceneList);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnScenesRemoveAllScenesResponseSuccess(void * context,
                                       const chip::app::Clusters::Scenes::Commands::RemoveAllScenesResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received RemoveAllScenesResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnScenesRemoveSceneResponseSuccess(void * context,
                                   const chip::app::Clusters::Scenes::Commands::RemoveSceneResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received RemoveSceneResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneId", 1, data.sceneId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnScenesStoreSceneResponseSuccess(void * context,
                                              const chip::app::Clusters::Scenes::Commands::StoreSceneResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received StoreSceneResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneId", 1, data.sceneId);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnScenesViewSceneResponseSuccess(void * context,
                                             const chip::app::Clusters::Scenes::Commands::ViewSceneResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ViewSceneResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("groupId", 1, data.groupId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneId", 1, data.sceneId);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("transitionTime", 1, data.transitionTime);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("sceneName", 1, data.sceneName);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("extensionFieldSets", 1, data.extensionFieldSets);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnTvChannelChangeChannelResponseSuccess(void * context,
                                        const chip::app::Clusters::TvChannel::Commands::ChangeChannelResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received ChangeChannelResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("channelMatch", 1, data.channelMatch);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("errorType", 1, data.errorType);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTargetNavigatorNavigateTargetResponseSuccess(
    void * context, const chip::app::Clusters::TargetNavigator::Commands::NavigateTargetResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received NavigateTargetResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("status", 1, data.status);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("data", 1, data.data);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnTestClusterBooleanResponseSuccess(void * context,
                                    const chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received BooleanResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("value", 1, data.value);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTestClusterTestAddArgumentsResponseSuccess(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestAddArgumentsResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("returnValue", 1, data.returnValue);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void
OnTestClusterTestEnumsResponseSuccess(void * context,
                                      const chip::app::Clusters::TestCluster::Commands::TestEnumsResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestEnumsResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("arg1", 1, data.arg1);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("arg2", 1, data.arg2);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTestClusterTestListInt8UReverseResponseSuccess(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestListInt8UReverseResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("arg1", 1, data.arg1);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTestClusterTestNullableOptionalResponseSuccess(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestNullableOptionalResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("wasPresent", 1, data.wasPresent);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("wasNull", 1, data.wasNull);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("value", 1, data.value);
    }
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("originalValue", 1, data.originalValue);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

static void OnTestClusterTestSpecificResponseSuccess(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestSpecificResponse::DecodableType & data)
{
    ChipLogProgress(Zcl, "Received TestSpecificResponse:");
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (err == CHIP_NO_ERROR)
    {
        err = LogValue("returnValue", 1, data.returnValue);
    }

    ModelCommand * command = static_cast<ModelCommand *>(context);
    command->SetCommandExitStatus(err);
};

/*----------------------------------------------------------------------------*\
| Cluster Name                                                        |   ID   |
|---------------------------------------------------------------------+--------|
| AccountLogin                                                        | 0x050E |
| AdministratorCommissioning                                          | 0x003C |
| ApplicationBasic                                                    | 0x050D |
| ApplicationLauncher                                                 | 0x050C |
| AudioOutput                                                         | 0x050B |
| BarrierControl                                                      | 0x0103 |
| Basic                                                               | 0x0028 |
| BinaryInputBasic                                                    | 0x000F |
| Binding                                                             | 0xF000 |
| BooleanState                                                        | 0x0045 |
| BridgedActions                                                      | 0x0025 |
| BridgedDeviceBasicInformation                                       | 0x0039 |
| ColorControl                                                        | 0x0300 |
| ContentLauncher                                                     | 0x050A |
| Descriptor                                                          | 0x001D |
| DiagnosticLogs                                                      | 0x0032 |
| DoorLock                                                            | 0x0101 |
| ElectricalMeasurement                                               | 0x0B04 |
| EthernetNetworkDiagnostics                                          | 0x0037 |
| FixedLabel                                                          | 0x0040 |
| FlowMeasurement                                                     | 0x0404 |
| GeneralCommissioning                                                | 0x0030 |
| GeneralDiagnostics                                                  | 0x0033 |
| GroupKeyManagement                                                  | 0xF004 |
| Groups                                                              | 0x0004 |
| Identify                                                            | 0x0003 |
| IlluminanceMeasurement                                              | 0x0400 |
| KeypadInput                                                         | 0x0509 |
| LevelControl                                                        | 0x0008 |
| LowPower                                                            | 0x0508 |
| MediaInput                                                          | 0x0507 |
| MediaPlayback                                                       | 0x0506 |
| ModeSelect                                                          | 0x0050 |
| NetworkCommissioning                                                | 0x0031 |
| OtaSoftwareUpdateProvider                                           | 0x0029 |
| OtaSoftwareUpdateRequestor                                          | 0x002A |
| OccupancySensing                                                    | 0x0406 |
| OnOff                                                               | 0x0006 |
| OnOffSwitchConfiguration                                            | 0x0007 |
| OperationalCredentials                                              | 0x003E |
| PowerSource                                                         | 0x002F |
| PressureMeasurement                                                 | 0x0403 |
| PumpConfigurationAndControl                                         | 0x0200 |
| RelativeHumidityMeasurement                                         | 0x0405 |
| Scenes                                                              | 0x0005 |
| SoftwareDiagnostics                                                 | 0x0034 |
| Switch                                                              | 0x003B |
| TvChannel                                                           | 0x0504 |
| TargetNavigator                                                     | 0x0505 |
| TemperatureMeasurement                                              | 0x0402 |
| TestCluster                                                         | 0x050F |
| Thermostat                                                          | 0x0201 |
| ThermostatUserInterfaceConfiguration                                | 0x0204 |
| ThreadNetworkDiagnostics                                            | 0x0035 |
| WakeOnLan                                                           | 0x0503 |
| WiFiNetworkDiagnostics                                              | 0x0036 |
| WindowCovering                                                      | 0x0102 |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
| Cluster AccountLogin                                                | 0x050E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * GetSetupPIN                                                       |   0x00 |
| * Login                                                             |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command GetSetupPIN
 */
class AccountLoginGetSetupPIN : public ModelCommand
{
public:
    AccountLoginGetSetupPIN() : ModelCommand("get-setup-pin")
    {
        AddArgument("TempAccountIdentifier", &mRequest.tempAccountIdentifier);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnAccountLoginGetSetupPINResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type mRequest;
};

/*
 * Command Login
 */
class AccountLoginLogin : public ModelCommand
{
public:
    AccountLoginLogin() : ModelCommand("login")
    {
        AddArgument("TempAccountIdentifier", &mRequest.tempAccountIdentifier);
        AddArgument("SetupPIN", &mRequest.setupPIN);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::AccountLogin::Commands::Login::Type mRequest;
};

/*
 * Attribute ClusterRevision
 */
class ReadAccountLoginClusterRevision : public ModelCommand
{
public:
    ReadAccountLoginClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050E) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::AccountLoginCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportAccountLoginClusterRevision : public ModelCommand
{
public:
    ReportAccountLoginClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccountLoginClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050E) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::AccountLoginCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AdministratorCommissioning                                  | 0x003C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * OpenBasicCommissioningWindow                                      |   0x01 |
| * OpenCommissioningWindow                                           |   0x00 |
| * RevokeCommissioning                                               |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command OpenBasicCommissioningWindow
 */
class AdministratorCommissioningOpenBasicCommissioningWindow : public ModelCommand
{
public:
    AdministratorCommissioningOpenBasicCommissioningWindow() : ModelCommand("open-basic-commissioning-window")
    {
        AddArgument("CommissioningTimeout", 0, UINT16_MAX, &mRequest.commissioningTimeout);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type mRequest;
};

/*
 * Command OpenCommissioningWindow
 */
class AdministratorCommissioningOpenCommissioningWindow : public ModelCommand
{
public:
    AdministratorCommissioningOpenCommissioningWindow() : ModelCommand("open-commissioning-window")
    {
        AddArgument("CommissioningTimeout", 0, UINT16_MAX, &mRequest.commissioningTimeout);
        AddArgument("PAKEVerifier", &mRequest.PAKEVerifier);
        AddArgument("Discriminator", 0, UINT16_MAX, &mRequest.discriminator);
        AddArgument("Iterations", 0, UINT32_MAX, &mRequest.iterations);
        AddArgument("Salt", &mRequest.salt);
        AddArgument("PasscodeID", 0, UINT16_MAX, &mRequest.passcodeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type mRequest;
};

/*
 * Command RevokeCommissioning
 */
class AdministratorCommissioningRevokeCommissioning : public ModelCommand
{
public:
    AdministratorCommissioningRevokeCommissioning() : ModelCommand("revoke-commissioning") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::AdministratorCommissioning::Commands::RevokeCommissioning::Type mRequest;
};

/*
 * Attribute ClusterRevision
 */
class ReadAdministratorCommissioningClusterRevision : public ModelCommand
{
public:
    ReadAdministratorCommissioningClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003C) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::AdministratorCommissioningCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportAdministratorCommissioningClusterRevision : public ModelCommand
{
public:
    ReportAdministratorCommissioningClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAdministratorCommissioningClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003C) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::AdministratorCommissioningCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ApplicationBasic                                            | 0x050D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeStatus                                                      |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * VendorName                                                        | 0x0000 |
| * VendorId                                                          | 0x0001 |
| * ApplicationName                                                   | 0x0002 |
| * ProductId                                                         | 0x0003 |
| * ApplicationId                                                     | 0x0005 |
| * CatalogVendorId                                                   | 0x0006 |
| * ApplicationStatus                                                 | 0x0007 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeStatus
 */
class ApplicationBasicChangeStatus : public ModelCommand
{
public:
    ApplicationBasicChangeStatus() : ModelCommand("change-status")
    {
        AddArgument("Status", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.status)> *>(&mRequest.status));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ApplicationBasic::Commands::ChangeStatus::Type mRequest;
};

/*
 * Attribute VendorName
 */
class ReadApplicationBasicVendorName : public ModelCommand
{
public:
    ReadApplicationBasicVendorName() : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicVendorName()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeVendorName(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationBasicVendorName : public ModelCommand
{
public:
    ReportApplicationBasicVendorName() : ModelCommand("report")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicVendorName()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeVendorName(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeVendorName(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorId
 */
class ReadApplicationBasicVendorId : public ModelCommand
{
public:
    ReadApplicationBasicVendorId() : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicVendorId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeVendorId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationBasicVendorId : public ModelCommand
{
public:
    ReportApplicationBasicVendorId() : ModelCommand("report")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicVendorId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeVendorId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeVendorId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationName
 */
class ReadApplicationBasicApplicationName : public ModelCommand
{
public:
    ReadApplicationBasicApplicationName() : ModelCommand("read")
    {
        AddArgument("attr-name", "application-name");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationName()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeApplicationName(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationBasicApplicationName : public ModelCommand
{
public:
    ReportApplicationBasicApplicationName() : ModelCommand("report")
    {
        AddArgument("attr-name", "application-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicApplicationName()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeApplicationName(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeApplicationName(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductId
 */
class ReadApplicationBasicProductId : public ModelCommand
{
public:
    ReadApplicationBasicProductId() : ModelCommand("read")
    {
        AddArgument("attr-name", "product-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicProductId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeProductId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationBasicProductId : public ModelCommand
{
public:
    ReportApplicationBasicProductId() : ModelCommand("report")
    {
        AddArgument("attr-name", "product-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicProductId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeProductId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeProductId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationId
 */
class ReadApplicationBasicApplicationId : public ModelCommand
{
public:
    ReadApplicationBasicApplicationId() : ModelCommand("read")
    {
        AddArgument("attr-name", "application-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeApplicationId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationBasicApplicationId : public ModelCommand
{
public:
    ReportApplicationBasicApplicationId() : ModelCommand("report")
    {
        AddArgument("attr-name", "application-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicApplicationId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeApplicationId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeApplicationId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CatalogVendorId
 */
class ReadApplicationBasicCatalogVendorId : public ModelCommand
{
public:
    ReadApplicationBasicCatalogVendorId() : ModelCommand("read")
    {
        AddArgument("attr-name", "catalog-vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicCatalogVendorId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCatalogVendorId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationBasicCatalogVendorId : public ModelCommand
{
public:
    ReportApplicationBasicCatalogVendorId() : ModelCommand("report")
    {
        AddArgument("attr-name", "catalog-vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicCatalogVendorId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCatalogVendorId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCatalogVendorId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationStatus
 */
class ReadApplicationBasicApplicationStatus : public ModelCommand
{
public:
    ReadApplicationBasicApplicationStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "application-status");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationStatus()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeApplicationStatus(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationBasicApplicationStatus : public ModelCommand
{
public:
    ReportApplicationBasicApplicationStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "application-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicApplicationStatus()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeApplicationStatus(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeApplicationStatus(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadApplicationBasicClusterRevision : public ModelCommand
{
public:
    ReadApplicationBasicClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationBasicClusterRevision : public ModelCommand
{
public:
    ReportApplicationBasicClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050D) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ApplicationLauncher                                         | 0x050C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * LaunchApp                                                         |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ApplicationLauncherList                                           | 0x0000 |
| * CatalogVendorId                                                   | 0x0001 |
| * ApplicationId                                                     | 0x0002 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command LaunchApp
 */
class ApplicationLauncherLaunchApp : public ModelCommand
{
public:
    ApplicationLauncherLaunchApp() : ModelCommand("launch-app")
    {
        AddArgument("Data", &mRequest.data);
        AddArgument("CatalogVendorId", 0, UINT16_MAX, &mRequest.catalogVendorId);
        AddArgument("ApplicationId", &mRequest.applicationId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnApplicationLauncherLaunchAppResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type mRequest;
};

/*
 * Attribute ApplicationLauncherList
 */
class ReadApplicationLauncherApplicationLauncherList : public ModelCommand
{
public:
    ReadApplicationLauncherApplicationLauncherList() : ModelCommand("read")
    {
        AddArgument("attr-name", "application-launcher-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherApplicationLauncherList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050C) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationLauncherCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeApplicationLauncherList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<ApplicationLauncherApplicationLauncherListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<ApplicationLauncherApplicationLauncherListListAttributeCallback>(
            OnApplicationLauncherApplicationLauncherListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute CatalogVendorId
 */
class ReadApplicationLauncherCatalogVendorId : public ModelCommand
{
public:
    ReadApplicationLauncherCatalogVendorId() : ModelCommand("read")
    {
        AddArgument("attr-name", "catalog-vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherCatalogVendorId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050C) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationLauncherCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCatalogVendorId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationLauncherCatalogVendorId : public ModelCommand
{
public:
    ReportApplicationLauncherCatalogVendorId() : ModelCommand("report")
    {
        AddArgument("attr-name", "catalog-vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherCatalogVendorId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050C) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationLauncherCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCatalogVendorId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCatalogVendorId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationId
 */
class ReadApplicationLauncherApplicationId : public ModelCommand
{
public:
    ReadApplicationLauncherApplicationId() : ModelCommand("read")
    {
        AddArgument("attr-name", "application-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherApplicationId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050C) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationLauncherCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeApplicationId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationLauncherApplicationId : public ModelCommand
{
public:
    ReportApplicationLauncherApplicationId() : ModelCommand("report")
    {
        AddArgument("attr-name", "application-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherApplicationId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050C) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationLauncherCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeApplicationId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeApplicationId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadApplicationLauncherClusterRevision : public ModelCommand
{
public:
    ReadApplicationLauncherClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050C) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationLauncherCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportApplicationLauncherClusterRevision : public ModelCommand
{
public:
    ReportApplicationLauncherClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050C) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ApplicationLauncherCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AudioOutput                                                 | 0x050B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * RenameOutput                                                      |   0x01 |
| * SelectOutput                                                      |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AudioOutputList                                                   | 0x0000 |
| * CurrentAudioOutput                                                | 0x0001 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command RenameOutput
 */
class AudioOutputRenameOutput : public ModelCommand
{
public:
    AudioOutputRenameOutput() : ModelCommand("rename-output")
    {
        AddArgument("Index", 0, UINT8_MAX, &mRequest.index);
        AddArgument("Name", &mRequest.name);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type mRequest;
};

/*
 * Command SelectOutput
 */
class AudioOutputSelectOutput : public ModelCommand
{
public:
    AudioOutputSelectOutput() : ModelCommand("select-output")
    {
        AddArgument("Index", 0, UINT8_MAX, &mRequest.index);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type mRequest;
};

/*
 * Attribute AudioOutputList
 */
class ReadAudioOutputAudioOutputList : public ModelCommand
{
public:
    ReadAudioOutputAudioOutputList() : ModelCommand("read")
    {
        AddArgument("attr-name", "audio-output-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputAudioOutputList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050B) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::AudioOutputCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeAudioOutputList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<AudioOutputAudioOutputListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<AudioOutputAudioOutputListListAttributeCallback>(
            OnAudioOutputAudioOutputListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute CurrentAudioOutput
 */
class ReadAudioOutputCurrentAudioOutput : public ModelCommand
{
public:
    ReadAudioOutputCurrentAudioOutput() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-audio-output");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputCurrentAudioOutput()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050B) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::AudioOutputCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentAudioOutput(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportAudioOutputCurrentAudioOutput : public ModelCommand
{
public:
    ReportAudioOutputCurrentAudioOutput() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-audio-output");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputCurrentAudioOutput()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050B) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::AudioOutputCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentAudioOutput(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentAudioOutput(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAudioOutputClusterRevision : public ModelCommand
{
public:
    ReadAudioOutputClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050B) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::AudioOutputCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportAudioOutputClusterRevision : public ModelCommand
{
public:
    ReportAudioOutputClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050B) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::AudioOutputCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BarrierControl                                              | 0x0103 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * BarrierControlGoToPercent                                         |   0x00 |
| * BarrierControlStop                                                |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * BarrierMovingState                                                | 0x0001 |
| * BarrierSafetyStatus                                               | 0x0002 |
| * BarrierCapabilities                                               | 0x0003 |
| * BarrierPosition                                                   | 0x000A |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command BarrierControlGoToPercent
 */
class BarrierControlBarrierControlGoToPercent : public ModelCommand
{
public:
    BarrierControlBarrierControlGoToPercent() : ModelCommand("barrier-control-go-to-percent")
    {
        AddArgument("PercentOpen", 0, UINT8_MAX, &mRequest.percentOpen);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BarrierControl::Commands::BarrierControlGoToPercent::Type mRequest;
};

/*
 * Command BarrierControlStop
 */
class BarrierControlBarrierControlStop : public ModelCommand
{
public:
    BarrierControlBarrierControlStop() : ModelCommand("barrier-control-stop") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BarrierControl::Commands::BarrierControlStop::Type mRequest;
};

/*
 * Attribute BarrierMovingState
 */
class ReadBarrierControlBarrierMovingState : public ModelCommand
{
public:
    ReadBarrierControlBarrierMovingState() : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-moving-state");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierMovingState()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0103) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BarrierControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBarrierMovingState(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBarrierControlBarrierMovingState : public ModelCommand
{
public:
    ReportBarrierControlBarrierMovingState() : ModelCommand("report")
    {
        AddArgument("attr-name", "barrier-moving-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierMovingState()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0103) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BarrierControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBarrierMovingState(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBarrierMovingState(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierSafetyStatus
 */
class ReadBarrierControlBarrierSafetyStatus : public ModelCommand
{
public:
    ReadBarrierControlBarrierSafetyStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-safety-status");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierSafetyStatus()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0103) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BarrierControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBarrierSafetyStatus(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBarrierControlBarrierSafetyStatus : public ModelCommand
{
public:
    ReportBarrierControlBarrierSafetyStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "barrier-safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierSafetyStatus()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0103) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BarrierControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBarrierSafetyStatus(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBarrierSafetyStatus(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierCapabilities
 */
class ReadBarrierControlBarrierCapabilities : public ModelCommand
{
public:
    ReadBarrierControlBarrierCapabilities() : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-capabilities");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierCapabilities()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0103) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BarrierControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBarrierCapabilities(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBarrierControlBarrierCapabilities : public ModelCommand
{
public:
    ReportBarrierControlBarrierCapabilities() : ModelCommand("report")
    {
        AddArgument("attr-name", "barrier-capabilities");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierCapabilities()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0103) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BarrierControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBarrierCapabilities(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBarrierCapabilities(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierPosition
 */
class ReadBarrierControlBarrierPosition : public ModelCommand
{
public:
    ReadBarrierControlBarrierPosition() : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-position");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierPosition()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0103) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BarrierControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBarrierPosition(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBarrierControlBarrierPosition : public ModelCommand
{
public:
    ReportBarrierControlBarrierPosition() : ModelCommand("report")
    {
        AddArgument("attr-name", "barrier-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierPosition()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0103) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BarrierControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBarrierPosition(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBarrierPosition(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBarrierControlClusterRevision : public ModelCommand
{
public:
    ReadBarrierControlClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0103) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BarrierControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBarrierControlClusterRevision : public ModelCommand
{
public:
    ReportBarrierControlClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0103) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BarrierControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Basic                                                       | 0x0028 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MfgSpecificPing                                                   |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * InteractionModelVersion                                           | 0x0000 |
| * VendorName                                                        | 0x0001 |
| * VendorID                                                          | 0x0002 |
| * ProductName                                                       | 0x0003 |
| * ProductID                                                         | 0x0004 |
| * UserLabel                                                         | 0x0005 |
| * Location                                                          | 0x0006 |
| * HardwareVersion                                                   | 0x0007 |
| * HardwareVersionString                                             | 0x0008 |
| * SoftwareVersion                                                   | 0x0009 |
| * SoftwareVersionString                                             | 0x000A |
| * ManufacturingDate                                                 | 0x000B |
| * PartNumber                                                        | 0x000C |
| * ProductURL                                                        | 0x000D |
| * ProductLabel                                                      | 0x000E |
| * SerialNumber                                                      | 0x000F |
| * LocalConfigDisabled                                               | 0x0010 |
| * Reachable                                                         | 0x0011 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command MfgSpecificPing
 */
class BasicMfgSpecificPing : public ModelCommand
{
public:
    BasicMfgSpecificPing() : ModelCommand("mfg-specific-ping") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Basic::Commands::MfgSpecificPing::Type mRequest;
};

/*
 * Attribute InteractionModelVersion
 */
class ReadBasicInteractionModelVersion : public ModelCommand
{
public:
    ReadBasicInteractionModelVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "interaction-model-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicInteractionModelVersion()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInteractionModelVersion(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicInteractionModelVersion : public ModelCommand
{
public:
    ReportBasicInteractionModelVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "interaction-model-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicInteractionModelVersion()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInteractionModelVersion(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInteractionModelVersion(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                 mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorName
 */
class ReadBasicVendorName : public ModelCommand
{
public:
    ReadBasicVendorName() : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadBasicVendorName()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeVendorName(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicVendorName : public ModelCommand
{
public:
    ReportBasicVendorName() : ModelCommand("report")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicVendorName()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeVendorName(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeVendorName(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorID
 */
class ReadBasicVendorID : public ModelCommand
{
public:
    ReadBasicVendorID() : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicVendorID()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeVendorID(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicVendorID : public ModelCommand
{
public:
    ReportBasicVendorID() : ModelCommand("report")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicVendorID()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeVendorID(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeVendorID(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductName
 */
class ReadBasicProductName : public ModelCommand
{
public:
    ReadBasicProductName() : ModelCommand("read")
    {
        AddArgument("attr-name", "product-name");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductName()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeProductName(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicProductName : public ModelCommand
{
public:
    ReportBasicProductName() : ModelCommand("report")
    {
        AddArgument("attr-name", "product-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductName()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeProductName(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeProductName(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductID
 */
class ReadBasicProductID : public ModelCommand
{
public:
    ReadBasicProductID() : ModelCommand("read")
    {
        AddArgument("attr-name", "product-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductID()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeProductID(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicProductID : public ModelCommand
{
public:
    ReportBasicProductID() : ModelCommand("report")
    {
        AddArgument("attr-name", "product-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductID()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeProductID(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeProductID(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UserLabel
 */
class ReadBasicUserLabel : public ModelCommand
{
public:
    ReadBasicUserLabel() : ModelCommand("read")
    {
        AddArgument("attr-name", "user-label");
        ModelCommand::AddArguments();
    }

    ~ReadBasicUserLabel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeUserLabel(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteBasicUserLabel : public ModelCommand
{
public:
    WriteBasicUserLabel() : ModelCommand("write")
    {
        AddArgument("attr-name", "user-label");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicUserLabel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeUserLabel(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::CharSpan mValue;
};

class ReportBasicUserLabel : public ModelCommand
{
public:
    ReportBasicUserLabel() : ModelCommand("report")
    {
        AddArgument("attr-name", "user-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicUserLabel()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeUserLabel(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeUserLabel(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Location
 */
class ReadBasicLocation : public ModelCommand
{
public:
    ReadBasicLocation() : ModelCommand("read")
    {
        AddArgument("attr-name", "location");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLocation()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLocation(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteBasicLocation : public ModelCommand
{
public:
    WriteBasicLocation() : ModelCommand("write")
    {
        AddArgument("attr-name", "location");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicLocation()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeLocation(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::CharSpan mValue;
};

class ReportBasicLocation : public ModelCommand
{
public:
    ReportBasicLocation() : ModelCommand("report")
    {
        AddArgument("attr-name", "location");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicLocation()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLocation(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLocation(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersion
 */
class ReadBasicHardwareVersion : public ModelCommand
{
public:
    ReadBasicHardwareVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicHardwareVersion()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeHardwareVersion(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicHardwareVersion : public ModelCommand
{
public:
    ReportBasicHardwareVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "hardware-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicHardwareVersion()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeHardwareVersion(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeHardwareVersion(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersionString
 */
class ReadBasicHardwareVersionString : public ModelCommand
{
public:
    ReadBasicHardwareVersionString() : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBasicHardwareVersionString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeHardwareVersionString(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicHardwareVersionString : public ModelCommand
{
public:
    ReportBasicHardwareVersionString() : ModelCommand("report")
    {
        AddArgument("attr-name", "hardware-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicHardwareVersionString()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeHardwareVersionString(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeHardwareVersionString(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                               mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersion
 */
class ReadBasicSoftwareVersion : public ModelCommand
{
public:
    ReadBasicSoftwareVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSoftwareVersion()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSoftwareVersion(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicSoftwareVersion : public ModelCommand
{
public:
    ReportBasicSoftwareVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "software-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicSoftwareVersion()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSoftwareVersion(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSoftwareVersion(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersionString
 */
class ReadBasicSoftwareVersionString : public ModelCommand
{
public:
    ReadBasicSoftwareVersionString() : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSoftwareVersionString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSoftwareVersionString(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicSoftwareVersionString : public ModelCommand
{
public:
    ReportBasicSoftwareVersionString() : ModelCommand("report")
    {
        AddArgument("attr-name", "software-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicSoftwareVersionString()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSoftwareVersionString(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSoftwareVersionString(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                               mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ManufacturingDate
 */
class ReadBasicManufacturingDate : public ModelCommand
{
public:
    ReadBasicManufacturingDate() : ModelCommand("read")
    {
        AddArgument("attr-name", "manufacturing-date");
        ModelCommand::AddArguments();
    }

    ~ReadBasicManufacturingDate()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeManufacturingDate(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicManufacturingDate : public ModelCommand
{
public:
    ReportBasicManufacturingDate() : ModelCommand("report")
    {
        AddArgument("attr-name", "manufacturing-date");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicManufacturingDate()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeManufacturingDate(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeManufacturingDate(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartNumber
 */
class ReadBasicPartNumber : public ModelCommand
{
public:
    ReadBasicPartNumber() : ModelCommand("read")
    {
        AddArgument("attr-name", "part-number");
        ModelCommand::AddArguments();
    }

    ~ReadBasicPartNumber()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePartNumber(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicPartNumber : public ModelCommand
{
public:
    ReportBasicPartNumber() : ModelCommand("report")
    {
        AddArgument("attr-name", "part-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicPartNumber()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePartNumber(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePartNumber(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductURL
 */
class ReadBasicProductURL : public ModelCommand
{
public:
    ReadBasicProductURL() : ModelCommand("read")
    {
        AddArgument("attr-name", "product-url");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductURL()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeProductURL(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicProductURL : public ModelCommand
{
public:
    ReportBasicProductURL() : ModelCommand("report")
    {
        AddArgument("attr-name", "product-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductURL()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeProductURL(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeProductURL(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductLabel
 */
class ReadBasicProductLabel : public ModelCommand
{
public:
    ReadBasicProductLabel() : ModelCommand("read")
    {
        AddArgument("attr-name", "product-label");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductLabel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeProductLabel(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicProductLabel : public ModelCommand
{
public:
    ReportBasicProductLabel() : ModelCommand("report")
    {
        AddArgument("attr-name", "product-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductLabel()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeProductLabel(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeProductLabel(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SerialNumber
 */
class ReadBasicSerialNumber : public ModelCommand
{
public:
    ReadBasicSerialNumber() : ModelCommand("read")
    {
        AddArgument("attr-name", "serial-number");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSerialNumber()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSerialNumber(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicSerialNumber : public ModelCommand
{
public:
    ReportBasicSerialNumber() : ModelCommand("report")
    {
        AddArgument("attr-name", "serial-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicSerialNumber()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSerialNumber(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSerialNumber(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LocalConfigDisabled
 */
class ReadBasicLocalConfigDisabled : public ModelCommand
{
public:
    ReadBasicLocalConfigDisabled() : ModelCommand("read")
    {
        AddArgument("attr-name", "local-config-disabled");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLocalConfigDisabled()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLocalConfigDisabled(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteBasicLocalConfigDisabled : public ModelCommand
{
public:
    WriteBasicLocalConfigDisabled() : ModelCommand("write")
    {
        AddArgument("attr-name", "local-config-disabled");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicLocalConfigDisabled()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeLocalConfigDisabled(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    bool mValue;
};

class ReportBasicLocalConfigDisabled : public ModelCommand
{
public:
    ReportBasicLocalConfigDisabled() : ModelCommand("report")
    {
        AddArgument("attr-name", "local-config-disabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicLocalConfigDisabled()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLocalConfigDisabled(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLocalConfigDisabled(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Reachable
 */
class ReadBasicReachable : public ModelCommand
{
public:
    ReadBasicReachable() : ModelCommand("read")
    {
        AddArgument("attr-name", "reachable");
        ModelCommand::AddArguments();
    }

    ~ReadBasicReachable()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeReachable(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicReachable : public ModelCommand
{
public:
    ReportBasicReachable() : ModelCommand("report")
    {
        AddArgument("attr-name", "reachable");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicReachable()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeReachable(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeReachable(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBasicClusterRevision : public ModelCommand
{
public:
    ReadBasicClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBasicClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBasicClusterRevision : public ModelCommand
{
public:
    ReportBasicClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0028) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BinaryInputBasic                                            | 0x000F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OutOfService                                                      | 0x0051 |
| * PresentValue                                                      | 0x0055 |
| * StatusFlags                                                       | 0x006F |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute OutOfService
 */
class ReadBinaryInputBasicOutOfService : public ModelCommand
{
public:
    ReadBinaryInputBasicOutOfService() : ModelCommand("read")
    {
        AddArgument("attr-name", "out-of-service");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicOutOfService()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x000F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BinaryInputBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOutOfService(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteBinaryInputBasicOutOfService : public ModelCommand
{
public:
    WriteBinaryInputBasicOutOfService() : ModelCommand("write")
    {
        AddArgument("attr-name", "out-of-service");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBinaryInputBasicOutOfService()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x000F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::BinaryInputBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOutOfService(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    bool mValue;
};

class ReportBinaryInputBasicOutOfService : public ModelCommand
{
public:
    ReportBinaryInputBasicOutOfService() : ModelCommand("report")
    {
        AddArgument("attr-name", "out-of-service");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicOutOfService()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x000F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BinaryInputBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOutOfService(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOutOfService(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PresentValue
 */
class ReadBinaryInputBasicPresentValue : public ModelCommand
{
public:
    ReadBinaryInputBasicPresentValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "present-value");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicPresentValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x000F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BinaryInputBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePresentValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteBinaryInputBasicPresentValue : public ModelCommand
{
public:
    WriteBinaryInputBasicPresentValue() : ModelCommand("write")
    {
        AddArgument("attr-name", "present-value");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBinaryInputBasicPresentValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x000F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::BinaryInputBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributePresentValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    bool mValue;
};

class ReportBinaryInputBasicPresentValue : public ModelCommand
{
public:
    ReportBinaryInputBasicPresentValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "present-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicPresentValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x000F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BinaryInputBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePresentValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePresentValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StatusFlags
 */
class ReadBinaryInputBasicStatusFlags : public ModelCommand
{
public:
    ReadBinaryInputBasicStatusFlags() : ModelCommand("read")
    {
        AddArgument("attr-name", "status-flags");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicStatusFlags()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x000F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BinaryInputBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeStatusFlags(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBinaryInputBasicStatusFlags : public ModelCommand
{
public:
    ReportBinaryInputBasicStatusFlags() : ModelCommand("report")
    {
        AddArgument("attr-name", "status-flags");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicStatusFlags()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x000F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BinaryInputBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeStatusFlags(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeStatusFlags(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBinaryInputBasicClusterRevision : public ModelCommand
{
public:
    ReadBinaryInputBasicClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x000F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BinaryInputBasicCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBinaryInputBasicClusterRevision : public ModelCommand
{
public:
    ReportBinaryInputBasicClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x000F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BinaryInputBasicCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Binding                                                     | 0xF000 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Bind                                                              |   0x00 |
| * Unbind                                                            |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command Bind
 */
class BindingBind : public ModelCommand
{
public:
    BindingBind() : ModelCommand("bind")
    {
        AddArgument("NodeId", 0, UINT64_MAX, &mRequest.nodeId);
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("EndpointId", 0, UINT16_MAX, &mRequest.endpointId);
        AddArgument("ClusterId", 0, UINT32_MAX, &mRequest.clusterId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000F000) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Binding::Commands::Bind::Type mRequest;
};

/*
 * Command Unbind
 */
class BindingUnbind : public ModelCommand
{
public:
    BindingUnbind() : ModelCommand("unbind")
    {
        AddArgument("NodeId", 0, UINT64_MAX, &mRequest.nodeId);
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("EndpointId", 0, UINT16_MAX, &mRequest.endpointId);
        AddArgument("ClusterId", 0, UINT32_MAX, &mRequest.clusterId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000F000) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Binding::Commands::Unbind::Type mRequest;
};

/*
 * Attribute ClusterRevision
 */
class ReadBindingClusterRevision : public ModelCommand
{
public:
    ReadBindingClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBindingClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0xF000) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BindingCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBindingClusterRevision : public ModelCommand
{
public:
    ReportBindingClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBindingClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0xF000) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BindingCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BooleanState                                                | 0x0045 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * StateValue                                                        | 0x0000 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute StateValue
 */
class ReadBooleanStateStateValue : public ModelCommand
{
public:
    ReadBooleanStateStateValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "state-value");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateStateValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0045) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BooleanStateCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeStateValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBooleanStateStateValue : public ModelCommand
{
public:
    ReportBooleanStateStateValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "state-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateStateValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0045) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BooleanStateCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeStateValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeStateValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBooleanStateClusterRevision : public ModelCommand
{
public:
    ReadBooleanStateClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0045) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BooleanStateCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBooleanStateClusterRevision : public ModelCommand
{
public:
    ReportBooleanStateClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0045) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BooleanStateCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BridgedActions                                              | 0x0025 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * DisableAction                                                     |   0x0A |
| * DisableActionWithDuration                                         |   0x0B |
| * EnableAction                                                      |   0x08 |
| * EnableActionWithDuration                                          |   0x09 |
| * InstantAction                                                     |   0x00 |
| * InstantActionWithTransition                                       |   0x01 |
| * PauseAction                                                       |   0x05 |
| * PauseActionWithDuration                                           |   0x06 |
| * ResumeAction                                                      |   0x07 |
| * StartAction                                                       |   0x02 |
| * StartActionWithDuration                                           |   0x03 |
| * StopAction                                                        |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActionList                                                        | 0x0000 |
| * EndpointList                                                      | 0x0001 |
| * SetupUrl                                                          | 0x0002 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command DisableAction
 */
class BridgedActionsDisableAction : public ModelCommand
{
public:
    BridgedActionsDisableAction() : ModelCommand("disable-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x0000000A) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::DisableAction::Type mRequest;
};

/*
 * Command DisableActionWithDuration
 */
class BridgedActionsDisableActionWithDuration : public ModelCommand
{
public:
    BridgedActionsDisableActionWithDuration() : ModelCommand("disable-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mRequest.duration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x0000000B) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::DisableActionWithDuration::Type mRequest;
};

/*
 * Command EnableAction
 */
class BridgedActionsEnableAction : public ModelCommand
{
public:
    BridgedActionsEnableAction() : ModelCommand("enable-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000008) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::EnableAction::Type mRequest;
};

/*
 * Command EnableActionWithDuration
 */
class BridgedActionsEnableActionWithDuration : public ModelCommand
{
public:
    BridgedActionsEnableActionWithDuration() : ModelCommand("enable-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mRequest.duration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000009) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::EnableActionWithDuration::Type mRequest;
};

/*
 * Command InstantAction
 */
class BridgedActionsInstantAction : public ModelCommand
{
public:
    BridgedActionsInstantAction() : ModelCommand("instant-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::InstantAction::Type mRequest;
};

/*
 * Command InstantActionWithTransition
 */
class BridgedActionsInstantActionWithTransition : public ModelCommand
{
public:
    BridgedActionsInstantActionWithTransition() : ModelCommand("instant-action-with-transition")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::InstantActionWithTransition::Type mRequest;
};

/*
 * Command PauseAction
 */
class BridgedActionsPauseAction : public ModelCommand
{
public:
    BridgedActionsPauseAction() : ModelCommand("pause-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000005) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::PauseAction::Type mRequest;
};

/*
 * Command PauseActionWithDuration
 */
class BridgedActionsPauseActionWithDuration : public ModelCommand
{
public:
    BridgedActionsPauseActionWithDuration() : ModelCommand("pause-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mRequest.duration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000006) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::PauseActionWithDuration::Type mRequest;
};

/*
 * Command ResumeAction
 */
class BridgedActionsResumeAction : public ModelCommand
{
public:
    BridgedActionsResumeAction() : ModelCommand("resume-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000007) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::ResumeAction::Type mRequest;
};

/*
 * Command StartAction
 */
class BridgedActionsStartAction : public ModelCommand
{
public:
    BridgedActionsStartAction() : ModelCommand("start-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::StartAction::Type mRequest;
};

/*
 * Command StartActionWithDuration
 */
class BridgedActionsStartActionWithDuration : public ModelCommand
{
public:
    BridgedActionsStartActionWithDuration() : ModelCommand("start-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mRequest.duration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000003) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::StartActionWithDuration::Type mRequest;
};

/*
 * Command StopAction
 */
class BridgedActionsStopAction : public ModelCommand
{
public:
    BridgedActionsStopAction() : ModelCommand("stop-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mRequest.actionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mRequest.invokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::BridgedActions::Commands::StopAction::Type mRequest;
};

/*
 * Attribute ActionList
 */
class ReadBridgedActionsActionList : public ModelCommand
{
public:
    ReadBridgedActionsActionList() : ModelCommand("read")
    {
        AddArgument("attr-name", "action-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsActionList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0025) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BridgedActionsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActionList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BridgedActionsActionListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BridgedActionsActionListListAttributeCallback>(OnBridgedActionsActionListListAttributeResponse,
                                                                                    this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute EndpointList
 */
class ReadBridgedActionsEndpointList : public ModelCommand
{
public:
    ReadBridgedActionsEndpointList() : ModelCommand("read")
    {
        AddArgument("attr-name", "endpoint-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsEndpointList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0025) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BridgedActionsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeEndpointList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BridgedActionsEndpointListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BridgedActionsEndpointListListAttributeCallback>(
            OnBridgedActionsEndpointListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute SetupUrl
 */
class ReadBridgedActionsSetupUrl : public ModelCommand
{
public:
    ReadBridgedActionsSetupUrl() : ModelCommand("read")
    {
        AddArgument("attr-name", "setup-url");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsSetupUrl()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0025) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BridgedActionsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSetupUrl(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBridgedActionsSetupUrl : public ModelCommand
{
public:
    ReportBridgedActionsSetupUrl() : ModelCommand("report")
    {
        AddArgument("attr-name", "setup-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsSetupUrl()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0025) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BridgedActionsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSetupUrl(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSetupUrl(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBridgedActionsClusterRevision : public ModelCommand
{
public:
    ReadBridgedActionsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0025) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BridgedActionsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBridgedActionsClusterRevision : public ModelCommand
{
public:
    ReportBridgedActionsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0025) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BridgedActionsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BridgedDeviceBasicInformation                               | 0x0039 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute ClusterRevision
 */
class ReadBridgedDeviceBasicInformationClusterRevision : public ModelCommand
{
public:
    ReadBridgedDeviceBasicInformationClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicInformationClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0039) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::BridgedDeviceBasicInformationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportBridgedDeviceBasicInformationClusterRevision : public ModelCommand
{
public:
    ReportBridgedDeviceBasicInformationClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicInformationClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0039) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::BridgedDeviceBasicInformationCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ColorControl                                                | 0x0300 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ColorLoopSet                                                      |   0x44 |
| * EnhancedMoveHue                                                   |   0x41 |
| * EnhancedMoveToHue                                                 |   0x40 |
| * EnhancedMoveToHueAndSaturation                                    |   0x43 |
| * EnhancedStepHue                                                   |   0x42 |
| * MoveColor                                                         |   0x08 |
| * MoveColorTemperature                                              |   0x4B |
| * MoveHue                                                           |   0x01 |
| * MoveSaturation                                                    |   0x04 |
| * MoveToColor                                                       |   0x07 |
| * MoveToColorTemperature                                            |   0x0A |
| * MoveToHue                                                         |   0x00 |
| * MoveToHueAndSaturation                                            |   0x06 |
| * MoveToSaturation                                                  |   0x03 |
| * StepColor                                                         |   0x09 |
| * StepColorTemperature                                              |   0x4C |
| * StepHue                                                           |   0x02 |
| * StepSaturation                                                    |   0x05 |
| * StopMoveStep                                                      |   0x47 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentHue                                                        | 0x0000 |
| * CurrentSaturation                                                 | 0x0001 |
| * RemainingTime                                                     | 0x0002 |
| * CurrentX                                                          | 0x0003 |
| * CurrentY                                                          | 0x0004 |
| * DriftCompensation                                                 | 0x0005 |
| * CompensationText                                                  | 0x0006 |
| * ColorTemperature                                                  | 0x0007 |
| * ColorMode                                                         | 0x0008 |
| * ColorControlOptions                                               | 0x000F |
| * NumberOfPrimaries                                                 | 0x0010 |
| * Primary1X                                                         | 0x0011 |
| * Primary1Y                                                         | 0x0012 |
| * Primary1Intensity                                                 | 0x0013 |
| * Primary2X                                                         | 0x0015 |
| * Primary2Y                                                         | 0x0016 |
| * Primary2Intensity                                                 | 0x0017 |
| * Primary3X                                                         | 0x0019 |
| * Primary3Y                                                         | 0x001A |
| * Primary3Intensity                                                 | 0x001B |
| * Primary4X                                                         | 0x0020 |
| * Primary4Y                                                         | 0x0021 |
| * Primary4Intensity                                                 | 0x0022 |
| * Primary5X                                                         | 0x0024 |
| * Primary5Y                                                         | 0x0025 |
| * Primary5Intensity                                                 | 0x0026 |
| * Primary6X                                                         | 0x0028 |
| * Primary6Y                                                         | 0x0029 |
| * Primary6Intensity                                                 | 0x002A |
| * WhitePointX                                                       | 0x0030 |
| * WhitePointY                                                       | 0x0031 |
| * ColorPointRX                                                      | 0x0032 |
| * ColorPointRY                                                      | 0x0033 |
| * ColorPointRIntensity                                              | 0x0034 |
| * ColorPointGX                                                      | 0x0036 |
| * ColorPointGY                                                      | 0x0037 |
| * ColorPointGIntensity                                              | 0x0038 |
| * ColorPointBX                                                      | 0x003A |
| * ColorPointBY                                                      | 0x003B |
| * ColorPointBIntensity                                              | 0x003C |
| * EnhancedCurrentHue                                                | 0x4000 |
| * EnhancedColorMode                                                 | 0x4001 |
| * ColorLoopActive                                                   | 0x4002 |
| * ColorLoopDirection                                                | 0x4003 |
| * ColorLoopTime                                                     | 0x4004 |
| * ColorLoopStartEnhancedHue                                         | 0x4005 |
| * ColorLoopStoredEnhancedHue                                        | 0x4006 |
| * ColorCapabilities                                                 | 0x400A |
| * ColorTempPhysicalMin                                              | 0x400B |
| * ColorTempPhysicalMax                                              | 0x400C |
| * CoupleColorTempToLevelMinMireds                                   | 0x400D |
| * StartUpColorTemperatureMireds                                     | 0x4010 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ColorLoopSet
 */
class ColorControlColorLoopSet : public ModelCommand
{
public:
    ColorControlColorLoopSet() : ModelCommand("color-loop-set")
    {
        AddArgument("UpdateFlags", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags> *>(
                        &mRequest.updateFlags));
        AddArgument("Action", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.action)> *>(&mRequest.action));
        AddArgument("Direction", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.direction)> *>(&mRequest.direction));
        AddArgument("Time", 0, UINT16_MAX, &mRequest.time);
        AddArgument("StartHue", 0, UINT16_MAX, &mRequest.startHue);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000044) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type mRequest;
};

/*
 * Command EnhancedMoveHue
 */
class ColorControlEnhancedMoveHue : public ModelCommand
{
public:
    ColorControlEnhancedMoveHue() : ModelCommand("enhanced-move-hue")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT16_MAX, &mRequest.rate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000041) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type mRequest;
};

/*
 * Command EnhancedMoveToHue
 */
class ColorControlEnhancedMoveToHue : public ModelCommand
{
public:
    ColorControlEnhancedMoveToHue() : ModelCommand("enhanced-move-to-hue")
    {
        AddArgument("EnhancedHue", 0, UINT16_MAX, &mRequest.enhancedHue);
        AddArgument("Direction", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.direction)> *>(&mRequest.direction));
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000040) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type mRequest;
};

/*
 * Command EnhancedMoveToHueAndSaturation
 */
class ColorControlEnhancedMoveToHueAndSaturation : public ModelCommand
{
public:
    ColorControlEnhancedMoveToHueAndSaturation() : ModelCommand("enhanced-move-to-hue-and-saturation")
    {
        AddArgument("EnhancedHue", 0, UINT16_MAX, &mRequest.enhancedHue);
        AddArgument("Saturation", 0, UINT8_MAX, &mRequest.saturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000043) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type mRequest;
};

/*
 * Command EnhancedStepHue
 */
class ColorControlEnhancedStepHue : public ModelCommand
{
public:
    ColorControlEnhancedStepHue() : ModelCommand("enhanced-step-hue")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT16_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000042) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type mRequest;
};

/*
 * Command MoveColor
 */
class ColorControlMoveColor : public ModelCommand
{
public:
    ColorControlMoveColor() : ModelCommand("move-color")
    {
        AddArgument("RateX", INT16_MIN, INT16_MAX, &mRequest.rateX);
        AddArgument("RateY", INT16_MIN, INT16_MAX, &mRequest.rateY);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000008) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveColor::Type mRequest;
};

/*
 * Command MoveColorTemperature
 */
class ColorControlMoveColorTemperature : public ModelCommand
{
public:
    ColorControlMoveColorTemperature() : ModelCommand("move-color-temperature")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT16_MAX, &mRequest.rate);
        AddArgument("ColorTemperatureMinimum", 0, UINT16_MAX, &mRequest.colorTemperatureMinimum);
        AddArgument("ColorTemperatureMaximum", 0, UINT16_MAX, &mRequest.colorTemperatureMaximum);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000004B) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type mRequest;
};

/*
 * Command MoveHue
 */
class ColorControlMoveHue : public ModelCommand
{
public:
    ColorControlMoveHue() : ModelCommand("move-hue")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT8_MAX, &mRequest.rate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveHue::Type mRequest;
};

/*
 * Command MoveSaturation
 */
class ColorControlMoveSaturation : public ModelCommand
{
public:
    ColorControlMoveSaturation() : ModelCommand("move-saturation")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT8_MAX, &mRequest.rate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type mRequest;
};

/*
 * Command MoveToColor
 */
class ColorControlMoveToColor : public ModelCommand
{
public:
    ColorControlMoveToColor() : ModelCommand("move-to-color")
    {
        AddArgument("ColorX", 0, UINT16_MAX, &mRequest.colorX);
        AddArgument("ColorY", 0, UINT16_MAX, &mRequest.colorY);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000007) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveToColor::Type mRequest;
};

/*
 * Command MoveToColorTemperature
 */
class ColorControlMoveToColorTemperature : public ModelCommand
{
public:
    ColorControlMoveToColorTemperature() : ModelCommand("move-to-color-temperature")
    {
        AddArgument("ColorTemperature", 0, UINT16_MAX, &mRequest.colorTemperature);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000000A) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type mRequest;
};

/*
 * Command MoveToHue
 */
class ColorControlMoveToHue : public ModelCommand
{
public:
    ColorControlMoveToHue() : ModelCommand("move-to-hue")
    {
        AddArgument("Hue", 0, UINT8_MAX, &mRequest.hue);
        AddArgument("Direction", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.direction)> *>(&mRequest.direction));
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveToHue::Type mRequest;
};

/*
 * Command MoveToHueAndSaturation
 */
class ColorControlMoveToHueAndSaturation : public ModelCommand
{
public:
    ColorControlMoveToHueAndSaturation() : ModelCommand("move-to-hue-and-saturation")
    {
        AddArgument("Hue", 0, UINT8_MAX, &mRequest.hue);
        AddArgument("Saturation", 0, UINT8_MAX, &mRequest.saturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000006) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type mRequest;
};

/*
 * Command MoveToSaturation
 */
class ColorControlMoveToSaturation : public ModelCommand
{
public:
    ColorControlMoveToSaturation() : ModelCommand("move-to-saturation")
    {
        AddArgument("Saturation", 0, UINT8_MAX, &mRequest.saturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000003) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type mRequest;
};

/*
 * Command StepColor
 */
class ColorControlStepColor : public ModelCommand
{
public:
    ColorControlStepColor() : ModelCommand("step-color")
    {
        AddArgument("StepX", INT16_MIN, INT16_MAX, &mRequest.stepX);
        AddArgument("StepY", INT16_MIN, INT16_MAX, &mRequest.stepY);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000009) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::StepColor::Type mRequest;
};

/*
 * Command StepColorTemperature
 */
class ColorControlStepColorTemperature : public ModelCommand
{
public:
    ColorControlStepColorTemperature() : ModelCommand("step-color-temperature")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT16_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("ColorTemperatureMinimum", 0, UINT16_MAX, &mRequest.colorTemperatureMinimum);
        AddArgument("ColorTemperatureMaximum", 0, UINT16_MAX, &mRequest.colorTemperatureMaximum);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000004C) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type mRequest;
};

/*
 * Command StepHue
 */
class ColorControlStepHue : public ModelCommand
{
public:
    ColorControlStepHue() : ModelCommand("step-hue")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT8_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT8_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::StepHue::Type mRequest;
};

/*
 * Command StepSaturation
 */
class ColorControlStepSaturation : public ModelCommand
{
public:
    ColorControlStepSaturation() : ModelCommand("step-saturation")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT8_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT8_MAX, &mRequest.transitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000005) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::StepSaturation::Type mRequest;
};

/*
 * Command StopMoveStep
 */
class ColorControlStopMoveStep : public ModelCommand
{
public:
    ColorControlStopMoveStep() : ModelCommand("stop-move-step")
    {
        AddArgument("OptionsMask", 0, UINT8_MAX, &mRequest.optionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mRequest.optionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000047) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type mRequest;
};

/*
 * Attribute CurrentHue
 */
class ReadColorControlCurrentHue : public ModelCommand
{
public:
    ReadColorControlCurrentHue() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentHue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentHue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlCurrentHue : public ModelCommand
{
public:
    ReportColorControlCurrentHue() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentHue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentHue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentHue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentSaturation
 */
class ReadColorControlCurrentSaturation : public ModelCommand
{
public:
    ReadColorControlCurrentSaturation() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-saturation");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentSaturation()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentSaturation(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlCurrentSaturation : public ModelCommand
{
public:
    ReportColorControlCurrentSaturation() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-saturation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentSaturation()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentSaturation(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentSaturation(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RemainingTime
 */
class ReadColorControlRemainingTime : public ModelCommand
{
public:
    ReadColorControlRemainingTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlRemainingTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRemainingTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlRemainingTime : public ModelCommand
{
public:
    ReportColorControlRemainingTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "remaining-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlRemainingTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRemainingTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRemainingTime(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentX
 */
class ReadColorControlCurrentX : public ModelCommand
{
public:
    ReadColorControlCurrentX() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentX()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentX(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlCurrentX : public ModelCommand
{
public:
    ReportColorControlCurrentX() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentX()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentX(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentX(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentY
 */
class ReadColorControlCurrentY : public ModelCommand
{
public:
    ReadColorControlCurrentY() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentY()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentY(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlCurrentY : public ModelCommand
{
public:
    ReportColorControlCurrentY() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentY()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentY(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentY(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DriftCompensation
 */
class ReadColorControlDriftCompensation : public ModelCommand
{
public:
    ReadColorControlDriftCompensation() : ModelCommand("read")
    {
        AddArgument("attr-name", "drift-compensation");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlDriftCompensation()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeDriftCompensation(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlDriftCompensation : public ModelCommand
{
public:
    ReportColorControlDriftCompensation() : ModelCommand("report")
    {
        AddArgument("attr-name", "drift-compensation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlDriftCompensation()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeDriftCompensation(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeDriftCompensation(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CompensationText
 */
class ReadColorControlCompensationText : public ModelCommand
{
public:
    ReadColorControlCompensationText() : ModelCommand("read")
    {
        AddArgument("attr-name", "compensation-text");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCompensationText()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCompensationText(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlCompensationText : public ModelCommand
{
public:
    ReportColorControlCompensationText() : ModelCommand("report")
    {
        AddArgument("attr-name", "compensation-text");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCompensationText()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCompensationText(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCompensationText(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTemperature
 */
class ReadColorControlColorTemperature : public ModelCommand
{
public:
    ReadColorControlColorTemperature() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temperature");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTemperature()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorTemperature(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlColorTemperature : public ModelCommand
{
public:
    ReportColorControlColorTemperature() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-temperature");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorTemperature()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorTemperature(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorTemperature(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorMode
 */
class ReadColorControlColorMode : public ModelCommand
{
public:
    ReadColorControlColorMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-mode");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlColorMode : public ModelCommand
{
public:
    ReportColorControlColorMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorMode(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorControlOptions
 */
class ReadColorControlColorControlOptions : public ModelCommand
{
public:
    ReadColorControlColorControlOptions() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-control-options");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorControlOptions()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorControlOptions(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlColorControlOptions : public ModelCommand
{
public:
    WriteColorControlColorControlOptions() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-control-options");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorControlOptions()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeColorControlOptions(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportColorControlColorControlOptions : public ModelCommand
{
public:
    ReportColorControlColorControlOptions() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-control-options");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorControlOptions()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorControlOptions(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorControlOptions(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfPrimaries
 */
class ReadColorControlNumberOfPrimaries : public ModelCommand
{
public:
    ReadColorControlNumberOfPrimaries() : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-primaries");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlNumberOfPrimaries()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNumberOfPrimaries(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlNumberOfPrimaries : public ModelCommand
{
public:
    ReportColorControlNumberOfPrimaries() : ModelCommand("report")
    {
        AddArgument("attr-name", "number-of-primaries");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlNumberOfPrimaries()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNumberOfPrimaries(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNumberOfPrimaries(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1X
 */
class ReadColorControlPrimary1X : public ModelCommand
{
public:
    ReadColorControlPrimary1X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1X()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary1X(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary1X : public ModelCommand
{
public:
    ReportColorControlPrimary1X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary1x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary1X()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary1X(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary1X(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1Y
 */
class ReadColorControlPrimary1Y : public ModelCommand
{
public:
    ReadColorControlPrimary1Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1Y()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary1Y(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary1Y : public ModelCommand
{
public:
    ReportColorControlPrimary1Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary1y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary1Y()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary1Y(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary1Y(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1Intensity
 */
class ReadColorControlPrimary1Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary1Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1Intensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary1Intensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary1Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary1Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary1intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary1Intensity()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary1Intensity(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary1Intensity(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2X
 */
class ReadColorControlPrimary2X : public ModelCommand
{
public:
    ReadColorControlPrimary2X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2X()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary2X(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary2X : public ModelCommand
{
public:
    ReportColorControlPrimary2X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary2x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary2X()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary2X(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary2X(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2Y
 */
class ReadColorControlPrimary2Y : public ModelCommand
{
public:
    ReadColorControlPrimary2Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2Y()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary2Y(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary2Y : public ModelCommand
{
public:
    ReportColorControlPrimary2Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary2y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary2Y()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary2Y(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary2Y(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2Intensity
 */
class ReadColorControlPrimary2Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary2Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2Intensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary2Intensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary2Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary2Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary2intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary2Intensity()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary2Intensity(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary2Intensity(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3X
 */
class ReadColorControlPrimary3X : public ModelCommand
{
public:
    ReadColorControlPrimary3X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3X()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary3X(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary3X : public ModelCommand
{
public:
    ReportColorControlPrimary3X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary3x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary3X()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary3X(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary3X(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3Y
 */
class ReadColorControlPrimary3Y : public ModelCommand
{
public:
    ReadColorControlPrimary3Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3Y()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary3Y(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary3Y : public ModelCommand
{
public:
    ReportColorControlPrimary3Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary3y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary3Y()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary3Y(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary3Y(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3Intensity
 */
class ReadColorControlPrimary3Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary3Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3Intensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary3Intensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary3Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary3Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary3intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary3Intensity()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary3Intensity(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary3Intensity(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4X
 */
class ReadColorControlPrimary4X : public ModelCommand
{
public:
    ReadColorControlPrimary4X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4X()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary4X(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary4X : public ModelCommand
{
public:
    ReportColorControlPrimary4X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary4x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary4X()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary4X(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary4X(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4Y
 */
class ReadColorControlPrimary4Y : public ModelCommand
{
public:
    ReadColorControlPrimary4Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4Y()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary4Y(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary4Y : public ModelCommand
{
public:
    ReportColorControlPrimary4Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary4y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary4Y()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary4Y(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary4Y(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4Intensity
 */
class ReadColorControlPrimary4Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary4Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4Intensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary4Intensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary4Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary4Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary4intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary4Intensity()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary4Intensity(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary4Intensity(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5X
 */
class ReadColorControlPrimary5X : public ModelCommand
{
public:
    ReadColorControlPrimary5X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5X()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary5X(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary5X : public ModelCommand
{
public:
    ReportColorControlPrimary5X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary5x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary5X()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary5X(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary5X(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5Y
 */
class ReadColorControlPrimary5Y : public ModelCommand
{
public:
    ReadColorControlPrimary5Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5Y()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary5Y(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary5Y : public ModelCommand
{
public:
    ReportColorControlPrimary5Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary5y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary5Y()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary5Y(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary5Y(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5Intensity
 */
class ReadColorControlPrimary5Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary5Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5Intensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary5Intensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary5Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary5Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary5intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary5Intensity()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary5Intensity(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary5Intensity(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6X
 */
class ReadColorControlPrimary6X : public ModelCommand
{
public:
    ReadColorControlPrimary6X() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6X()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary6X(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary6X : public ModelCommand
{
public:
    ReportColorControlPrimary6X() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary6x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary6X()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary6X(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary6X(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6Y
 */
class ReadColorControlPrimary6Y : public ModelCommand
{
public:
    ReadColorControlPrimary6Y() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6Y()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary6Y(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary6Y : public ModelCommand
{
public:
    ReportColorControlPrimary6Y() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary6y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary6Y()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary6Y(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary6Y(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6Intensity
 */
class ReadColorControlPrimary6Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary6Intensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6Intensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePrimary6Intensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlPrimary6Intensity : public ModelCommand
{
public:
    ReportColorControlPrimary6Intensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "primary6intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary6Intensity()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePrimary6Intensity(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePrimary6Intensity(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WhitePointX
 */
class ReadColorControlWhitePointX : public ModelCommand
{
public:
    ReadColorControlWhitePointX() : ModelCommand("read")
    {
        AddArgument("attr-name", "white-point-x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWhitePointX()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeWhitePointX(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlWhitePointX : public ModelCommand
{
public:
    WriteColorControlWhitePointX() : ModelCommand("write")
    {
        AddArgument("attr-name", "white-point-x");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlWhitePointX()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeWhitePointX(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportColorControlWhitePointX : public ModelCommand
{
public:
    ReportColorControlWhitePointX() : ModelCommand("report")
    {
        AddArgument("attr-name", "white-point-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlWhitePointX()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeWhitePointX(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeWhitePointX(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WhitePointY
 */
class ReadColorControlWhitePointY : public ModelCommand
{
public:
    ReadColorControlWhitePointY() : ModelCommand("read")
    {
        AddArgument("attr-name", "white-point-y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWhitePointY()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeWhitePointY(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlWhitePointY : public ModelCommand
{
public:
    WriteColorControlWhitePointY() : ModelCommand("write")
    {
        AddArgument("attr-name", "white-point-y");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlWhitePointY()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeWhitePointY(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportColorControlWhitePointY : public ModelCommand
{
public:
    ReportColorControlWhitePointY() : ModelCommand("report")
    {
        AddArgument("attr-name", "white-point-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlWhitePointY()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeWhitePointY(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeWhitePointY(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRX
 */
class ReadColorControlColorPointRX : public ModelCommand
{
public:
    ReadColorControlColorPointRX() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-rx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRX()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorPointRX(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlColorPointRX : public ModelCommand
{
public:
    WriteColorControlColorPointRX() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-rx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRX()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeColorPointRX(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportColorControlColorPointRX : public ModelCommand
{
public:
    ReportColorControlColorPointRX() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-rx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointRX()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorPointRX(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorPointRX(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRY
 */
class ReadColorControlColorPointRY : public ModelCommand
{
public:
    ReadColorControlColorPointRY() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-ry");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRY()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorPointRY(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlColorPointRY : public ModelCommand
{
public:
    WriteColorControlColorPointRY() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-ry");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRY()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeColorPointRY(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportColorControlColorPointRY : public ModelCommand
{
public:
    ReportColorControlColorPointRY() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-ry");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointRY()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorPointRY(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorPointRY(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRIntensity
 */
class ReadColorControlColorPointRIntensity : public ModelCommand
{
public:
    ReadColorControlColorPointRIntensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-rintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRIntensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorPointRIntensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlColorPointRIntensity : public ModelCommand
{
public:
    WriteColorControlColorPointRIntensity() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-rintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRIntensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeColorPointRIntensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportColorControlColorPointRIntensity : public ModelCommand
{
public:
    ReportColorControlColorPointRIntensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-rintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointRIntensity()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorPointRIntensity(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorPointRIntensity(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGX
 */
class ReadColorControlColorPointGX : public ModelCommand
{
public:
    ReadColorControlColorPointGX() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGX()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorPointGX(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlColorPointGX : public ModelCommand
{
public:
    WriteColorControlColorPointGX() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGX()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeColorPointGX(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportColorControlColorPointGX : public ModelCommand
{
public:
    ReportColorControlColorPointGX() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-gx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointGX()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorPointGX(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorPointGX(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGY
 */
class ReadColorControlColorPointGY : public ModelCommand
{
public:
    ReadColorControlColorPointGY() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gy");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGY()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorPointGY(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlColorPointGY : public ModelCommand
{
public:
    WriteColorControlColorPointGY() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gy");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGY()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeColorPointGY(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportColorControlColorPointGY : public ModelCommand
{
public:
    ReportColorControlColorPointGY() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-gy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointGY()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorPointGY(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorPointGY(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGIntensity
 */
class ReadColorControlColorPointGIntensity : public ModelCommand
{
public:
    ReadColorControlColorPointGIntensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGIntensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorPointGIntensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlColorPointGIntensity : public ModelCommand
{
public:
    WriteColorControlColorPointGIntensity() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGIntensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeColorPointGIntensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportColorControlColorPointGIntensity : public ModelCommand
{
public:
    ReportColorControlColorPointGIntensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-gintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointGIntensity()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorPointGIntensity(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorPointGIntensity(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBX
 */
class ReadColorControlColorPointBX : public ModelCommand
{
public:
    ReadColorControlColorPointBX() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-bx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBX()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorPointBX(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlColorPointBX : public ModelCommand
{
public:
    WriteColorControlColorPointBX() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-bx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBX()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeColorPointBX(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportColorControlColorPointBX : public ModelCommand
{
public:
    ReportColorControlColorPointBX() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-bx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointBX()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorPointBX(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorPointBX(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBY
 */
class ReadColorControlColorPointBY : public ModelCommand
{
public:
    ReadColorControlColorPointBY() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-by");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBY()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorPointBY(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlColorPointBY : public ModelCommand
{
public:
    WriteColorControlColorPointBY() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-by");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBY()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeColorPointBY(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportColorControlColorPointBY : public ModelCommand
{
public:
    ReportColorControlColorPointBY() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-by");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointBY()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorPointBY(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorPointBY(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBIntensity
 */
class ReadColorControlColorPointBIntensity : public ModelCommand
{
public:
    ReadColorControlColorPointBIntensity() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-bintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBIntensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorPointBIntensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlColorPointBIntensity : public ModelCommand
{
public:
    WriteColorControlColorPointBIntensity() : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-bintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBIntensity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeColorPointBIntensity(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportColorControlColorPointBIntensity : public ModelCommand
{
public:
    ReportColorControlColorPointBIntensity() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-point-bintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointBIntensity()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorPointBIntensity(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorPointBIntensity(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnhancedCurrentHue
 */
class ReadColorControlEnhancedCurrentHue : public ModelCommand
{
public:
    ReadColorControlEnhancedCurrentHue() : ModelCommand("read")
    {
        AddArgument("attr-name", "enhanced-current-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlEnhancedCurrentHue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeEnhancedCurrentHue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlEnhancedCurrentHue : public ModelCommand
{
public:
    ReportColorControlEnhancedCurrentHue() : ModelCommand("report")
    {
        AddArgument("attr-name", "enhanced-current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlEnhancedCurrentHue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeEnhancedCurrentHue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeEnhancedCurrentHue(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnhancedColorMode
 */
class ReadColorControlEnhancedColorMode : public ModelCommand
{
public:
    ReadColorControlEnhancedColorMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "enhanced-color-mode");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlEnhancedColorMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeEnhancedColorMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlEnhancedColorMode : public ModelCommand
{
public:
    ReportColorControlEnhancedColorMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "enhanced-color-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlEnhancedColorMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeEnhancedColorMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeEnhancedColorMode(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopActive
 */
class ReadColorControlColorLoopActive : public ModelCommand
{
public:
    ReadColorControlColorLoopActive() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-active");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopActive()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorLoopActive(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlColorLoopActive : public ModelCommand
{
public:
    ReportColorControlColorLoopActive() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-loop-active");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopActive()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorLoopActive(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorLoopActive(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopDirection
 */
class ReadColorControlColorLoopDirection : public ModelCommand
{
public:
    ReadColorControlColorLoopDirection() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-direction");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopDirection()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorLoopDirection(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlColorLoopDirection : public ModelCommand
{
public:
    ReportColorControlColorLoopDirection() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-loop-direction");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopDirection()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorLoopDirection(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorLoopDirection(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopTime
 */
class ReadColorControlColorLoopTime : public ModelCommand
{
public:
    ReadColorControlColorLoopTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-time");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorLoopTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlColorLoopTime : public ModelCommand
{
public:
    ReportColorControlColorLoopTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-loop-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorLoopTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorLoopTime(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopStartEnhancedHue
 */
class ReadColorControlColorLoopStartEnhancedHue : public ModelCommand
{
public:
    ReadColorControlColorLoopStartEnhancedHue() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopStartEnhancedHue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorLoopStartEnhancedHue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlColorLoopStartEnhancedHue : public ModelCommand
{
public:
    ReportColorControlColorLoopStartEnhancedHue() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopStartEnhancedHue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorLoopStartEnhancedHue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorLoopStartEnhancedHue(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                   mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopStoredEnhancedHue
 */
class ReadColorControlColorLoopStoredEnhancedHue : public ModelCommand
{
public:
    ReadColorControlColorLoopStoredEnhancedHue() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopStoredEnhancedHue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorLoopStoredEnhancedHue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlColorLoopStoredEnhancedHue : public ModelCommand
{
public:
    ReportColorControlColorLoopStoredEnhancedHue() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopStoredEnhancedHue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorLoopStoredEnhancedHue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorLoopStoredEnhancedHue(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                    mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorCapabilities
 */
class ReadColorControlColorCapabilities : public ModelCommand
{
public:
    ReadColorControlColorCapabilities() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-capabilities");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorCapabilities()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorCapabilities(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlColorCapabilities : public ModelCommand
{
public:
    ReportColorControlColorCapabilities() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-capabilities");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorCapabilities()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorCapabilities(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorCapabilities(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTempPhysicalMin
 */
class ReadColorControlColorTempPhysicalMin : public ModelCommand
{
public:
    ReadColorControlColorTempPhysicalMin() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temp-physical-min");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTempPhysicalMin()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorTempPhysicalMin(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlColorTempPhysicalMin : public ModelCommand
{
public:
    ReportColorControlColorTempPhysicalMin() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-temp-physical-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorTempPhysicalMin()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorTempPhysicalMin(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorTempPhysicalMin(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTempPhysicalMax
 */
class ReadColorControlColorTempPhysicalMax : public ModelCommand
{
public:
    ReadColorControlColorTempPhysicalMax() : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temp-physical-max");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTempPhysicalMax()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeColorTempPhysicalMax(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlColorTempPhysicalMax : public ModelCommand
{
public:
    ReportColorControlColorTempPhysicalMax() : ModelCommand("report")
    {
        AddArgument("attr-name", "color-temp-physical-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorTempPhysicalMax()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeColorTempPhysicalMax(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeColorTempPhysicalMax(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CoupleColorTempToLevelMinMireds
 */
class ReadColorControlCoupleColorTempToLevelMinMireds : public ModelCommand
{
public:
    ReadColorControlCoupleColorTempToLevelMinMireds() : ModelCommand("read")
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCoupleColorTempToLevelMinMireds()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCoupleColorTempToLevelMinMireds(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlCoupleColorTempToLevelMinMireds : public ModelCommand
{
public:
    ReportColorControlCoupleColorTempToLevelMinMireds() : ModelCommand("report")
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCoupleColorTempToLevelMinMireds()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCoupleColorTempToLevelMinMireds(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCoupleColorTempToLevelMinMireds(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                         mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpColorTemperatureMireds
 */
class ReadColorControlStartUpColorTemperatureMireds : public ModelCommand
{
public:
    ReadColorControlStartUpColorTemperatureMireds() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlStartUpColorTemperatureMireds()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeStartUpColorTemperatureMireds(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteColorControlStartUpColorTemperatureMireds : public ModelCommand
{
public:
    WriteColorControlStartUpColorTemperatureMireds() : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlStartUpColorTemperatureMireds()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeStartUpColorTemperatureMireds(onSuccessCallback->Cancel(), onFailureCallback->Cancel(),
                                                                   mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportColorControlStartUpColorTemperatureMireds : public ModelCommand
{
public:
    ReportColorControlStartUpColorTemperatureMireds() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlStartUpColorTemperatureMireds()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeStartUpColorTemperatureMireds(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeStartUpColorTemperatureMireds(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                       mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadColorControlClusterRevision : public ModelCommand
{
public:
    ReadColorControlClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportColorControlClusterRevision : public ModelCommand
{
public:
    ReportColorControlClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0300) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ColorControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ContentLauncher                                             | 0x050A |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * LaunchContent                                                     |   0x00 |
| * LaunchURL                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AcceptsHeaderList                                                 | 0x0000 |
| * SupportedStreamingTypes                                           | 0x0001 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command LaunchContent
 */
class ContentLauncherLaunchContent : public ModelCommand
{
public:
    ContentLauncherLaunchContent() : ModelCommand("launch-content")
    {
        AddArgument("AutoPlay", 0, 1, &mRequest.autoPlay);
        AddArgument("Data", &mRequest.data);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnContentLauncherLaunchContentResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type mRequest;
};

/*
 * Command LaunchURL
 */
class ContentLauncherLaunchURL : public ModelCommand
{
public:
    ContentLauncherLaunchURL() : ModelCommand("launch-url")
    {
        AddArgument("ContentURL", &mRequest.contentURL);
        AddArgument("DisplayString", &mRequest.displayString);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnContentLauncherLaunchURLResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type mRequest;
};

/*
 * Attribute AcceptsHeaderList
 */
class ReadContentLauncherAcceptsHeaderList : public ModelCommand
{
public:
    ReadContentLauncherAcceptsHeaderList() : ModelCommand("read")
    {
        AddArgument("attr-name", "accepts-header-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherAcceptsHeaderList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050A) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ContentLauncherCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeAcceptsHeaderList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<ContentLauncherAcceptsHeaderListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<ContentLauncherAcceptsHeaderListListAttributeCallback>(
            OnContentLauncherAcceptsHeaderListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute SupportedStreamingTypes
 */
class ReadContentLauncherSupportedStreamingTypes : public ModelCommand
{
public:
    ReadContentLauncherSupportedStreamingTypes() : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-streaming-types");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherSupportedStreamingTypes()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050A) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ContentLauncherCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSupportedStreamingTypes(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<ContentLauncherSupportedStreamingTypesListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<ContentLauncherSupportedStreamingTypesListAttributeCallback>(
            OnContentLauncherSupportedStreamingTypesListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ClusterRevision
 */
class ReadContentLauncherClusterRevision : public ModelCommand
{
public:
    ReadContentLauncherClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050A) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ContentLauncherCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportContentLauncherClusterRevision : public ModelCommand
{
public:
    ReportContentLauncherClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050A) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ContentLauncherCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Descriptor                                                  | 0x001D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DeviceList                                                        | 0x0000 |
| * ServerList                                                        | 0x0001 |
| * ClientList                                                        | 0x0002 |
| * PartsList                                                         | 0x0003 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute DeviceList
 */
class ReadDescriptorDeviceList : public ModelCommand
{
public:
    ReadDescriptorDeviceList() : ModelCommand("read")
    {
        AddArgument("attr-name", "device-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorDeviceList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x001D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::DescriptorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeDeviceList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<DescriptorDeviceListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<DescriptorDeviceListListAttributeCallback>(OnDescriptorDeviceListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ServerList
 */
class ReadDescriptorServerList : public ModelCommand
{
public:
    ReadDescriptorServerList() : ModelCommand("read")
    {
        AddArgument("attr-name", "server-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorServerList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x001D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::DescriptorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeServerList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<DescriptorServerListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<DescriptorServerListListAttributeCallback>(OnDescriptorServerListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ClientList
 */
class ReadDescriptorClientList : public ModelCommand
{
public:
    ReadDescriptorClientList() : ModelCommand("read")
    {
        AddArgument("attr-name", "client-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClientList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x001D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::DescriptorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClientList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<DescriptorClientListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<DescriptorClientListListAttributeCallback>(OnDescriptorClientListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute PartsList
 */
class ReadDescriptorPartsList : public ModelCommand
{
public:
    ReadDescriptorPartsList() : ModelCommand("read")
    {
        AddArgument("attr-name", "parts-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorPartsList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x001D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::DescriptorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePartsList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<DescriptorPartsListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<DescriptorPartsListListAttributeCallback>(OnDescriptorPartsListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ClusterRevision
 */
class ReadDescriptorClusterRevision : public ModelCommand
{
public:
    ReadDescriptorClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x001D) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::DescriptorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportDescriptorClusterRevision : public ModelCommand
{
public:
    ReportDescriptorClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x001D) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::DescriptorCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster DiagnosticLogs                                              | 0x0032 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * RetrieveLogsRequest                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
\*----------------------------------------------------------------------------*/

/*
 * Command RetrieveLogsRequest
 */
class DiagnosticLogsRetrieveLogsRequest : public ModelCommand
{
public:
    DiagnosticLogsRetrieveLogsRequest() : ModelCommand("retrieve-logs-request")
    {
        AddArgument("Intent", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.intent)> *>(&mRequest.intent));
        AddArgument("RequestedProtocol", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.requestedProtocol)> *>(&mRequest.requestedProtocol));
        AddArgument("TransferFileDesignator", &mRequest.transferFileDesignator);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDiagnosticLogsRetrieveLogsResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DiagnosticLogs::Commands::RetrieveLogsRequest::Type mRequest;
};

/*----------------------------------------------------------------------------*\
| Cluster DoorLock                                                    | 0x0101 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ClearAllPins                                                      |   0x08 |
| * ClearAllRfids                                                     |   0x19 |
| * ClearHolidaySchedule                                              |   0x13 |
| * ClearPin                                                          |   0x07 |
| * ClearRfid                                                         |   0x18 |
| * ClearWeekdaySchedule                                              |   0x0D |
| * ClearYeardaySchedule                                              |   0x10 |
| * GetHolidaySchedule                                                |   0x12 |
| * GetLogRecord                                                      |   0x04 |
| * GetPin                                                            |   0x06 |
| * GetRfid                                                           |   0x17 |
| * GetUserType                                                       |   0x15 |
| * GetWeekdaySchedule                                                |   0x0C |
| * GetYeardaySchedule                                                |   0x0F |
| * LockDoor                                                          |   0x00 |
| * SetHolidaySchedule                                                |   0x11 |
| * SetPin                                                            |   0x05 |
| * SetRfid                                                           |   0x16 |
| * SetUserType                                                       |   0x14 |
| * SetWeekdaySchedule                                                |   0x0B |
| * SetYeardaySchedule                                                |   0x0E |
| * UnlockDoor                                                        |   0x01 |
| * UnlockWithTimeout                                                 |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LockState                                                         | 0x0000 |
| * LockType                                                          | 0x0001 |
| * ActuatorEnabled                                                   | 0x0002 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ClearAllPins
 */
class DoorLockClearAllPins : public ModelCommand
{
public:
    DoorLockClearAllPins() : ModelCommand("clear-all-pins") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000008) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockClearAllPinsResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::ClearAllPins::Type mRequest;
};

/*
 * Command ClearAllRfids
 */
class DoorLockClearAllRfids : public ModelCommand
{
public:
    DoorLockClearAllRfids() : ModelCommand("clear-all-rfids") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000019) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockClearAllRfidsResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::ClearAllRfids::Type mRequest;
};

/*
 * Command ClearHolidaySchedule
 */
class DoorLockClearHolidaySchedule : public ModelCommand
{
public:
    DoorLockClearHolidaySchedule() : ModelCommand("clear-holiday-schedule")
    {
        AddArgument("ScheduleId", 0, UINT8_MAX, &mRequest.scheduleId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000013) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockClearHolidayScheduleResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::ClearHolidaySchedule::Type mRequest;
};

/*
 * Command ClearPin
 */
class DoorLockClearPin : public ModelCommand
{
public:
    DoorLockClearPin() : ModelCommand("clear-pin")
    {
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000007) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockClearPinResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::ClearPin::Type mRequest;
};

/*
 * Command ClearRfid
 */
class DoorLockClearRfid : public ModelCommand
{
public:
    DoorLockClearRfid() : ModelCommand("clear-rfid")
    {
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000018) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockClearRfidResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::ClearRfid::Type mRequest;
};

/*
 * Command ClearWeekdaySchedule
 */
class DoorLockClearWeekdaySchedule : public ModelCommand
{
public:
    DoorLockClearWeekdaySchedule() : ModelCommand("clear-weekday-schedule")
    {
        AddArgument("ScheduleId", 0, UINT8_MAX, &mRequest.scheduleId);
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000D) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockClearWeekdayScheduleResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::ClearWeekdaySchedule::Type mRequest;
};

/*
 * Command ClearYeardaySchedule
 */
class DoorLockClearYeardaySchedule : public ModelCommand
{
public:
    DoorLockClearYeardaySchedule() : ModelCommand("clear-yearday-schedule")
    {
        AddArgument("ScheduleId", 0, UINT8_MAX, &mRequest.scheduleId);
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000010) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockClearYeardayScheduleResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::ClearYeardaySchedule::Type mRequest;
};

/*
 * Command GetHolidaySchedule
 */
class DoorLockGetHolidaySchedule : public ModelCommand
{
public:
    DoorLockGetHolidaySchedule() : ModelCommand("get-holiday-schedule")
    {
        AddArgument("ScheduleId", 0, UINT8_MAX, &mRequest.scheduleId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000012) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockGetHolidayScheduleResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::GetHolidaySchedule::Type mRequest;
};

/*
 * Command GetLogRecord
 */
class DoorLockGetLogRecord : public ModelCommand
{
public:
    DoorLockGetLogRecord() : ModelCommand("get-log-record")
    {
        AddArgument("LogIndex", 0, UINT16_MAX, &mRequest.logIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockGetLogRecordResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::GetLogRecord::Type mRequest;
};

/*
 * Command GetPin
 */
class DoorLockGetPin : public ModelCommand
{
public:
    DoorLockGetPin() : ModelCommand("get-pin")
    {
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000006) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockGetPinResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::GetPin::Type mRequest;
};

/*
 * Command GetRfid
 */
class DoorLockGetRfid : public ModelCommand
{
public:
    DoorLockGetRfid() : ModelCommand("get-rfid")
    {
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000017) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockGetRfidResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::GetRfid::Type mRequest;
};

/*
 * Command GetUserType
 */
class DoorLockGetUserType : public ModelCommand
{
public:
    DoorLockGetUserType() : ModelCommand("get-user-type")
    {
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000015) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockGetUserTypeResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::GetUserType::Type mRequest;
};

/*
 * Command GetWeekdaySchedule
 */
class DoorLockGetWeekdaySchedule : public ModelCommand
{
public:
    DoorLockGetWeekdaySchedule() : ModelCommand("get-weekday-schedule")
    {
        AddArgument("ScheduleId", 0, UINT8_MAX, &mRequest.scheduleId);
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000C) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockGetWeekdayScheduleResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::GetWeekdaySchedule::Type mRequest;
};

/*
 * Command GetYeardaySchedule
 */
class DoorLockGetYeardaySchedule : public ModelCommand
{
public:
    DoorLockGetYeardaySchedule() : ModelCommand("get-yearday-schedule")
    {
        AddArgument("ScheduleId", 0, UINT8_MAX, &mRequest.scheduleId);
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000F) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockGetYeardayScheduleResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::GetYeardaySchedule::Type mRequest;
};

/*
 * Command LockDoor
 */
class DoorLockLockDoor : public ModelCommand
{
public:
    DoorLockLockDoor() : ModelCommand("lock-door")
    {
        AddArgument("Pin", &mRequest.pin);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockLockDoorResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::LockDoor::Type mRequest;
};

/*
 * Command SetHolidaySchedule
 */
class DoorLockSetHolidaySchedule : public ModelCommand
{
public:
    DoorLockSetHolidaySchedule() : ModelCommand("set-holiday-schedule")
    {
        AddArgument("ScheduleId", 0, UINT8_MAX, &mRequest.scheduleId);
        AddArgument("LocalStartTime", 0, UINT32_MAX, &mRequest.localStartTime);
        AddArgument("LocalEndTime", 0, UINT32_MAX, &mRequest.localEndTime);
        AddArgument("OperatingModeDuringHoliday", 0, UINT8_MAX, &mRequest.operatingModeDuringHoliday);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000011) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockSetHolidayScheduleResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::SetHolidaySchedule::Type mRequest;
};

/*
 * Command SetPin
 */
class DoorLockSetPin : public ModelCommand
{
public:
    DoorLockSetPin() : ModelCommand("set-pin")
    {
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        AddArgument("UserStatus", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.userStatus)> *>(&mRequest.userStatus));
        AddArgument("UserType", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.userType)> *>(&mRequest.userType));
        AddArgument("Pin", &mRequest.pin);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000005) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockSetPinResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::SetPin::Type mRequest;
};

/*
 * Command SetRfid
 */
class DoorLockSetRfid : public ModelCommand
{
public:
    DoorLockSetRfid() : ModelCommand("set-rfid")
    {
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        AddArgument("UserStatus", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.userStatus)> *>(&mRequest.userStatus));
        AddArgument("UserType", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.userType)> *>(&mRequest.userType));
        AddArgument("Id", &mRequest.id);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000016) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockSetRfidResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::SetRfid::Type mRequest;
};

/*
 * Command SetUserType
 */
class DoorLockSetUserType : public ModelCommand
{
public:
    DoorLockSetUserType() : ModelCommand("set-user-type")
    {
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        AddArgument("UserType", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.userType)> *>(&mRequest.userType));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000014) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockSetUserTypeResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::SetUserType::Type mRequest;
};

/*
 * Command SetWeekdaySchedule
 */
class DoorLockSetWeekdaySchedule : public ModelCommand
{
public:
    DoorLockSetWeekdaySchedule() : ModelCommand("set-weekday-schedule")
    {
        AddArgument("ScheduleId", 0, UINT8_MAX, &mRequest.scheduleId);
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        AddArgument(
            "DaysMask", 0, UINT8_MAX,
            reinterpret_cast<std::underlying_type_t<chip::app::Clusters::DoorLock::DoorLockDayOfWeek> *>(&mRequest.daysMask));
        AddArgument("StartHour", 0, UINT8_MAX, &mRequest.startHour);
        AddArgument("StartMinute", 0, UINT8_MAX, &mRequest.startMinute);
        AddArgument("EndHour", 0, UINT8_MAX, &mRequest.endHour);
        AddArgument("EndMinute", 0, UINT8_MAX, &mRequest.endMinute);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000B) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockSetWeekdayScheduleResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::SetWeekdaySchedule::Type mRequest;
};

/*
 * Command SetYeardaySchedule
 */
class DoorLockSetYeardaySchedule : public ModelCommand
{
public:
    DoorLockSetYeardaySchedule() : ModelCommand("set-yearday-schedule")
    {
        AddArgument("ScheduleId", 0, UINT8_MAX, &mRequest.scheduleId);
        AddArgument("UserId", 0, UINT16_MAX, &mRequest.userId);
        AddArgument("LocalStartTime", 0, UINT32_MAX, &mRequest.localStartTime);
        AddArgument("LocalEndTime", 0, UINT32_MAX, &mRequest.localEndTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000E) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockSetYeardayScheduleResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::SetYeardaySchedule::Type mRequest;
};

/*
 * Command UnlockDoor
 */
class DoorLockUnlockDoor : public ModelCommand
{
public:
    DoorLockUnlockDoor() : ModelCommand("unlock-door")
    {
        AddArgument("Pin", &mRequest.pin);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockUnlockDoorResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type mRequest;
};

/*
 * Command UnlockWithTimeout
 */
class DoorLockUnlockWithTimeout : public ModelCommand
{
public:
    DoorLockUnlockWithTimeout() : ModelCommand("unlock-with-timeout")
    {
        AddArgument("TimeoutInSeconds", 0, UINT16_MAX, &mRequest.timeoutInSeconds);
        AddArgument("Pin", &mRequest.pin);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000003) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDoorLockUnlockWithTimeoutResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::DoorLock::Commands::UnlockWithTimeout::Type mRequest;
};

/*
 * Attribute LockState
 */
class ReadDoorLockLockState : public ModelCommand
{
public:
    ReadDoorLockLockState() : ModelCommand("read")
    {
        AddArgument("attr-name", "lock-state");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockState()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0101) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::DoorLockCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLockState(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportDoorLockLockState : public ModelCommand
{
public:
    ReportDoorLockLockState() : ModelCommand("report")
    {
        AddArgument("attr-name", "lock-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockState()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0101) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::DoorLockCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLockState(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLockState(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LockType
 */
class ReadDoorLockLockType : public ModelCommand
{
public:
    ReadDoorLockLockType() : ModelCommand("read")
    {
        AddArgument("attr-name", "lock-type");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockType()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0101) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::DoorLockCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLockType(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportDoorLockLockType : public ModelCommand
{
public:
    ReportDoorLockLockType() : ModelCommand("report")
    {
        AddArgument("attr-name", "lock-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockType()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0101) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::DoorLockCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLockType(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLockType(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActuatorEnabled
 */
class ReadDoorLockActuatorEnabled : public ModelCommand
{
public:
    ReadDoorLockActuatorEnabled() : ModelCommand("read")
    {
        AddArgument("attr-name", "actuator-enabled");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockActuatorEnabled()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0101) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::DoorLockCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActuatorEnabled(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportDoorLockActuatorEnabled : public ModelCommand
{
public:
    ReportDoorLockActuatorEnabled() : ModelCommand("report")
    {
        AddArgument("attr-name", "actuator-enabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockActuatorEnabled()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0101) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::DoorLockCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeActuatorEnabled(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeActuatorEnabled(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadDoorLockClusterRevision : public ModelCommand
{
public:
    ReadDoorLockClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0101) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::DoorLockCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportDoorLockClusterRevision : public ModelCommand
{
public:
    ReportDoorLockClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0101) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::DoorLockCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ElectricalMeasurement                                       | 0x0B04 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasurementType                                                   | 0x0000 |
| * TotalActivePower                                                  | 0x0304 |
| * RmsVoltage                                                        | 0x0505 |
| * RmsVoltageMin                                                     | 0x0506 |
| * RmsVoltageMax                                                     | 0x0507 |
| * RmsCurrent                                                        | 0x0508 |
| * RmsCurrentMin                                                     | 0x0509 |
| * RmsCurrentMax                                                     | 0x050A |
| * ActivePower                                                       | 0x050B |
| * ActivePowerMin                                                    | 0x050C |
| * ActivePowerMax                                                    | 0x050D |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasurementType
 */
class ReadElectricalMeasurementMeasurementType : public ModelCommand
{
public:
    ReadElectricalMeasurementMeasurementType() : ModelCommand("read")
    {
        AddArgument("attr-name", "measurement-type");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementMeasurementType()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMeasurementType(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementMeasurementType : public ModelCommand
{
public:
    ReportElectricalMeasurementMeasurementType() : ModelCommand("report")
    {
        AddArgument("attr-name", "measurement-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementMeasurementType()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMeasurementType(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMeasurementType(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TotalActivePower
 */
class ReadElectricalMeasurementTotalActivePower : public ModelCommand
{
public:
    ReadElectricalMeasurementTotalActivePower() : ModelCommand("read")
    {
        AddArgument("attr-name", "total-active-power");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementTotalActivePower()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTotalActivePower(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32sAttributeCallback>(OnInt32sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementTotalActivePower : public ModelCommand
{
public:
    ReportElectricalMeasurementTotalActivePower() : ModelCommand("report")
    {
        AddArgument("attr-name", "total-active-power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementTotalActivePower()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTotalActivePower(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTotalActivePower(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32sAttributeCallback>(OnInt32sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltage
 */
class ReadElectricalMeasurementRmsVoltage : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsVoltage() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltage()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRmsVoltage(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementRmsVoltage : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsVoltage() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-voltage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsVoltage()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRmsVoltage(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRmsVoltage(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltageMin
 */
class ReadElectricalMeasurementRmsVoltageMin : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsVoltageMin() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltageMin()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRmsVoltageMin(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementRmsVoltageMin : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsVoltageMin() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-voltage-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsVoltageMin()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRmsVoltageMin(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRmsVoltageMin(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltageMax
 */
class ReadElectricalMeasurementRmsVoltageMax : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsVoltageMax() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltageMax()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRmsVoltageMax(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementRmsVoltageMax : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsVoltageMax() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-voltage-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsVoltageMax()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRmsVoltageMax(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRmsVoltageMax(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrent
 */
class ReadElectricalMeasurementRmsCurrent : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsCurrent() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrent()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRmsCurrent(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementRmsCurrent : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsCurrent() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-current");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsCurrent()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRmsCurrent(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRmsCurrent(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrentMin
 */
class ReadElectricalMeasurementRmsCurrentMin : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsCurrentMin() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrentMin()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRmsCurrentMin(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementRmsCurrentMin : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsCurrentMin() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-current-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsCurrentMin()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRmsCurrentMin(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRmsCurrentMin(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrentMax
 */
class ReadElectricalMeasurementRmsCurrentMax : public ModelCommand
{
public:
    ReadElectricalMeasurementRmsCurrentMax() : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrentMax()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRmsCurrentMax(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementRmsCurrentMax : public ModelCommand
{
public:
    ReportElectricalMeasurementRmsCurrentMax() : ModelCommand("report")
    {
        AddArgument("attr-name", "rms-current-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsCurrentMax()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRmsCurrentMax(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRmsCurrentMax(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePower
 */
class ReadElectricalMeasurementActivePower : public ModelCommand
{
public:
    ReadElectricalMeasurementActivePower() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePower()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActivePower(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementActivePower : public ModelCommand
{
public:
    ReportElectricalMeasurementActivePower() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementActivePower()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeActivePower(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeActivePower(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePowerMin
 */
class ReadElectricalMeasurementActivePowerMin : public ModelCommand
{
public:
    ReadElectricalMeasurementActivePowerMin() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePowerMin()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActivePowerMin(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementActivePowerMin : public ModelCommand
{
public:
    ReportElectricalMeasurementActivePowerMin() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-power-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementActivePowerMin()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeActivePowerMin(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeActivePowerMin(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePowerMax
 */
class ReadElectricalMeasurementActivePowerMax : public ModelCommand
{
public:
    ReadElectricalMeasurementActivePowerMax() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePowerMax()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActivePowerMax(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementActivePowerMax : public ModelCommand
{
public:
    ReportElectricalMeasurementActivePowerMax() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-power-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementActivePowerMax()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeActivePowerMax(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeActivePowerMax(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadElectricalMeasurementClusterRevision : public ModelCommand
{
public:
    ReadElectricalMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportElectricalMeasurementClusterRevision : public ModelCommand
{
public:
    ReportElectricalMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0B04) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ElectricalMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster EthernetNetworkDiagnostics                                  | 0x0037 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * PHYRate                                                           | 0x0000 |
| * FullDuplex                                                        | 0x0001 |
| * PacketRxCount                                                     | 0x0002 |
| * PacketTxCount                                                     | 0x0003 |
| * TxErrCount                                                        | 0x0004 |
| * CollisionCount                                                    | 0x0005 |
| * OverrunCount                                                      | 0x0006 |
| * CarrierDetect                                                     | 0x0007 |
| * TimeSinceReset                                                    | 0x0008 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class EthernetNetworkDiagnosticsResetCounts : public ModelCommand
{
public:
    EthernetNetworkDiagnosticsResetCounts() : ModelCommand("reset-counts") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::EthernetNetworkDiagnostics::Commands::ResetCounts::Type mRequest;
};

/*
 * Attribute PHYRate
 */
class ReadEthernetNetworkDiagnosticsPHYRate : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsPHYRate() : ModelCommand("read")
    {
        AddArgument("attr-name", "phyrate");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPHYRate()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePHYRate(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportEthernetNetworkDiagnosticsPHYRate : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsPHYRate() : ModelCommand("report")
    {
        AddArgument("attr-name", "phyrate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsPHYRate()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePHYRate(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePHYRate(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FullDuplex
 */
class ReadEthernetNetworkDiagnosticsFullDuplex : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsFullDuplex() : ModelCommand("read")
    {
        AddArgument("attr-name", "full-duplex");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsFullDuplex()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeFullDuplex(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportEthernetNetworkDiagnosticsFullDuplex : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsFullDuplex() : ModelCommand("report")
    {
        AddArgument("attr-name", "full-duplex");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsFullDuplex()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeFullDuplex(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeFullDuplex(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketRxCount
 */
class ReadEthernetNetworkDiagnosticsPacketRxCount : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsPacketRxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPacketRxCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePacketRxCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportEthernetNetworkDiagnosticsPacketRxCount : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsPacketRxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsPacketRxCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePacketRxCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePacketRxCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketTxCount
 */
class ReadEthernetNetworkDiagnosticsPacketTxCount : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsPacketTxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPacketTxCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePacketTxCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportEthernetNetworkDiagnosticsPacketTxCount : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsPacketTxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsPacketTxCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePacketTxCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePacketTxCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrCount
 */
class ReadEthernetNetworkDiagnosticsTxErrCount : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsTxErrCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsTxErrCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxErrCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportEthernetNetworkDiagnosticsTxErrCount : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsTxErrCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-err-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsTxErrCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxErrCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxErrCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CollisionCount
 */
class ReadEthernetNetworkDiagnosticsCollisionCount : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsCollisionCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "collision-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsCollisionCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCollisionCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportEthernetNetworkDiagnosticsCollisionCount : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsCollisionCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "collision-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsCollisionCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCollisionCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCollisionCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadEthernetNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsOverrunCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsOverrunCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOverrunCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportEthernetNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsOverrunCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsOverrunCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOverrunCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOverrunCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CarrierDetect
 */
class ReadEthernetNetworkDiagnosticsCarrierDetect : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsCarrierDetect() : ModelCommand("read")
    {
        AddArgument("attr-name", "carrier-detect");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsCarrierDetect()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCarrierDetect(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportEthernetNetworkDiagnosticsCarrierDetect : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsCarrierDetect() : ModelCommand("report")
    {
        AddArgument("attr-name", "carrier-detect");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsCarrierDetect()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCarrierDetect(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCarrierDetect(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TimeSinceReset
 */
class ReadEthernetNetworkDiagnosticsTimeSinceReset : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsTimeSinceReset() : ModelCommand("read")
    {
        AddArgument("attr-name", "time-since-reset");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsTimeSinceReset()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTimeSinceReset(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportEthernetNetworkDiagnosticsTimeSinceReset : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsTimeSinceReset() : ModelCommand("report")
    {
        AddArgument("attr-name", "time-since-reset");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsTimeSinceReset()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTimeSinceReset(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTimeSinceReset(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadEthernetNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReadEthernetNetworkDiagnosticsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportEthernetNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReportEthernetNetworkDiagnosticsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0037) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::EthernetNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FixedLabel                                                  | 0x0040 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LabelList                                                         | 0x0000 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute LabelList
 */
class ReadFixedLabelLabelList : public ModelCommand
{
public:
    ReadFixedLabelLabelList() : ModelCommand("read")
    {
        AddArgument("attr-name", "label-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelLabelList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0040) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::FixedLabelCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLabelList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<FixedLabelLabelListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<FixedLabelLabelListListAttributeCallback>(OnFixedLabelLabelListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ClusterRevision
 */
class ReadFixedLabelClusterRevision : public ModelCommand
{
public:
    ReadFixedLabelClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0040) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::FixedLabelCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportFixedLabelClusterRevision : public ModelCommand
{
public:
    ReportFixedLabelClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFixedLabelClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0040) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::FixedLabelCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FlowMeasurement                                             | 0x0404 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadFlowMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadFlowMeasurementMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0404) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::FlowMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportFlowMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportFlowMeasurementMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0404) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::FlowMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadFlowMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadFlowMeasurementMinMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMinMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0404) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::FlowMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportFlowMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReportFlowMeasurementMinMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementMinMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0404) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::FlowMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadFlowMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadFlowMeasurementMaxMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMaxMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0404) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::FlowMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportFlowMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReportFlowMeasurementMaxMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementMaxMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0404) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::FlowMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadFlowMeasurementTolerance : public ModelCommand
{
public:
    ReadFlowMeasurementTolerance() : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementTolerance()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0404) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::FlowMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTolerance(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportFlowMeasurementTolerance : public ModelCommand
{
public:
    ReportFlowMeasurementTolerance() : ModelCommand("report")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementTolerance()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0404) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::FlowMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTolerance(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTolerance(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadFlowMeasurementClusterRevision : public ModelCommand
{
public:
    ReadFlowMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0404) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::FlowMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportFlowMeasurementClusterRevision : public ModelCommand
{
public:
    ReportFlowMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0404) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::FlowMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GeneralCommissioning                                        | 0x0030 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ArmFailSafe                                                       |   0x00 |
| * CommissioningComplete                                             |   0x04 |
| * SetRegulatoryConfig                                               |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Breadcrumb                                                        | 0x0000 |
| * BasicCommissioningInfoList                                        | 0x0001 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ArmFailSafe
 */
class GeneralCommissioningArmFailSafe : public ModelCommand
{
public:
    GeneralCommissioningArmFailSafe() : ModelCommand("arm-fail-safe")
    {
        AddArgument("ExpiryLengthSeconds", 0, UINT16_MAX, &mRequest.expiryLengthSeconds);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGeneralCommissioningArmFailSafeResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafe::Type mRequest;
};

/*
 * Command CommissioningComplete
 */
class GeneralCommissioningCommissioningComplete : public ModelCommand
{
public:
    GeneralCommissioningCommissioningComplete() : ModelCommand("commissioning-complete") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGeneralCommissioningCommissioningCompleteResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::GeneralCommissioning::Commands::CommissioningComplete::Type mRequest;
};

/*
 * Command SetRegulatoryConfig
 */
class GeneralCommissioningSetRegulatoryConfig : public ModelCommand
{
public:
    GeneralCommissioningSetRegulatoryConfig() : ModelCommand("set-regulatory-config")
    {
        AddArgument("Location", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.location)> *>(&mRequest.location));
        AddArgument("CountryCode", &mRequest.countryCode);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGeneralCommissioningSetRegulatoryConfigResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::GeneralCommissioning::Commands::SetRegulatoryConfig::Type mRequest;
};

/*
 * Attribute Breadcrumb
 */
class ReadGeneralCommissioningBreadcrumb : public ModelCommand
{
public:
    ReadGeneralCommissioningBreadcrumb() : ModelCommand("read")
    {
        AddArgument("attr-name", "breadcrumb");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningBreadcrumb()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0030) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralCommissioningCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBreadcrumb(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteGeneralCommissioningBreadcrumb : public ModelCommand
{
public:
    WriteGeneralCommissioningBreadcrumb() : ModelCommand("write")
    {
        AddArgument("attr-name", "breadcrumb");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteGeneralCommissioningBreadcrumb()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0030) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralCommissioningCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeBreadcrumb(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint64_t mValue;
};

class ReportGeneralCommissioningBreadcrumb : public ModelCommand
{
public:
    ReportGeneralCommissioningBreadcrumb() : ModelCommand("report")
    {
        AddArgument("attr-name", "breadcrumb");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningBreadcrumb()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0030) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralCommissioningCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBreadcrumb(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBreadcrumb(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BasicCommissioningInfoList
 */
class ReadGeneralCommissioningBasicCommissioningInfoList : public ModelCommand
{
public:
    ReadGeneralCommissioningBasicCommissioningInfoList() : ModelCommand("read")
    {
        AddArgument("attr-name", "basic-commissioning-info-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningBasicCommissioningInfoList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0030) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralCommissioningCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBasicCommissioningInfoList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback>(
            OnGeneralCommissioningBasicCommissioningInfoListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ClusterRevision
 */
class ReadGeneralCommissioningClusterRevision : public ModelCommand
{
public:
    ReadGeneralCommissioningClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0030) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralCommissioningCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportGeneralCommissioningClusterRevision : public ModelCommand
{
public:
    ReportGeneralCommissioningClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0030) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralCommissioningCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GeneralDiagnostics                                          | 0x0033 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NetworkInterfaces                                                 | 0x0000 |
| * RebootCount                                                       | 0x0001 |
| * UpTime                                                            | 0x0002 |
| * TotalOperationalHours                                             | 0x0003 |
| * BootReasons                                                       | 0x0004 |
| * ActiveHardwareFaults                                              | 0x0005 |
| * ActiveRadioFaults                                                 | 0x0006 |
| * ActiveNetworkFaults                                               | 0x0007 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute NetworkInterfaces
 */
class ReadGeneralDiagnosticsNetworkInterfaces : public ModelCommand
{
public:
    ReadGeneralDiagnosticsNetworkInterfaces() : ModelCommand("read")
    {
        AddArgument("attr-name", "network-interfaces");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsNetworkInterfaces()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNetworkInterfaces(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback>(
            OnGeneralDiagnosticsNetworkInterfacesListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute RebootCount
 */
class ReadGeneralDiagnosticsRebootCount : public ModelCommand
{
public:
    ReadGeneralDiagnosticsRebootCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "reboot-count");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsRebootCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRebootCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportGeneralDiagnosticsRebootCount : public ModelCommand
{
public:
    ReportGeneralDiagnosticsRebootCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "reboot-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsRebootCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRebootCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRebootCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpTime
 */
class ReadGeneralDiagnosticsUpTime : public ModelCommand
{
public:
    ReadGeneralDiagnosticsUpTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "up-time");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsUpTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeUpTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportGeneralDiagnosticsUpTime : public ModelCommand
{
public:
    ReportGeneralDiagnosticsUpTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "up-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsUpTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeUpTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeUpTime(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TotalOperationalHours
 */
class ReadGeneralDiagnosticsTotalOperationalHours : public ModelCommand
{
public:
    ReadGeneralDiagnosticsTotalOperationalHours() : ModelCommand("read")
    {
        AddArgument("attr-name", "total-operational-hours");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsTotalOperationalHours()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTotalOperationalHours(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportGeneralDiagnosticsTotalOperationalHours : public ModelCommand
{
public:
    ReportGeneralDiagnosticsTotalOperationalHours() : ModelCommand("report")
    {
        AddArgument("attr-name", "total-operational-hours");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsTotalOperationalHours()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTotalOperationalHours(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTotalOperationalHours(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                               mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BootReasons
 */
class ReadGeneralDiagnosticsBootReasons : public ModelCommand
{
public:
    ReadGeneralDiagnosticsBootReasons() : ModelCommand("read")
    {
        AddArgument("attr-name", "boot-reasons");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsBootReasons()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBootReasons(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportGeneralDiagnosticsBootReasons : public ModelCommand
{
public:
    ReportGeneralDiagnosticsBootReasons() : ModelCommand("report")
    {
        AddArgument("attr-name", "boot-reasons");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsBootReasons()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBootReasons(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBootReasons(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveHardwareFaults
 */
class ReadGeneralDiagnosticsActiveHardwareFaults : public ModelCommand
{
public:
    ReadGeneralDiagnosticsActiveHardwareFaults() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-hardware-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveHardwareFaults()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActiveHardwareFaults(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<GeneralDiagnosticsActiveHardwareFaultsListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<GeneralDiagnosticsActiveHardwareFaultsListAttributeCallback>(
            OnGeneralDiagnosticsActiveHardwareFaultsListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ActiveRadioFaults
 */
class ReadGeneralDiagnosticsActiveRadioFaults : public ModelCommand
{
public:
    ReadGeneralDiagnosticsActiveRadioFaults() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-radio-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveRadioFaults()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActiveRadioFaults(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<GeneralDiagnosticsActiveRadioFaultsListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<GeneralDiagnosticsActiveRadioFaultsListAttributeCallback>(
            OnGeneralDiagnosticsActiveRadioFaultsListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ActiveNetworkFaults
 */
class ReadGeneralDiagnosticsActiveNetworkFaults : public ModelCommand
{
public:
    ReadGeneralDiagnosticsActiveNetworkFaults() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-network-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveNetworkFaults()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActiveNetworkFaults(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<GeneralDiagnosticsActiveNetworkFaultsListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<GeneralDiagnosticsActiveNetworkFaultsListAttributeCallback>(
            OnGeneralDiagnosticsActiveNetworkFaultsListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ClusterRevision
 */
class ReadGeneralDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReadGeneralDiagnosticsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportGeneralDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReportGeneralDiagnosticsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0033) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::GeneralDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GroupKeyManagement                                          | 0xF004 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Groups                                                            | 0x0000 |
| * GroupKeys                                                         | 0x0001 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Groups
 */
class ReadGroupKeyManagementGroups : public ModelCommand
{
public:
    ReadGroupKeyManagementGroups() : ModelCommand("read")
    {
        AddArgument("attr-name", "groups");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGroups()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0xF004) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GroupKeyManagementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeGroups(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<GroupKeyManagementGroupsListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<GroupKeyManagementGroupsListAttributeCallback>(OnGroupKeyManagementGroupsListAttributeResponse,
                                                                                    this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute GroupKeys
 */
class ReadGroupKeyManagementGroupKeys : public ModelCommand
{
public:
    ReadGroupKeyManagementGroupKeys() : ModelCommand("read")
    {
        AddArgument("attr-name", "group-keys");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGroupKeys()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0xF004) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GroupKeyManagementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeGroupKeys(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<GroupKeyManagementGroupKeysListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<GroupKeyManagementGroupKeysListAttributeCallback>(
            OnGroupKeyManagementGroupKeysListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ClusterRevision
 */
class ReadGroupKeyManagementClusterRevision : public ModelCommand
{
public:
    ReadGroupKeyManagementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0xF004) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GroupKeyManagementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportGroupKeyManagementClusterRevision : public ModelCommand
{
public:
    ReportGroupKeyManagementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0xF004) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::GroupKeyManagementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Groups                                                      | 0x0004 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddGroup                                                          |   0x00 |
| * AddGroupIfIdentifying                                             |   0x05 |
| * GetGroupMembership                                                |   0x02 |
| * RemoveAllGroups                                                   |   0x04 |
| * RemoveGroup                                                       |   0x03 |
| * ViewGroup                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NameSupport                                                       | 0x0000 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command AddGroup
 */
class GroupsAddGroup : public ModelCommand
{
public:
    GroupsAddGroup() : ModelCommand("add-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("GroupName", &mRequest.groupName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGroupsAddGroupResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::Groups::Commands::AddGroup::Type mRequest;
};

/*
 * Command AddGroupIfIdentifying
 */
class GroupsAddGroupIfIdentifying : public ModelCommand
{
public:
    GroupsAddGroupIfIdentifying() : ModelCommand("add-group-if-identifying")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("GroupName", &mRequest.groupName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000005) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Groups::Commands::AddGroupIfIdentifying::Type mRequest;
};

/*
 * Command GetGroupMembership
 */
class GroupsGetGroupMembership : public ModelCommand
{
public:
    GroupsGetGroupMembership() : ModelCommand("get-group-membership")
    {
        // groupList Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGroupsGetGroupMembershipResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::Groups::Commands::GetGroupMembership::Type mRequest;
};

/*
 * Command RemoveAllGroups
 */
class GroupsRemoveAllGroups : public ModelCommand
{
public:
    GroupsRemoveAllGroups() : ModelCommand("remove-all-groups") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type mRequest;
};

/*
 * Command RemoveGroup
 */
class GroupsRemoveGroup : public ModelCommand
{
public:
    GroupsRemoveGroup() : ModelCommand("remove-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000003) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGroupsRemoveGroupResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::Groups::Commands::RemoveGroup::Type mRequest;
};

/*
 * Command ViewGroup
 */
class GroupsViewGroup : public ModelCommand
{
public:
    GroupsViewGroup() : ModelCommand("view-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnGroupsViewGroupResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::Groups::Commands::ViewGroup::Type mRequest;
};

/*
 * Attribute NameSupport
 */
class ReadGroupsNameSupport : public ModelCommand
{
public:
    ReadGroupsNameSupport() : ModelCommand("read")
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsNameSupport()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0004) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GroupsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNameSupport(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportGroupsNameSupport : public ModelCommand
{
public:
    ReportGroupsNameSupport() : ModelCommand("report")
    {
        AddArgument("attr-name", "name-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupsNameSupport()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0004) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::GroupsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNameSupport(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNameSupport(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGroupsClusterRevision : public ModelCommand
{
public:
    ReadGroupsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0004) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::GroupsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportGroupsClusterRevision : public ModelCommand
{
public:
    ReportGroupsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupsClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0004) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::GroupsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Identify                                                    | 0x0003 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Identify                                                          |   0x00 |
| * IdentifyQuery                                                     |   0x01 |
| * TriggerEffect                                                     |   0x40 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * IdentifyTime                                                      | 0x0000 |
| * IdentifyType                                                      | 0x0001 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command Identify
 */
class IdentifyIdentify : public ModelCommand
{
public:
    IdentifyIdentify() : ModelCommand("identify")
    {
        AddArgument("IdentifyTime", 0, UINT16_MAX, &mRequest.identifyTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Identify::Commands::Identify::Type mRequest;
};

/*
 * Command IdentifyQuery
 */
class IdentifyIdentifyQuery : public ModelCommand
{
public:
    IdentifyIdentifyQuery() : ModelCommand("identify-query") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnIdentifyIdentifyQueryResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::Identify::Commands::IdentifyQuery::Type mRequest;
};

/*
 * Command TriggerEffect
 */
class IdentifyTriggerEffect : public ModelCommand
{
public:
    IdentifyTriggerEffect() : ModelCommand("trigger-effect")
    {
        AddArgument("EffectIdentifier", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.effectIdentifier)> *>(&mRequest.effectIdentifier));
        AddArgument("EffectVariant", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.effectVariant)> *>(&mRequest.effectVariant));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000040) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Identify::Commands::TriggerEffect::Type mRequest;
};

/*
 * Attribute IdentifyTime
 */
class ReadIdentifyIdentifyTime : public ModelCommand
{
public:
    ReadIdentifyIdentifyTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "identify-time");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyIdentifyTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0003) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::IdentifyCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeIdentifyTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteIdentifyIdentifyTime : public ModelCommand
{
public:
    WriteIdentifyIdentifyTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteIdentifyIdentifyTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0003) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::IdentifyCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeIdentifyTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportIdentifyIdentifyTime : public ModelCommand
{
public:
    ReportIdentifyIdentifyTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyIdentifyTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0003) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::IdentifyCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeIdentifyTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeIdentifyTime(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute IdentifyType
 */
class ReadIdentifyIdentifyType : public ModelCommand
{
public:
    ReadIdentifyIdentifyType() : ModelCommand("read")
    {
        AddArgument("attr-name", "identify-type");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyIdentifyType()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0003) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::IdentifyCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeIdentifyType(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportIdentifyIdentifyType : public ModelCommand
{
public:
    ReportIdentifyIdentifyType() : ModelCommand("report")
    {
        AddArgument("attr-name", "identify-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyIdentifyType()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0003) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::IdentifyCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeIdentifyType(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeIdentifyType(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadIdentifyClusterRevision : public ModelCommand
{
public:
    ReadIdentifyClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0003) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::IdentifyCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportIdentifyClusterRevision : public ModelCommand
{
public:
    ReportIdentifyClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0003) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::IdentifyCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster IlluminanceMeasurement                                      | 0x0400 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * LightSensorType                                                   | 0x0004 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadIlluminanceMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadIlluminanceMeasurementMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportIlluminanceMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportIlluminanceMeasurementMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadIlluminanceMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadIlluminanceMeasurementMinMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMinMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportIlluminanceMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReportIlluminanceMeasurementMinMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementMinMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadIlluminanceMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadIlluminanceMeasurementMaxMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMaxMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportIlluminanceMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReportIlluminanceMeasurementMaxMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementMaxMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadIlluminanceMeasurementTolerance : public ModelCommand
{
public:
    ReadIlluminanceMeasurementTolerance() : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementTolerance()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTolerance(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportIlluminanceMeasurementTolerance : public ModelCommand
{
public:
    ReportIlluminanceMeasurementTolerance() : ModelCommand("report")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementTolerance()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTolerance(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTolerance(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LightSensorType
 */
class ReadIlluminanceMeasurementLightSensorType : public ModelCommand
{
public:
    ReadIlluminanceMeasurementLightSensorType() : ModelCommand("read")
    {
        AddArgument("attr-name", "light-sensor-type");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementLightSensorType()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLightSensorType(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportIlluminanceMeasurementLightSensorType : public ModelCommand
{
public:
    ReportIlluminanceMeasurementLightSensorType() : ModelCommand("report")
    {
        AddArgument("attr-name", "light-sensor-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementLightSensorType()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLightSensorType(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLightSensorType(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadIlluminanceMeasurementClusterRevision : public ModelCommand
{
public:
    ReadIlluminanceMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportIlluminanceMeasurementClusterRevision : public ModelCommand
{
public:
    ReportIlluminanceMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0400) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::IlluminanceMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster KeypadInput                                                 | 0x0509 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SendKey                                                           |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command SendKey
 */
class KeypadInputSendKey : public ModelCommand
{
public:
    KeypadInputSendKey() : ModelCommand("send-key")
    {
        AddArgument("KeyCode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.keyCode)> *>(&mRequest.keyCode));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnKeypadInputSendKeyResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::KeypadInput::Commands::SendKey::Type mRequest;
};

/*
 * Attribute ClusterRevision
 */
class ReadKeypadInputClusterRevision : public ModelCommand
{
public:
    ReadKeypadInputClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0509) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::KeypadInputCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportKeypadInputClusterRevision : public ModelCommand
{
public:
    ReportKeypadInputClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportKeypadInputClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0509) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::KeypadInputCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LevelControl                                                | 0x0008 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Move                                                              |   0x01 |
| * MoveToLevel                                                       |   0x00 |
| * MoveToLevelWithOnOff                                              |   0x04 |
| * MoveWithOnOff                                                     |   0x05 |
| * Step                                                              |   0x02 |
| * StepWithOnOff                                                     |   0x06 |
| * Stop                                                              |   0x03 |
| * StopWithOnOff                                                     |   0x07 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentLevel                                                      | 0x0000 |
| * RemainingTime                                                     | 0x0001 |
| * MinLevel                                                          | 0x0002 |
| * MaxLevel                                                          | 0x0003 |
| * CurrentFrequency                                                  | 0x0004 |
| * MinFrequency                                                      | 0x0005 |
| * MaxFrequency                                                      | 0x0006 |
| * Options                                                           | 0x000F |
| * OnOffTransitionTime                                               | 0x0010 |
| * OnLevel                                                           | 0x0011 |
| * OnTransitionTime                                                  | 0x0012 |
| * OffTransitionTime                                                 | 0x0013 |
| * DefaultMoveRate                                                   | 0x0014 |
| * StartUpCurrentLevel                                               | 0x4000 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command Move
 */
class LevelControlMove : public ModelCommand
{
public:
    LevelControlMove() : ModelCommand("move")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT8_MAX, &mRequest.rate);
        AddArgument("OptionMask", 0, UINT8_MAX, &mRequest.optionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mRequest.optionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::LevelControl::Commands::Move::Type mRequest;
};

/*
 * Command MoveToLevel
 */
class LevelControlMoveToLevel : public ModelCommand
{
public:
    LevelControlMoveToLevel() : ModelCommand("move-to-level")
    {
        AddArgument("Level", 0, UINT8_MAX, &mRequest.level);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionMask", 0, UINT8_MAX, &mRequest.optionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mRequest.optionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type mRequest;
};

/*
 * Command MoveToLevelWithOnOff
 */
class LevelControlMoveToLevelWithOnOff : public ModelCommand
{
public:
    LevelControlMoveToLevelWithOnOff() : ModelCommand("move-to-level-with-on-off")
    {
        AddArgument("Level", 0, UINT8_MAX, &mRequest.level);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::LevelControl::Commands::MoveToLevelWithOnOff::Type mRequest;
};

/*
 * Command MoveWithOnOff
 */
class LevelControlMoveWithOnOff : public ModelCommand
{
public:
    LevelControlMoveWithOnOff() : ModelCommand("move-with-on-off")
    {
        AddArgument("MoveMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.moveMode)> *>(&mRequest.moveMode));
        AddArgument("Rate", 0, UINT8_MAX, &mRequest.rate);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000005) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::LevelControl::Commands::MoveWithOnOff::Type mRequest;
};

/*
 * Command Step
 */
class LevelControlStep : public ModelCommand
{
public:
    LevelControlStep() : ModelCommand("step")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT8_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("OptionMask", 0, UINT8_MAX, &mRequest.optionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mRequest.optionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::LevelControl::Commands::Step::Type mRequest;
};

/*
 * Command StepWithOnOff
 */
class LevelControlStepWithOnOff : public ModelCommand
{
public:
    LevelControlStepWithOnOff() : ModelCommand("step-with-on-off")
    {
        AddArgument("StepMode", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.stepMode)> *>(&mRequest.stepMode));
        AddArgument("StepSize", 0, UINT8_MAX, &mRequest.stepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000006) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::LevelControl::Commands::StepWithOnOff::Type mRequest;
};

/*
 * Command Stop
 */
class LevelControlStop : public ModelCommand
{
public:
    LevelControlStop() : ModelCommand("stop")
    {
        AddArgument("OptionMask", 0, UINT8_MAX, &mRequest.optionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mRequest.optionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000003) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::LevelControl::Commands::Stop::Type mRequest;
};

/*
 * Command StopWithOnOff
 */
class LevelControlStopWithOnOff : public ModelCommand
{
public:
    LevelControlStopWithOnOff() : ModelCommand("stop-with-on-off") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000007) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::LevelControl::Commands::StopWithOnOff::Type mRequest;
};

/*
 * Attribute CurrentLevel
 */
class ReadLevelControlCurrentLevel : public ModelCommand
{
public:
    ReadLevelControlCurrentLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlCurrentLevel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentLevel(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportLevelControlCurrentLevel : public ModelCommand
{
public:
    ReportLevelControlCurrentLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlCurrentLevel()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentLevel(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentLevel(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RemainingTime
 */
class ReadLevelControlRemainingTime : public ModelCommand
{
public:
    ReadLevelControlRemainingTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlRemainingTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRemainingTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportLevelControlRemainingTime : public ModelCommand
{
public:
    ReportLevelControlRemainingTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "remaining-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlRemainingTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRemainingTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRemainingTime(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinLevel
 */
class ReadLevelControlMinLevel : public ModelCommand
{
public:
    ReadLevelControlMinLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMinLevel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinLevel(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportLevelControlMinLevel : public ModelCommand
{
public:
    ReportLevelControlMinLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMinLevel()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinLevel(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinLevel(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxLevel
 */
class ReadLevelControlMaxLevel : public ModelCommand
{
public:
    ReadLevelControlMaxLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMaxLevel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxLevel(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportLevelControlMaxLevel : public ModelCommand
{
public:
    ReportLevelControlMaxLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMaxLevel()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxLevel(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxLevel(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentFrequency
 */
class ReadLevelControlCurrentFrequency : public ModelCommand
{
public:
    ReadLevelControlCurrentFrequency() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlCurrentFrequency()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentFrequency(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportLevelControlCurrentFrequency : public ModelCommand
{
public:
    ReportLevelControlCurrentFrequency() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlCurrentFrequency()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentFrequency(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentFrequency(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinFrequency
 */
class ReadLevelControlMinFrequency : public ModelCommand
{
public:
    ReadLevelControlMinFrequency() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMinFrequency()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinFrequency(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportLevelControlMinFrequency : public ModelCommand
{
public:
    ReportLevelControlMinFrequency() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMinFrequency()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinFrequency(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinFrequency(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxFrequency
 */
class ReadLevelControlMaxFrequency : public ModelCommand
{
public:
    ReadLevelControlMaxFrequency() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMaxFrequency()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxFrequency(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportLevelControlMaxFrequency : public ModelCommand
{
public:
    ReportLevelControlMaxFrequency() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMaxFrequency()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxFrequency(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxFrequency(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Options
 */
class ReadLevelControlOptions : public ModelCommand
{
public:
    ReadLevelControlOptions() : ModelCommand("read")
    {
        AddArgument("attr-name", "options");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOptions()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOptions(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteLevelControlOptions : public ModelCommand
{
public:
    WriteLevelControlOptions() : ModelCommand("write")
    {
        AddArgument("attr-name", "options");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOptions()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOptions(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportLevelControlOptions : public ModelCommand
{
public:
    ReportLevelControlOptions() : ModelCommand("report")
    {
        AddArgument("attr-name", "options");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOptions()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOptions(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOptions(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnOffTransitionTime
 */
class ReadLevelControlOnOffTransitionTime : public ModelCommand
{
public:
    ReadLevelControlOnOffTransitionTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-off-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnOffTransitionTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOnOffTransitionTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteLevelControlOnOffTransitionTime : public ModelCommand
{
public:
    WriteLevelControlOnOffTransitionTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "on-off-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnOffTransitionTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOnOffTransitionTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportLevelControlOnOffTransitionTime : public ModelCommand
{
public:
    ReportLevelControlOnOffTransitionTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-off-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOnOffTransitionTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOnOffTransitionTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOnOffTransitionTime(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnLevel
 */
class ReadLevelControlOnLevel : public ModelCommand
{
public:
    ReadLevelControlOnLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnLevel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOnLevel(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteLevelControlOnLevel : public ModelCommand
{
public:
    WriteLevelControlOnLevel() : ModelCommand("write")
    {
        AddArgument("attr-name", "on-level");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnLevel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOnLevel(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportLevelControlOnLevel : public ModelCommand
{
public:
    ReportLevelControlOnLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOnLevel()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOnLevel(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOnLevel(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnTransitionTime
 */
class ReadLevelControlOnTransitionTime : public ModelCommand
{
public:
    ReadLevelControlOnTransitionTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnTransitionTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOnTransitionTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteLevelControlOnTransitionTime : public ModelCommand
{
public:
    WriteLevelControlOnTransitionTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "on-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnTransitionTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOnTransitionTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportLevelControlOnTransitionTime : public ModelCommand
{
public:
    ReportLevelControlOnTransitionTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOnTransitionTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOnTransitionTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOnTransitionTime(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OffTransitionTime
 */
class ReadLevelControlOffTransitionTime : public ModelCommand
{
public:
    ReadLevelControlOffTransitionTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "off-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOffTransitionTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOffTransitionTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteLevelControlOffTransitionTime : public ModelCommand
{
public:
    WriteLevelControlOffTransitionTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "off-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOffTransitionTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOffTransitionTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportLevelControlOffTransitionTime : public ModelCommand
{
public:
    ReportLevelControlOffTransitionTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "off-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOffTransitionTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOffTransitionTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOffTransitionTime(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DefaultMoveRate
 */
class ReadLevelControlDefaultMoveRate : public ModelCommand
{
public:
    ReadLevelControlDefaultMoveRate() : ModelCommand("read")
    {
        AddArgument("attr-name", "default-move-rate");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlDefaultMoveRate()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeDefaultMoveRate(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteLevelControlDefaultMoveRate : public ModelCommand
{
public:
    WriteLevelControlDefaultMoveRate() : ModelCommand("write")
    {
        AddArgument("attr-name", "default-move-rate");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlDefaultMoveRate()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeDefaultMoveRate(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportLevelControlDefaultMoveRate : public ModelCommand
{
public:
    ReportLevelControlDefaultMoveRate() : ModelCommand("report")
    {
        AddArgument("attr-name", "default-move-rate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlDefaultMoveRate()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeDefaultMoveRate(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeDefaultMoveRate(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpCurrentLevel
 */
class ReadLevelControlStartUpCurrentLevel : public ModelCommand
{
public:
    ReadLevelControlStartUpCurrentLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-current-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlStartUpCurrentLevel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeStartUpCurrentLevel(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteLevelControlStartUpCurrentLevel : public ModelCommand
{
public:
    WriteLevelControlStartUpCurrentLevel() : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-current-level");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlStartUpCurrentLevel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeStartUpCurrentLevel(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportLevelControlStartUpCurrentLevel : public ModelCommand
{
public:
    ReportLevelControlStartUpCurrentLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-up-current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlStartUpCurrentLevel()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeStartUpCurrentLevel(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeStartUpCurrentLevel(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadLevelControlClusterRevision : public ModelCommand
{
public:
    ReadLevelControlClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportLevelControlClusterRevision : public ModelCommand
{
public:
    ReportLevelControlClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0008) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LevelControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LowPower                                                    | 0x0508 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Sleep                                                             |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command Sleep
 */
class LowPowerSleep : public ModelCommand
{
public:
    LowPowerSleep() : ModelCommand("sleep") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::LowPower::Commands::Sleep::Type mRequest;
};

/*
 * Attribute ClusterRevision
 */
class ReadLowPowerClusterRevision : public ModelCommand
{
public:
    ReadLowPowerClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0508) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::LowPowerCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportLowPowerClusterRevision : public ModelCommand
{
public:
    ReportLowPowerClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLowPowerClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0508) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::LowPowerCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster MediaInput                                                  | 0x0507 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * HideInputStatus                                                   |   0x02 |
| * RenameInput                                                       |   0x03 |
| * SelectInput                                                       |   0x00 |
| * ShowInputStatus                                                   |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MediaInputList                                                    | 0x0000 |
| * CurrentMediaInput                                                 | 0x0001 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command HideInputStatus
 */
class MediaInputHideInputStatus : public ModelCommand
{
public:
    MediaInputHideInputStatus() : ModelCommand("hide-input-status") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type mRequest;
};

/*
 * Command RenameInput
 */
class MediaInputRenameInput : public ModelCommand
{
public:
    MediaInputRenameInput() : ModelCommand("rename-input")
    {
        AddArgument("Index", 0, UINT8_MAX, &mRequest.index);
        AddArgument("Name", &mRequest.name);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000003) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::MediaInput::Commands::RenameInput::Type mRequest;
};

/*
 * Command SelectInput
 */
class MediaInputSelectInput : public ModelCommand
{
public:
    MediaInputSelectInput() : ModelCommand("select-input")
    {
        AddArgument("Index", 0, UINT8_MAX, &mRequest.index);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::MediaInput::Commands::SelectInput::Type mRequest;
};

/*
 * Command ShowInputStatus
 */
class MediaInputShowInputStatus : public ModelCommand
{
public:
    MediaInputShowInputStatus() : ModelCommand("show-input-status") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type mRequest;
};

/*
 * Attribute MediaInputList
 */
class ReadMediaInputMediaInputList : public ModelCommand
{
public:
    ReadMediaInputMediaInputList() : ModelCommand("read")
    {
        AddArgument("attr-name", "media-input-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputMediaInputList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0507) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaInputCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMediaInputList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<MediaInputMediaInputListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<MediaInputMediaInputListListAttributeCallback>(OnMediaInputMediaInputListListAttributeResponse,
                                                                                    this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute CurrentMediaInput
 */
class ReadMediaInputCurrentMediaInput : public ModelCommand
{
public:
    ReadMediaInputCurrentMediaInput() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-media-input");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputCurrentMediaInput()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0507) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaInputCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentMediaInput(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaInputCurrentMediaInput : public ModelCommand
{
public:
    ReportMediaInputCurrentMediaInput() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-media-input");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputCurrentMediaInput()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0507) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaInputCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentMediaInput(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentMediaInput(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadMediaInputClusterRevision : public ModelCommand
{
public:
    ReadMediaInputClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0507) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaInputCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaInputClusterRevision : public ModelCommand
{
public:
    ReportMediaInputClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0507) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaInputCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster MediaPlayback                                               | 0x0506 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MediaFastForward                                                  |   0x07 |
| * MediaNext                                                         |   0x05 |
| * MediaPause                                                        |   0x01 |
| * MediaPlay                                                         |   0x00 |
| * MediaPrevious                                                     |   0x04 |
| * MediaRewind                                                       |   0x06 |
| * MediaSeek                                                         |   0x0A |
| * MediaSkipBackward                                                 |   0x09 |
| * MediaSkipForward                                                  |   0x08 |
| * MediaStartOver                                                    |   0x03 |
| * MediaStop                                                         |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * PlaybackState                                                     | 0x0000 |
| * StartTime                                                         | 0x0001 |
| * Duration                                                          | 0x0002 |
| * PositionUpdatedAt                                                 | 0x0003 |
| * Position                                                          | 0x0004 |
| * PlaybackSpeed                                                     | 0x0005 |
| * SeekRangeEnd                                                      | 0x0006 |
| * SeekRangeStart                                                    | 0x0007 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command MediaFastForward
 */
class MediaPlaybackMediaFastForward : public ModelCommand
{
public:
    MediaPlaybackMediaFastForward() : ModelCommand("media-fast-forward") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000007) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaFastForwardResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaFastForward::Type mRequest;
};

/*
 * Command MediaNext
 */
class MediaPlaybackMediaNext : public ModelCommand
{
public:
    MediaPlaybackMediaNext() : ModelCommand("media-next") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000005) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaNextResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaNext::Type mRequest;
};

/*
 * Command MediaPause
 */
class MediaPlaybackMediaPause : public ModelCommand
{
public:
    MediaPlaybackMediaPause() : ModelCommand("media-pause") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaPauseResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaPause::Type mRequest;
};

/*
 * Command MediaPlay
 */
class MediaPlaybackMediaPlay : public ModelCommand
{
public:
    MediaPlaybackMediaPlay() : ModelCommand("media-play") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaPlayResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaPlay::Type mRequest;
};

/*
 * Command MediaPrevious
 */
class MediaPlaybackMediaPrevious : public ModelCommand
{
public:
    MediaPlaybackMediaPrevious() : ModelCommand("media-previous") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaPreviousResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaPrevious::Type mRequest;
};

/*
 * Command MediaRewind
 */
class MediaPlaybackMediaRewind : public ModelCommand
{
public:
    MediaPlaybackMediaRewind() : ModelCommand("media-rewind") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000006) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaRewindResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaRewind::Type mRequest;
};

/*
 * Command MediaSeek
 */
class MediaPlaybackMediaSeek : public ModelCommand
{
public:
    MediaPlaybackMediaSeek() : ModelCommand("media-seek")
    {
        AddArgument("Position", 0, UINT64_MAX, &mRequest.position);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x0000000A) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaSeekResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaSeek::Type mRequest;
};

/*
 * Command MediaSkipBackward
 */
class MediaPlaybackMediaSkipBackward : public ModelCommand
{
public:
    MediaPlaybackMediaSkipBackward() : ModelCommand("media-skip-backward")
    {
        AddArgument("DeltaPositionMilliseconds", 0, UINT64_MAX, &mRequest.deltaPositionMilliseconds);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000009) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaSkipBackwardResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackward::Type mRequest;
};

/*
 * Command MediaSkipForward
 */
class MediaPlaybackMediaSkipForward : public ModelCommand
{
public:
    MediaPlaybackMediaSkipForward() : ModelCommand("media-skip-forward")
    {
        AddArgument("DeltaPositionMilliseconds", 0, UINT64_MAX, &mRequest.deltaPositionMilliseconds);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000008) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaSkipForwardResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaSkipForward::Type mRequest;
};

/*
 * Command MediaStartOver
 */
class MediaPlaybackMediaStartOver : public ModelCommand
{
public:
    MediaPlaybackMediaStartOver() : ModelCommand("media-start-over") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000003) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaStartOverResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaStartOver::Type mRequest;
};

/*
 * Command MediaStop
 */
class MediaPlaybackMediaStop : public ModelCommand
{
public:
    MediaPlaybackMediaStop() : ModelCommand("media-stop") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnMediaPlaybackMediaStopResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::MediaPlayback::Commands::MediaStop::Type mRequest;
};

/*
 * Attribute PlaybackState
 */
class ReadMediaPlaybackPlaybackState : public ModelCommand
{
public:
    ReadMediaPlaybackPlaybackState() : ModelCommand("read")
    {
        AddArgument("attr-name", "playback-state");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackPlaybackState()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePlaybackState(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaPlaybackPlaybackState : public ModelCommand
{
public:
    ReportMediaPlaybackPlaybackState() : ModelCommand("report")
    {
        AddArgument("attr-name", "playback-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackPlaybackState()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePlaybackState(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePlaybackState(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartTime
 */
class ReadMediaPlaybackStartTime : public ModelCommand
{
public:
    ReadMediaPlaybackStartTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-time");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackStartTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeStartTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaPlaybackStartTime : public ModelCommand
{
public:
    ReportMediaPlaybackStartTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackStartTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeStartTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeStartTime(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Duration
 */
class ReadMediaPlaybackDuration : public ModelCommand
{
public:
    ReadMediaPlaybackDuration() : ModelCommand("read")
    {
        AddArgument("attr-name", "duration");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackDuration()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeDuration(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaPlaybackDuration : public ModelCommand
{
public:
    ReportMediaPlaybackDuration() : ModelCommand("report")
    {
        AddArgument("attr-name", "duration");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackDuration()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeDuration(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeDuration(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PositionUpdatedAt
 */
class ReadMediaPlaybackPositionUpdatedAt : public ModelCommand
{
public:
    ReadMediaPlaybackPositionUpdatedAt() : ModelCommand("read")
    {
        AddArgument("attr-name", "position-updated-at");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackPositionUpdatedAt()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePositionUpdatedAt(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaPlaybackPositionUpdatedAt : public ModelCommand
{
public:
    ReportMediaPlaybackPositionUpdatedAt() : ModelCommand("report")
    {
        AddArgument("attr-name", "position-updated-at");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackPositionUpdatedAt()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePositionUpdatedAt(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePositionUpdatedAt(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Position
 */
class ReadMediaPlaybackPosition : public ModelCommand
{
public:
    ReadMediaPlaybackPosition() : ModelCommand("read")
    {
        AddArgument("attr-name", "position");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackPosition()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePosition(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaPlaybackPosition : public ModelCommand
{
public:
    ReportMediaPlaybackPosition() : ModelCommand("report")
    {
        AddArgument("attr-name", "position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackPosition()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePosition(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePosition(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PlaybackSpeed
 */
class ReadMediaPlaybackPlaybackSpeed : public ModelCommand
{
public:
    ReadMediaPlaybackPlaybackSpeed() : ModelCommand("read")
    {
        AddArgument("attr-name", "playback-speed");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackPlaybackSpeed()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePlaybackSpeed(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaPlaybackPlaybackSpeed : public ModelCommand
{
public:
    ReportMediaPlaybackPlaybackSpeed() : ModelCommand("report")
    {
        AddArgument("attr-name", "playback-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackPlaybackSpeed()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePlaybackSpeed(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePlaybackSpeed(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SeekRangeEnd
 */
class ReadMediaPlaybackSeekRangeEnd : public ModelCommand
{
public:
    ReadMediaPlaybackSeekRangeEnd() : ModelCommand("read")
    {
        AddArgument("attr-name", "seek-range-end");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSeekRangeEnd()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSeekRangeEnd(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaPlaybackSeekRangeEnd : public ModelCommand
{
public:
    ReportMediaPlaybackSeekRangeEnd() : ModelCommand("report")
    {
        AddArgument("attr-name", "seek-range-end");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackSeekRangeEnd()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSeekRangeEnd(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSeekRangeEnd(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SeekRangeStart
 */
class ReadMediaPlaybackSeekRangeStart : public ModelCommand
{
public:
    ReadMediaPlaybackSeekRangeStart() : ModelCommand("read")
    {
        AddArgument("attr-name", "seek-range-start");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSeekRangeStart()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSeekRangeStart(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaPlaybackSeekRangeStart : public ModelCommand
{
public:
    ReportMediaPlaybackSeekRangeStart() : ModelCommand("report")
    {
        AddArgument("attr-name", "seek-range-start");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackSeekRangeStart()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSeekRangeStart(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSeekRangeStart(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadMediaPlaybackClusterRevision : public ModelCommand
{
public:
    ReadMediaPlaybackClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportMediaPlaybackClusterRevision : public ModelCommand
{
public:
    ReportMediaPlaybackClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0506) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::MediaPlaybackCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ModeSelect                                                  | 0x0050 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeToMode                                                      |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentMode                                                       | 0x0000 |
| * SupportedModes                                                    | 0x0001 |
| * OnMode                                                            | 0x0002 |
| * StartUpMode                                                       | 0x0003 |
| * Description                                                       | 0x0004 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeToMode
 */
class ModeSelectChangeToMode : public ModelCommand
{
public:
    ModeSelectChangeToMode() : ModelCommand("change-to-mode")
    {
        AddArgument("NewMode", 0, UINT8_MAX, &mRequest.newMode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type mRequest;
};

/*
 * Attribute CurrentMode
 */
class ReadModeSelectCurrentMode : public ModelCommand
{
public:
    ReadModeSelectCurrentMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectCurrentMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportModeSelectCurrentMode : public ModelCommand
{
public:
    ReportModeSelectCurrentMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectCurrentMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentMode(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedModes
 */
class ReadModeSelectSupportedModes : public ModelCommand
{
public:
    ReadModeSelectSupportedModes() : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-modes");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectSupportedModes()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSupportedModes(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<ModeSelectSupportedModesListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<ModeSelectSupportedModesListAttributeCallback>(OnModeSelectSupportedModesListAttributeResponse,
                                                                                    this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute OnMode
 */
class ReadModeSelectOnMode : public ModelCommand
{
public:
    ReadModeSelectOnMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectOnMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOnMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteModeSelectOnMode : public ModelCommand
{
public:
    WriteModeSelectOnMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "on-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteModeSelectOnMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOnMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportModeSelectOnMode : public ModelCommand
{
public:
    ReportModeSelectOnMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectOnMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOnMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOnMode(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpMode
 */
class ReadModeSelectStartUpMode : public ModelCommand
{
public:
    ReadModeSelectStartUpMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectStartUpMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeStartUpMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportModeSelectStartUpMode : public ModelCommand
{
public:
    ReportModeSelectStartUpMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-up-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectStartUpMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeStartUpMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeStartUpMode(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Description
 */
class ReadModeSelectDescription : public ModelCommand
{
public:
    ReadModeSelectDescription() : ModelCommand("read")
    {
        AddArgument("attr-name", "description");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectDescription()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeDescription(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportModeSelectDescription : public ModelCommand
{
public:
    ReportModeSelectDescription() : ModelCommand("report")
    {
        AddArgument("attr-name", "description");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectDescription()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeDescription(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeDescription(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadModeSelectClusterRevision : public ModelCommand
{
public:
    ReadModeSelectClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportModeSelectClusterRevision : public ModelCommand
{
public:
    ReportModeSelectClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0050) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ModeSelectCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster NetworkCommissioning                                        | 0x0031 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddThreadNetwork                                                  |   0x06 |
| * AddWiFiNetwork                                                    |   0x02 |
| * DisableNetwork                                                    |   0x0E |
| * EnableNetwork                                                     |   0x0C |
| * RemoveNetwork                                                     |   0x0A |
| * ScanNetworks                                                      |   0x00 |
| * UpdateThreadNetwork                                               |   0x08 |
| * UpdateWiFiNetwork                                                 |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command AddThreadNetwork
 */
class NetworkCommissioningAddThreadNetwork : public ModelCommand
{
public:
    NetworkCommissioningAddThreadNetwork() : ModelCommand("add-thread-network")
    {
        AddArgument("OperationalDataset", &mRequest.operationalDataset);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000006) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningAddThreadNetworkResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::AddThreadNetwork::Type mRequest;
};

/*
 * Command AddWiFiNetwork
 */
class NetworkCommissioningAddWiFiNetwork : public ModelCommand
{
public:
    NetworkCommissioningAddWiFiNetwork() : ModelCommand("add-wi-fi-network")
    {
        AddArgument("Ssid", &mRequest.ssid);
        AddArgument("Credentials", &mRequest.credentials);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningAddWiFiNetworkResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::AddWiFiNetwork::Type mRequest;
};

/*
 * Command DisableNetwork
 */
class NetworkCommissioningDisableNetwork : public ModelCommand
{
public:
    NetworkCommissioningDisableNetwork() : ModelCommand("disable-network")
    {
        AddArgument("NetworkID", &mRequest.networkID);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x0000000E) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningDisableNetworkResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::DisableNetwork::Type mRequest;
};

/*
 * Command EnableNetwork
 */
class NetworkCommissioningEnableNetwork : public ModelCommand
{
public:
    NetworkCommissioningEnableNetwork() : ModelCommand("enable-network")
    {
        AddArgument("NetworkID", &mRequest.networkID);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x0000000C) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningEnableNetworkResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::EnableNetwork::Type mRequest;
};

/*
 * Command RemoveNetwork
 */
class NetworkCommissioningRemoveNetwork : public ModelCommand
{
public:
    NetworkCommissioningRemoveNetwork() : ModelCommand("remove-network")
    {
        AddArgument("NetworkID", &mRequest.networkID);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x0000000A) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningRemoveNetworkResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::RemoveNetwork::Type mRequest;
};

/*
 * Command ScanNetworks
 */
class NetworkCommissioningScanNetworks : public ModelCommand
{
public:
    NetworkCommissioningScanNetworks() : ModelCommand("scan-networks")
    {
        AddArgument("Ssid", &mRequest.ssid);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningScanNetworksResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::ScanNetworks::Type mRequest;
};

/*
 * Command UpdateThreadNetwork
 */
class NetworkCommissioningUpdateThreadNetwork : public ModelCommand
{
public:
    NetworkCommissioningUpdateThreadNetwork() : ModelCommand("update-thread-network")
    {
        AddArgument("OperationalDataset", &mRequest.operationalDataset);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000008) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningUpdateThreadNetworkResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::UpdateThreadNetwork::Type mRequest;
};

/*
 * Command UpdateWiFiNetwork
 */
class NetworkCommissioningUpdateWiFiNetwork : public ModelCommand
{
public:
    NetworkCommissioningUpdateWiFiNetwork() : ModelCommand("update-wi-fi-network")
    {
        AddArgument("Ssid", &mRequest.ssid);
        AddArgument("Credentials", &mRequest.credentials);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mRequest.breadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mRequest.timeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnNetworkCommissioningUpdateWiFiNetworkResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::NetworkCommissioning::Commands::UpdateWiFiNetwork::Type mRequest;
};

/*
 * Attribute FeatureMap
 */
class ReadNetworkCommissioningFeatureMap : public ModelCommand
{
public:
    ReadNetworkCommissioningFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningFeatureMap()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0031) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::NetworkCommissioningCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeFeatureMap(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportNetworkCommissioningFeatureMap : public ModelCommand
{
public:
    ReportNetworkCommissioningFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningFeatureMap()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0031) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::NetworkCommissioningCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeFeatureMap(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeFeatureMap(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadNetworkCommissioningClusterRevision : public ModelCommand
{
public:
    ReadNetworkCommissioningClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0031) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::NetworkCommissioningCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportNetworkCommissioningClusterRevision : public ModelCommand
{
public:
    ReportNetworkCommissioningClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0031) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::NetworkCommissioningCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OtaSoftwareUpdateProvider                                   | 0x0029 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ApplyUpdateRequest                                                |   0x01 |
| * NotifyUpdateApplied                                               |   0x02 |
| * QueryImage                                                        |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ApplyUpdateRequest
 */
class OtaSoftwareUpdateProviderApplyUpdateRequest : public ModelCommand
{
public:
    OtaSoftwareUpdateProviderApplyUpdateRequest() : ModelCommand("apply-update-request")
    {
        AddArgument("UpdateToken", &mRequest.updateToken);
        AddArgument("NewVersion", 0, UINT32_MAX, &mRequest.newVersion);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOtaSoftwareUpdateProviderApplyUpdateResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::ApplyUpdateRequest::Type mRequest;
};

/*
 * Command NotifyUpdateApplied
 */
class OtaSoftwareUpdateProviderNotifyUpdateApplied : public ModelCommand
{
public:
    OtaSoftwareUpdateProviderNotifyUpdateApplied() : ModelCommand("notify-update-applied")
    {
        AddArgument("UpdateToken", &mRequest.updateToken);
        AddArgument("SoftwareVersion", 0, UINT32_MAX, &mRequest.softwareVersion);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::NotifyUpdateApplied::Type mRequest;
};

/*
 * Command QueryImage
 */
class OtaSoftwareUpdateProviderQueryImage : public ModelCommand
{
public:
    OtaSoftwareUpdateProviderQueryImage() : ModelCommand("query-image")
    {
        AddArgument("VendorId", 0, UINT16_MAX, &mRequest.vendorId);
        AddArgument("ProductId", 0, UINT16_MAX, &mRequest.productId);
        AddArgument("SoftwareVersion", 0, UINT32_MAX, &mRequest.softwareVersion);
        // protocolsSupported Array parsing is not supported yet
        AddArgument("HardwareVersion", 0, UINT16_MAX, &mRequest.hardwareVersion);
        AddArgument("Location", &mRequest.location);
        AddArgument("RequestorCanConsent", 0, 1, &mRequest.requestorCanConsent);
        AddArgument("MetadataForProvider", &mRequest.metadataForProvider);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOtaSoftwareUpdateProviderQueryImageResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::QueryImage::Type mRequest;
};

/*
 * Attribute ClusterRevision
 */
class ReadOtaSoftwareUpdateProviderClusterRevision : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateProviderClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateProviderClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0029) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OtaSoftwareUpdateProviderCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOtaSoftwareUpdateProviderClusterRevision : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateProviderClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateProviderClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0029) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OtaSoftwareUpdateProviderCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OtaSoftwareUpdateRequestor                                  | 0x002A |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AnnounceOtaProvider                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DefaultOtaProvider                                                | 0x0001 |
| * UpdatePossible                                                    | 0x0002 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command AnnounceOtaProvider
 */
class OtaSoftwareUpdateRequestorAnnounceOtaProvider : public ModelCommand
{
public:
    OtaSoftwareUpdateRequestorAnnounceOtaProvider() : ModelCommand("announce-ota-provider")
    {
        AddArgument("ProviderLocation", 0, UINT64_MAX, &mRequest.providerLocation);
        AddArgument("VendorId", 0, UINT16_MAX, &mRequest.vendorId);
        AddArgument(
            "AnnouncementReason", 0, UINT8_MAX,
            reinterpret_cast<std::underlying_type_t<decltype(mRequest.announcementReason)> *>(&mRequest.announcementReason));
        AddArgument("MetadataForNode", &mRequest.metadataForNode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OtaSoftwareUpdateRequestor::Commands::AnnounceOtaProvider::Type mRequest;
};

/*
 * Attribute DefaultOtaProvider
 */
class ReadOtaSoftwareUpdateRequestorDefaultOtaProvider : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorDefaultOtaProvider() : ModelCommand("read")
    {
        AddArgument("attr-name", "default-ota-provider");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorDefaultOtaProvider()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002A) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OtaSoftwareUpdateRequestorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeDefaultOtaProvider(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OctetStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteOtaSoftwareUpdateRequestorDefaultOtaProvider : public ModelCommand
{
public:
    WriteOtaSoftwareUpdateRequestorDefaultOtaProvider() : ModelCommand("write")
    {
        AddArgument("attr-name", "default-ota-provider");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOtaSoftwareUpdateRequestorDefaultOtaProvider()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002A) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::OtaSoftwareUpdateRequestorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeDefaultOtaProvider(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::ByteSpan mValue;
};

class ReportOtaSoftwareUpdateRequestorDefaultOtaProvider : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorDefaultOtaProvider() : ModelCommand("report")
    {
        AddArgument("attr-name", "default-ota-provider");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorDefaultOtaProvider()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002A) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OtaSoftwareUpdateRequestorCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeDefaultOtaProvider(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeDefaultOtaProvider(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<OctetStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdatePossible
 */
class ReadOtaSoftwareUpdateRequestorUpdatePossible : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorUpdatePossible() : ModelCommand("read")
    {
        AddArgument("attr-name", "update-possible");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdatePossible()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002A) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OtaSoftwareUpdateRequestorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeUpdatePossible(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOtaSoftwareUpdateRequestorUpdatePossible : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorUpdatePossible() : ModelCommand("report")
    {
        AddArgument("attr-name", "update-possible");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorUpdatePossible()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002A) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OtaSoftwareUpdateRequestorCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeUpdatePossible(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeUpdatePossible(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOtaSoftwareUpdateRequestorClusterRevision : public ModelCommand
{
public:
    ReadOtaSoftwareUpdateRequestorClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002A) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OtaSoftwareUpdateRequestorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOtaSoftwareUpdateRequestorClusterRevision : public ModelCommand
{
public:
    ReportOtaSoftwareUpdateRequestorClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002A) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OtaSoftwareUpdateRequestorCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OccupancySensing                                            | 0x0406 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Occupancy                                                         | 0x0000 |
| * OccupancySensorType                                               | 0x0001 |
| * OccupancySensorTypeBitmap                                         | 0x0002 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Occupancy
 */
class ReadOccupancySensingOccupancy : public ModelCommand
{
public:
    ReadOccupancySensingOccupancy() : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancy()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0406) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OccupancySensingCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOccupancy(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOccupancySensingOccupancy : public ModelCommand
{
public:
    ReportOccupancySensingOccupancy() : ModelCommand("report")
    {
        AddArgument("attr-name", "occupancy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingOccupancy()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0406) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OccupancySensingCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOccupancy(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOccupancy(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupancySensorType
 */
class ReadOccupancySensingOccupancySensorType : public ModelCommand
{
public:
    ReadOccupancySensingOccupancySensorType() : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy-sensor-type");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancySensorType()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0406) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OccupancySensingCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOccupancySensorType(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOccupancySensingOccupancySensorType : public ModelCommand
{
public:
    ReportOccupancySensingOccupancySensorType() : ModelCommand("report")
    {
        AddArgument("attr-name", "occupancy-sensor-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingOccupancySensorType()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0406) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OccupancySensingCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOccupancySensorType(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOccupancySensorType(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupancySensorTypeBitmap
 */
class ReadOccupancySensingOccupancySensorTypeBitmap : public ModelCommand
{
public:
    ReadOccupancySensingOccupancySensorTypeBitmap() : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy-sensor-type-bitmap");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancySensorTypeBitmap()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0406) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OccupancySensingCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOccupancySensorTypeBitmap(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOccupancySensingOccupancySensorTypeBitmap : public ModelCommand
{
public:
    ReportOccupancySensingOccupancySensorTypeBitmap() : ModelCommand("report")
    {
        AddArgument("attr-name", "occupancy-sensor-type-bitmap");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingOccupancySensorTypeBitmap()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0406) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OccupancySensingCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOccupancySensorTypeBitmap(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOccupancySensorTypeBitmap(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                   mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOccupancySensingClusterRevision : public ModelCommand
{
public:
    ReadOccupancySensingClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0406) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OccupancySensingCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOccupancySensingClusterRevision : public ModelCommand
{
public:
    ReportOccupancySensingClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0406) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OccupancySensingCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOff                                                       | 0x0006 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Off                                                               |   0x00 |
| * OffWithEffect                                                     |   0x40 |
| * On                                                                |   0x01 |
| * OnWithRecallGlobalScene                                           |   0x41 |
| * OnWithTimedOff                                                    |   0x42 |
| * Toggle                                                            |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OnOff                                                             | 0x0000 |
| * GlobalSceneControl                                                | 0x4000 |
| * OnTime                                                            | 0x4001 |
| * OffWaitTime                                                       | 0x4002 |
| * StartUpOnOff                                                      | 0x4003 |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command Off
 */
class OnOffOff : public ModelCommand
{
public:
    OnOffOff() : ModelCommand("off") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OnOff::Commands::Off::Type mRequest;
};

/*
 * Command OffWithEffect
 */
class OnOffOffWithEffect : public ModelCommand
{
public:
    OnOffOffWithEffect() : ModelCommand("off-with-effect")
    {
        AddArgument("EffectId", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.effectId)> *>(&mRequest.effectId));
        AddArgument("EffectVariant", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<decltype(mRequest.effectVariant)> *>(&mRequest.effectVariant));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000040) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OnOff::Commands::OffWithEffect::Type mRequest;
};

/*
 * Command On
 */
class OnOffOn : public ModelCommand
{
public:
    OnOffOn() : ModelCommand("on") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OnOff::Commands::On::Type mRequest;
};

/*
 * Command OnWithRecallGlobalScene
 */
class OnOffOnWithRecallGlobalScene : public ModelCommand
{
public:
    OnOffOnWithRecallGlobalScene() : ModelCommand("on-with-recall-global-scene") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000041) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OnOff::Commands::OnWithRecallGlobalScene::Type mRequest;
};

/*
 * Command OnWithTimedOff
 */
class OnOffOnWithTimedOff : public ModelCommand
{
public:
    OnOffOnWithTimedOff() : ModelCommand("on-with-timed-off")
    {
        AddArgument("OnOffControl", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<chip::app::Clusters::OnOff::OnOffControl> *>(&mRequest.onOffControl));
        AddArgument("OnTime", 0, UINT16_MAX, &mRequest.onTime);
        AddArgument("OffWaitTime", 0, UINT16_MAX, &mRequest.offWaitTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000042) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OnOff::Commands::OnWithTimedOff::Type mRequest;
};

/*
 * Command Toggle
 */
class OnOffToggle : public ModelCommand
{
public:
    OnOffToggle() : ModelCommand("toggle") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OnOff::Commands::Toggle::Type mRequest;
};

/*
 * Attribute OnOff
 */
class ReadOnOffOnOff : public ModelCommand
{
public:
    ReadOnOffOnOff() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-off");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOnOff()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOnOff(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOnOffOnOff : public ModelCommand
{
public:
    ReportOnOffOnOff() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffOnOff()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOnOff(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOnOff(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GlobalSceneControl
 */
class ReadOnOffGlobalSceneControl : public ModelCommand
{
public:
    ReadOnOffGlobalSceneControl() : ModelCommand("read")
    {
        AddArgument("attr-name", "global-scene-control");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffGlobalSceneControl()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeGlobalSceneControl(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOnOffGlobalSceneControl : public ModelCommand
{
public:
    ReportOnOffGlobalSceneControl() : ModelCommand("report")
    {
        AddArgument("attr-name", "global-scene-control");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffGlobalSceneControl()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeGlobalSceneControl(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeGlobalSceneControl(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnTime
 */
class ReadOnOffOnTime : public ModelCommand
{
public:
    ReadOnOffOnTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "on-time");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOnTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOnTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteOnOffOnTime : public ModelCommand
{
public:
    WriteOnOffOnTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "on-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffOnTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOnTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportOnOffOnTime : public ModelCommand
{
public:
    ReportOnOffOnTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "on-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffOnTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOnTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOnTime(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OffWaitTime
 */
class ReadOnOffOffWaitTime : public ModelCommand
{
public:
    ReadOnOffOffWaitTime() : ModelCommand("read")
    {
        AddArgument("attr-name", "off-wait-time");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOffWaitTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOffWaitTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteOnOffOffWaitTime : public ModelCommand
{
public:
    WriteOnOffOffWaitTime() : ModelCommand("write")
    {
        AddArgument("attr-name", "off-wait-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffOffWaitTime()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOffWaitTime(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportOnOffOffWaitTime : public ModelCommand
{
public:
    ReportOnOffOffWaitTime() : ModelCommand("report")
    {
        AddArgument("attr-name", "off-wait-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffOffWaitTime()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOffWaitTime(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOffWaitTime(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpOnOff
 */
class ReadOnOffStartUpOnOff : public ModelCommand
{
public:
    ReadOnOffStartUpOnOff() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-on-off");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffStartUpOnOff()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeStartUpOnOff(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteOnOffStartUpOnOff : public ModelCommand
{
public:
    WriteOnOffStartUpOnOff() : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-on-off");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffStartUpOnOff()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeStartUpOnOff(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportOnOffStartUpOnOff : public ModelCommand
{
public:
    ReportOnOffStartUpOnOff() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-up-on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffStartUpOnOff()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeStartUpOnOff(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeStartUpOnOff(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadOnOffFeatureMap : public ModelCommand
{
public:
    ReadOnOffFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffFeatureMap()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeFeatureMap(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOnOffFeatureMap : public ModelCommand
{
public:
    ReportOnOffFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffFeatureMap()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeFeatureMap(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeFeatureMap(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOnOffClusterRevision : public ModelCommand
{
public:
    ReadOnOffClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOnOffClusterRevision : public ModelCommand
{
public:
    ReportOnOffClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0006) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOffSwitchConfiguration                                    | 0x0007 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SwitchType                                                        | 0x0000 |
| * SwitchActions                                                     | 0x0010 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute SwitchType
 */
class ReadOnOffSwitchConfigurationSwitchType : public ModelCommand
{
public:
    ReadOnOffSwitchConfigurationSwitchType() : ModelCommand("read")
    {
        AddArgument("attr-name", "switch-type");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationSwitchType()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0007) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffSwitchConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSwitchType(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOnOffSwitchConfigurationSwitchType : public ModelCommand
{
public:
    ReportOnOffSwitchConfigurationSwitchType() : ModelCommand("report")
    {
        AddArgument("attr-name", "switch-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationSwitchType()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0007) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffSwitchConfigurationCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSwitchType(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSwitchType(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SwitchActions
 */
class ReadOnOffSwitchConfigurationSwitchActions : public ModelCommand
{
public:
    ReadOnOffSwitchConfigurationSwitchActions() : ModelCommand("read")
    {
        AddArgument("attr-name", "switch-actions");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationSwitchActions()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0007) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffSwitchConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSwitchActions(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteOnOffSwitchConfigurationSwitchActions : public ModelCommand
{
public:
    WriteOnOffSwitchConfigurationSwitchActions() : ModelCommand("write")
    {
        AddArgument("attr-name", "switch-actions");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffSwitchConfigurationSwitchActions()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0007) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffSwitchConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeSwitchActions(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportOnOffSwitchConfigurationSwitchActions : public ModelCommand
{
public:
    ReportOnOffSwitchConfigurationSwitchActions() : ModelCommand("report")
    {
        AddArgument("attr-name", "switch-actions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationSwitchActions()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0007) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffSwitchConfigurationCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSwitchActions(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSwitchActions(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOnOffSwitchConfigurationClusterRevision : public ModelCommand
{
public:
    ReadOnOffSwitchConfigurationClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0007) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffSwitchConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOnOffSwitchConfigurationClusterRevision : public ModelCommand
{
public:
    ReportOnOffSwitchConfigurationClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0007) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OnOffSwitchConfigurationCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OperationalCredentials                                      | 0x003E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddNOC                                                            |   0x06 |
| * AddTrustedRootCertificate                                         |   0x0B |
| * AttestationRequest                                                |   0x00 |
| * CertificateChainRequest                                           |   0x02 |
| * OpCSRRequest                                                      |   0x04 |
| * RemoveFabric                                                      |   0x0A |
| * RemoveTrustedRootCertificate                                      |   0x0C |
| * UpdateFabricLabel                                                 |   0x09 |
| * UpdateNOC                                                         |   0x07 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * FabricsList                                                       | 0x0001 |
| * SupportedFabrics                                                  | 0x0002 |
| * CommissionedFabrics                                               | 0x0003 |
| * TrustedRootCertificates                                           | 0x0004 |
| * CurrentFabricIndex                                                | 0x0005 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command AddNOC
 */
class OperationalCredentialsAddNOC : public ModelCommand
{
public:
    OperationalCredentialsAddNOC() : ModelCommand("add-noc")
    {
        AddArgument("NOCValue", &mRequest.NOCValue);
        AddArgument("ICACValue", &mRequest.ICACValue);
        AddArgument("IPKValue", &mRequest.IPKValue);
        AddArgument("CaseAdminNode", 0, UINT64_MAX, &mRequest.caseAdminNode);
        AddArgument("AdminVendorId", 0, UINT16_MAX, &mRequest.adminVendorId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000006) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsNOCResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::AddNOC::Type mRequest;
};

/*
 * Command AddTrustedRootCertificate
 */
class OperationalCredentialsAddTrustedRootCertificate : public ModelCommand
{
public:
    OperationalCredentialsAddTrustedRootCertificate() : ModelCommand("add-trusted-root-certificate")
    {
        AddArgument("RootCertificate", &mRequest.rootCertificate);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000B) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::AddTrustedRootCertificate::Type mRequest;
};

/*
 * Command AttestationRequest
 */
class OperationalCredentialsAttestationRequest : public ModelCommand
{
public:
    OperationalCredentialsAttestationRequest() : ModelCommand("attestation-request")
    {
        AddArgument("AttestationNonce", &mRequest.attestationNonce);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsAttestationResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::AttestationRequest::Type mRequest;
};

/*
 * Command CertificateChainRequest
 */
class OperationalCredentialsCertificateChainRequest : public ModelCommand
{
public:
    OperationalCredentialsCertificateChainRequest() : ModelCommand("certificate-chain-request")
    {
        AddArgument("CertificateType", 0, UINT8_MAX, &mRequest.certificateType);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsCertificateChainResponseSuccess,
                                               OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::CertificateChainRequest::Type mRequest;
};

/*
 * Command OpCSRRequest
 */
class OperationalCredentialsOpCSRRequest : public ModelCommand
{
public:
    OperationalCredentialsOpCSRRequest() : ModelCommand("op-csrrequest")
    {
        AddArgument("CSRNonce", &mRequest.CSRNonce);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsOpCSRResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::OpCSRRequest::Type mRequest;
};

/*
 * Command RemoveFabric
 */
class OperationalCredentialsRemoveFabric : public ModelCommand
{
public:
    OperationalCredentialsRemoveFabric() : ModelCommand("remove-fabric")
    {
        AddArgument("FabricIndex", 0, UINT8_MAX, &mRequest.fabricIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000A) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsNOCResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::RemoveFabric::Type mRequest;
};

/*
 * Command RemoveTrustedRootCertificate
 */
class OperationalCredentialsRemoveTrustedRootCertificate : public ModelCommand
{
public:
    OperationalCredentialsRemoveTrustedRootCertificate() : ModelCommand("remove-trusted-root-certificate")
    {
        AddArgument("TrustedRootIdentifier", &mRequest.trustedRootIdentifier);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000C) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::RemoveTrustedRootCertificate::Type mRequest;
};

/*
 * Command UpdateFabricLabel
 */
class OperationalCredentialsUpdateFabricLabel : public ModelCommand
{
public:
    OperationalCredentialsUpdateFabricLabel() : ModelCommand("update-fabric-label")
    {
        AddArgument("Label", &mRequest.label);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000009) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsNOCResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::UpdateFabricLabel::Type mRequest;
};

/*
 * Command UpdateNOC
 */
class OperationalCredentialsUpdateNOC : public ModelCommand
{
public:
    OperationalCredentialsUpdateNOC() : ModelCommand("update-noc")
    {
        AddArgument("NOCValue", &mRequest.NOCValue);
        AddArgument("ICACValue", &mRequest.ICACValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000007) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnOperationalCredentialsNOCResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::OperationalCredentials::Commands::UpdateNOC::Type mRequest;
};

/*
 * Attribute FabricsList
 */
class ReadOperationalCredentialsFabricsList : public ModelCommand
{
public:
    ReadOperationalCredentialsFabricsList() : ModelCommand("read")
    {
        AddArgument("attr-name", "fabrics-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsFabricsList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003E) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OperationalCredentialsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeFabricsList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback>(
            OnOperationalCredentialsFabricsListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute SupportedFabrics
 */
class ReadOperationalCredentialsSupportedFabrics : public ModelCommand
{
public:
    ReadOperationalCredentialsSupportedFabrics() : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsSupportedFabrics()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003E) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OperationalCredentialsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSupportedFabrics(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOperationalCredentialsSupportedFabrics : public ModelCommand
{
public:
    ReportOperationalCredentialsSupportedFabrics() : ModelCommand("report")
    {
        AddArgument("attr-name", "supported-fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsSupportedFabrics()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003E) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OperationalCredentialsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSupportedFabrics(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSupportedFabrics(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CommissionedFabrics
 */
class ReadOperationalCredentialsCommissionedFabrics : public ModelCommand
{
public:
    ReadOperationalCredentialsCommissionedFabrics() : ModelCommand("read")
    {
        AddArgument("attr-name", "commissioned-fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsCommissionedFabrics()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003E) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OperationalCredentialsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCommissionedFabrics(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOperationalCredentialsCommissionedFabrics : public ModelCommand
{
public:
    ReportOperationalCredentialsCommissionedFabrics() : ModelCommand("report")
    {
        AddArgument("attr-name", "commissioned-fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsCommissionedFabrics()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003E) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OperationalCredentialsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCommissionedFabrics(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCommissionedFabrics(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TrustedRootCertificates
 */
class ReadOperationalCredentialsTrustedRootCertificates : public ModelCommand
{
public:
    ReadOperationalCredentialsTrustedRootCertificates() : ModelCommand("read")
    {
        AddArgument("attr-name", "trusted-root-certificates");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsTrustedRootCertificates()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003E) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OperationalCredentialsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTrustedRootCertificates(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback>(
            OnOperationalCredentialsTrustedRootCertificatesListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute CurrentFabricIndex
 */
class ReadOperationalCredentialsCurrentFabricIndex : public ModelCommand
{
public:
    ReadOperationalCredentialsCurrentFabricIndex() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-fabric-index");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsCurrentFabricIndex()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003E) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OperationalCredentialsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentFabricIndex(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOperationalCredentialsCurrentFabricIndex : public ModelCommand
{
public:
    ReportOperationalCredentialsCurrentFabricIndex() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-fabric-index");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsCurrentFabricIndex()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003E) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OperationalCredentialsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentFabricIndex(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentFabricIndex(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOperationalCredentialsClusterRevision : public ModelCommand
{
public:
    ReadOperationalCredentialsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003E) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::OperationalCredentialsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportOperationalCredentialsClusterRevision : public ModelCommand
{
public:
    ReportOperationalCredentialsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003E) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::OperationalCredentialsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PowerSource                                                 | 0x002F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Status                                                            | 0x0000 |
| * Order                                                             | 0x0001 |
| * Description                                                       | 0x0002 |
| * BatteryVoltage                                                    | 0x000B |
| * BatteryPercentRemaining                                           | 0x000C |
| * BatteryTimeRemaining                                              | 0x000D |
| * BatteryChargeLevel                                                | 0x000E |
| * ActiveBatteryFaults                                               | 0x0012 |
| * BatteryChargeState                                                | 0x001A |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Status
 */
class ReadPowerSourceStatus : public ModelCommand
{
public:
    ReadPowerSourceStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "status");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceStatus()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeStatus(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPowerSourceStatus : public ModelCommand
{
public:
    ReportPowerSourceStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceStatus()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeStatus(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeStatus(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Order
 */
class ReadPowerSourceOrder : public ModelCommand
{
public:
    ReadPowerSourceOrder() : ModelCommand("read")
    {
        AddArgument("attr-name", "order");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceOrder()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOrder(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPowerSourceOrder : public ModelCommand
{
public:
    ReportPowerSourceOrder() : ModelCommand("report")
    {
        AddArgument("attr-name", "order");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceOrder()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOrder(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOrder(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Description
 */
class ReadPowerSourceDescription : public ModelCommand
{
public:
    ReadPowerSourceDescription() : ModelCommand("read")
    {
        AddArgument("attr-name", "description");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceDescription()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeDescription(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPowerSourceDescription : public ModelCommand
{
public:
    ReportPowerSourceDescription() : ModelCommand("report")
    {
        AddArgument("attr-name", "description");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceDescription()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeDescription(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeDescription(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryVoltage
 */
class ReadPowerSourceBatteryVoltage : public ModelCommand
{
public:
    ReadPowerSourceBatteryVoltage() : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-voltage");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryVoltage()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBatteryVoltage(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPowerSourceBatteryVoltage : public ModelCommand
{
public:
    ReportPowerSourceBatteryVoltage() : ModelCommand("report")
    {
        AddArgument("attr-name", "battery-voltage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryVoltage()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBatteryVoltage(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBatteryVoltage(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryPercentRemaining
 */
class ReadPowerSourceBatteryPercentRemaining : public ModelCommand
{
public:
    ReadPowerSourceBatteryPercentRemaining() : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-percent-remaining");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryPercentRemaining()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBatteryPercentRemaining(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPowerSourceBatteryPercentRemaining : public ModelCommand
{
public:
    ReportPowerSourceBatteryPercentRemaining() : ModelCommand("report")
    {
        AddArgument("attr-name", "battery-percent-remaining");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryPercentRemaining()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBatteryPercentRemaining(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBatteryPercentRemaining(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                 mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryTimeRemaining
 */
class ReadPowerSourceBatteryTimeRemaining : public ModelCommand
{
public:
    ReadPowerSourceBatteryTimeRemaining() : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-time-remaining");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryTimeRemaining()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBatteryTimeRemaining(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPowerSourceBatteryTimeRemaining : public ModelCommand
{
public:
    ReportPowerSourceBatteryTimeRemaining() : ModelCommand("report")
    {
        AddArgument("attr-name", "battery-time-remaining");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryTimeRemaining()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBatteryTimeRemaining(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBatteryTimeRemaining(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryChargeLevel
 */
class ReadPowerSourceBatteryChargeLevel : public ModelCommand
{
public:
    ReadPowerSourceBatteryChargeLevel() : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-charge-level");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryChargeLevel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBatteryChargeLevel(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPowerSourceBatteryChargeLevel : public ModelCommand
{
public:
    ReportPowerSourceBatteryChargeLevel() : ModelCommand("report")
    {
        AddArgument("attr-name", "battery-charge-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryChargeLevel()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBatteryChargeLevel(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBatteryChargeLevel(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveBatteryFaults
 */
class ReadPowerSourceActiveBatteryFaults : public ModelCommand
{
public:
    ReadPowerSourceActiveBatteryFaults() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-battery-faults");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceActiveBatteryFaults()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActiveBatteryFaults(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<PowerSourceActiveBatteryFaultsListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<PowerSourceActiveBatteryFaultsListAttributeCallback>(
            OnPowerSourceActiveBatteryFaultsListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute BatteryChargeState
 */
class ReadPowerSourceBatteryChargeState : public ModelCommand
{
public:
    ReadPowerSourceBatteryChargeState() : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-charge-state");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryChargeState()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBatteryChargeState(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPowerSourceBatteryChargeState : public ModelCommand
{
public:
    ReportPowerSourceBatteryChargeState() : ModelCommand("report")
    {
        AddArgument("attr-name", "battery-charge-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryChargeState()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBatteryChargeState(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBatteryChargeState(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadPowerSourceFeatureMap : public ModelCommand
{
public:
    ReadPowerSourceFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceFeatureMap()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeFeatureMap(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPowerSourceFeatureMap : public ModelCommand
{
public:
    ReportPowerSourceFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceFeatureMap()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeFeatureMap(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeFeatureMap(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPowerSourceClusterRevision : public ModelCommand
{
public:
    ReadPowerSourceClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPowerSourceClusterRevision : public ModelCommand
{
public:
    ReportPowerSourceClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x002F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PowerSourceCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PressureMeasurement                                         | 0x0403 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadPressureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadPressureMeasurementMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0403) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PressureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPressureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportPressureMeasurementMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0403) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PressureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadPressureMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadPressureMeasurementMinMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMinMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0403) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PressureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPressureMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReportPressureMeasurementMinMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementMinMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0403) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PressureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadPressureMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadPressureMeasurementMaxMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMaxMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0403) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PressureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPressureMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReportPressureMeasurementMaxMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementMaxMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0403) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PressureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPressureMeasurementClusterRevision : public ModelCommand
{
public:
    ReadPressureMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0403) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PressureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPressureMeasurementClusterRevision : public ModelCommand
{
public:
    ReportPressureMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0403) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PressureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PumpConfigurationAndControl                                 | 0x0200 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MaxPressure                                                       | 0x0000 |
| * MaxSpeed                                                          | 0x0001 |
| * MaxFlow                                                           | 0x0002 |
| * MinConstPressure                                                  | 0x0003 |
| * MaxConstPressure                                                  | 0x0004 |
| * MinCompPressure                                                   | 0x0005 |
| * MaxCompPressure                                                   | 0x0006 |
| * MinConstSpeed                                                     | 0x0007 |
| * MaxConstSpeed                                                     | 0x0008 |
| * MinConstFlow                                                      | 0x0009 |
| * MaxConstFlow                                                      | 0x000A |
| * MinConstTemp                                                      | 0x000B |
| * MaxConstTemp                                                      | 0x000C |
| * PumpStatus                                                        | 0x0010 |
| * EffectiveOperationMode                                            | 0x0011 |
| * EffectiveControlMode                                              | 0x0012 |
| * Capacity                                                          | 0x0013 |
| * Speed                                                             | 0x0014 |
| * LifetimeEnergyConsumed                                            | 0x0017 |
| * OperationMode                                                     | 0x0020 |
| * ControlMode                                                       | 0x0021 |
| * AlarmMask                                                         | 0x0022 |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MaxPressure
 */
class ReadPumpConfigurationAndControlMaxPressure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxPressure() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxPressure()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxPressure(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMaxPressure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxPressure() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxPressure()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxPressure(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxPressure(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxSpeed
 */
class ReadPumpConfigurationAndControlMaxSpeed : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxSpeed() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxSpeed()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxSpeed(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMaxSpeed : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxSpeed() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxSpeed()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxSpeed(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxSpeed(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxFlow
 */
class ReadPumpConfigurationAndControlMaxFlow : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxFlow() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxFlow()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxFlow(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMaxFlow : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxFlow() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxFlow()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxFlow(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxFlow(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstPressure
 */
class ReadPumpConfigurationAndControlMinConstPressure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMinConstPressure() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstPressure()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinConstPressure(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMinConstPressure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMinConstPressure() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-const-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstPressure()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinConstPressure(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinConstPressure(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstPressure
 */
class ReadPumpConfigurationAndControlMaxConstPressure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxConstPressure() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstPressure()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxConstPressure(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMaxConstPressure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxConstPressure() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-const-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstPressure()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxConstPressure(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxConstPressure(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinCompPressure
 */
class ReadPumpConfigurationAndControlMinCompPressure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMinCompPressure() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-comp-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinCompPressure()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinCompPressure(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMinCompPressure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMinCompPressure() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-comp-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinCompPressure()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinCompPressure(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinCompPressure(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxCompPressure
 */
class ReadPumpConfigurationAndControlMaxCompPressure : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxCompPressure() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-comp-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxCompPressure()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxCompPressure(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMaxCompPressure : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxCompPressure() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-comp-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxCompPressure()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxCompPressure(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxCompPressure(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstSpeed
 */
class ReadPumpConfigurationAndControlMinConstSpeed : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMinConstSpeed() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstSpeed()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinConstSpeed(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMinConstSpeed : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMinConstSpeed() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-const-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstSpeed()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinConstSpeed(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinConstSpeed(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstSpeed
 */
class ReadPumpConfigurationAndControlMaxConstSpeed : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxConstSpeed() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstSpeed()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxConstSpeed(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMaxConstSpeed : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxConstSpeed() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-const-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstSpeed()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxConstSpeed(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxConstSpeed(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstFlow
 */
class ReadPumpConfigurationAndControlMinConstFlow : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMinConstFlow() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstFlow()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinConstFlow(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMinConstFlow : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMinConstFlow() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-const-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstFlow()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinConstFlow(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinConstFlow(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstFlow
 */
class ReadPumpConfigurationAndControlMaxConstFlow : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxConstFlow() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstFlow()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxConstFlow(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMaxConstFlow : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxConstFlow() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-const-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstFlow()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxConstFlow(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxConstFlow(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstTemp
 */
class ReadPumpConfigurationAndControlMinConstTemp : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMinConstTemp() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-temp");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstTemp()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinConstTemp(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMinConstTemp : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMinConstTemp() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-const-temp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstTemp()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinConstTemp(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinConstTemp(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstTemp
 */
class ReadPumpConfigurationAndControlMaxConstTemp : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlMaxConstTemp() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-temp");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstTemp()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxConstTemp(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlMaxConstTemp : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlMaxConstTemp() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-const-temp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstTemp()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxConstTemp(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxConstTemp(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PumpStatus
 */
class ReadPumpConfigurationAndControlPumpStatus : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlPumpStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "pump-status");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPumpStatus()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePumpStatus(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlPumpStatus : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlPumpStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "pump-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPumpStatus()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePumpStatus(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePumpStatus(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EffectiveOperationMode
 */
class ReadPumpConfigurationAndControlEffectiveOperationMode : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlEffectiveOperationMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "effective-operation-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlEffectiveOperationMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeEffectiveOperationMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlEffectiveOperationMode : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlEffectiveOperationMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "effective-operation-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlEffectiveOperationMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeEffectiveOperationMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeEffectiveOperationMode(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EffectiveControlMode
 */
class ReadPumpConfigurationAndControlEffectiveControlMode : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlEffectiveControlMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "effective-control-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlEffectiveControlMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeEffectiveControlMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlEffectiveControlMode : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlEffectiveControlMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "effective-control-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlEffectiveControlMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeEffectiveControlMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeEffectiveControlMode(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Capacity
 */
class ReadPumpConfigurationAndControlCapacity : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlCapacity() : ModelCommand("read")
    {
        AddArgument("attr-name", "capacity");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlCapacity()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCapacity(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlCapacity : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlCapacity() : ModelCommand("report")
    {
        AddArgument("attr-name", "capacity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlCapacity()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCapacity(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCapacity(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Speed
 */
class ReadPumpConfigurationAndControlSpeed : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlSpeed() : ModelCommand("read")
    {
        AddArgument("attr-name", "speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSpeed()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSpeed(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlSpeed : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlSpeed() : ModelCommand("report")
    {
        AddArgument("attr-name", "speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSpeed()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSpeed(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSpeed(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LifetimeEnergyConsumed
 */
class ReadPumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlLifetimeEnergyConsumed() : ModelCommand("read")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLifetimeEnergyConsumed()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLifetimeEnergyConsumed(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlLifetimeEnergyConsumed() : ModelCommand("report")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlLifetimeEnergyConsumed()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLifetimeEnergyConsumed(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLifetimeEnergyConsumed(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationMode
 */
class ReadPumpConfigurationAndControlOperationMode : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlOperationMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "operation-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlOperationMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOperationMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WritePumpConfigurationAndControlOperationMode : public ModelCommand
{
public:
    WritePumpConfigurationAndControlOperationMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "operation-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlOperationMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOperationMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportPumpConfigurationAndControlOperationMode : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlOperationMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "operation-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlOperationMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOperationMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOperationMode(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ControlMode
 */
class ReadPumpConfigurationAndControlControlMode : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlControlMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "control-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlControlMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeControlMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WritePumpConfigurationAndControlControlMode : public ModelCommand
{
public:
    WritePumpConfigurationAndControlControlMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "control-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlControlMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeControlMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportPumpConfigurationAndControlControlMode : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlControlMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "control-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlControlMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeControlMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeControlMode(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AlarmMask
 */
class ReadPumpConfigurationAndControlAlarmMask : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlAlarmMask() : ModelCommand("read")
    {
        AddArgument("attr-name", "alarm-mask");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAlarmMask()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeAlarmMask(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlAlarmMask : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlAlarmMask() : ModelCommand("report")
    {
        AddArgument("attr-name", "alarm-mask");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlAlarmMask()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeAlarmMask(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeAlarmMask(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadPumpConfigurationAndControlFeatureMap : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlFeatureMap()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeFeatureMap(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlFeatureMap : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlFeatureMap()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeFeatureMap(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeFeatureMap(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPumpConfigurationAndControlClusterRevision : public ModelCommand
{
public:
    ReadPumpConfigurationAndControlClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportPumpConfigurationAndControlClusterRevision : public ModelCommand
{
public:
    ReportPumpConfigurationAndControlClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0200) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::PumpConfigurationAndControlCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster RelativeHumidityMeasurement                                 | 0x0405 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadRelativeHumidityMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0405) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::RelativeHumidityMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportRelativeHumidityMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0405) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::RelativeHumidityMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadRelativeHumidityMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementMinMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMinMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0405) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::RelativeHumidityMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportRelativeHumidityMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementMinMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementMinMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0405) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::RelativeHumidityMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadRelativeHumidityMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementMaxMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMaxMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0405) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::RelativeHumidityMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportRelativeHumidityMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementMaxMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementMaxMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0405) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::RelativeHumidityMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadRelativeHumidityMeasurementTolerance : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementTolerance() : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementTolerance()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0405) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::RelativeHumidityMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTolerance(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportRelativeHumidityMeasurementTolerance : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementTolerance() : ModelCommand("report")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementTolerance()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0405) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::RelativeHumidityMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTolerance(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTolerance(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadRelativeHumidityMeasurementClusterRevision : public ModelCommand
{
public:
    ReadRelativeHumidityMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0405) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::RelativeHumidityMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportRelativeHumidityMeasurementClusterRevision : public ModelCommand
{
public:
    ReportRelativeHumidityMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0405) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::RelativeHumidityMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Scenes                                                      | 0x0005 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddScene                                                          |   0x00 |
| * GetSceneMembership                                                |   0x06 |
| * RecallScene                                                       |   0x05 |
| * RemoveAllScenes                                                   |   0x03 |
| * RemoveScene                                                       |   0x02 |
| * StoreScene                                                        |   0x04 |
| * ViewScene                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SceneCount                                                        | 0x0000 |
| * CurrentScene                                                      | 0x0001 |
| * CurrentGroup                                                      | 0x0002 |
| * SceneValid                                                        | 0x0003 |
| * NameSupport                                                       | 0x0004 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command AddScene
 */
class ScenesAddScene : public ModelCommand
{
public:
    ScenesAddScene() : ModelCommand("add-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mRequest.sceneId);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        AddArgument("SceneName", &mRequest.sceneName);
        // extensionFieldSets Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesAddSceneResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::Scenes::Commands::AddScene::Type mRequest;
};

/*
 * Command GetSceneMembership
 */
class ScenesGetSceneMembership : public ModelCommand
{
public:
    ScenesGetSceneMembership() : ModelCommand("get-scene-membership")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000006) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesGetSceneMembershipResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::Scenes::Commands::GetSceneMembership::Type mRequest;
};

/*
 * Command RecallScene
 */
class ScenesRecallScene : public ModelCommand
{
public:
    ScenesRecallScene() : ModelCommand("recall-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mRequest.sceneId);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mRequest.transitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000005) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Scenes::Commands::RecallScene::Type mRequest;
};

/*
 * Command RemoveAllScenes
 */
class ScenesRemoveAllScenes : public ModelCommand
{
public:
    ScenesRemoveAllScenes() : ModelCommand("remove-all-scenes")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000003) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesRemoveAllScenesResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::Scenes::Commands::RemoveAllScenes::Type mRequest;
};

/*
 * Command RemoveScene
 */
class ScenesRemoveScene : public ModelCommand
{
public:
    ScenesRemoveScene() : ModelCommand("remove-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mRequest.sceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesRemoveSceneResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::Scenes::Commands::RemoveScene::Type mRequest;
};

/*
 * Command StoreScene
 */
class ScenesStoreScene : public ModelCommand
{
public:
    ScenesStoreScene() : ModelCommand("store-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mRequest.sceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesStoreSceneResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::Scenes::Commands::StoreScene::Type mRequest;
};

/*
 * Command ViewScene
 */
class ScenesViewScene : public ModelCommand
{
public:
    ScenesViewScene() : ModelCommand("view-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mRequest.groupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mRequest.sceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnScenesViewSceneResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::Scenes::Commands::ViewScene::Type mRequest;
};

/*
 * Attribute SceneCount
 */
class ReadScenesSceneCount : public ModelCommand
{
public:
    ReadScenesSceneCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "scene-count");
        ModelCommand::AddArguments();
    }

    ~ReadScenesSceneCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSceneCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportScenesSceneCount : public ModelCommand
{
public:
    ReportScenesSceneCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "scene-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesSceneCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSceneCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSceneCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentScene
 */
class ReadScenesCurrentScene : public ModelCommand
{
public:
    ReadScenesCurrentScene() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-scene");
        ModelCommand::AddArguments();
    }

    ~ReadScenesCurrentScene()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentScene(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportScenesCurrentScene : public ModelCommand
{
public:
    ReportScenesCurrentScene() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-scene");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesCurrentScene()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentScene(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentScene(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentGroup
 */
class ReadScenesCurrentGroup : public ModelCommand
{
public:
    ReadScenesCurrentGroup() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-group");
        ModelCommand::AddArguments();
    }

    ~ReadScenesCurrentGroup()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentGroup(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportScenesCurrentGroup : public ModelCommand
{
public:
    ReportScenesCurrentGroup() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-group");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesCurrentGroup()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentGroup(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentGroup(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SceneValid
 */
class ReadScenesSceneValid : public ModelCommand
{
public:
    ReadScenesSceneValid() : ModelCommand("read")
    {
        AddArgument("attr-name", "scene-valid");
        ModelCommand::AddArguments();
    }

    ~ReadScenesSceneValid()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSceneValid(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportScenesSceneValid : public ModelCommand
{
public:
    ReportScenesSceneValid() : ModelCommand("report")
    {
        AddArgument("attr-name", "scene-valid");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesSceneValid()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSceneValid(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSceneValid(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NameSupport
 */
class ReadScenesNameSupport : public ModelCommand
{
public:
    ReadScenesNameSupport() : ModelCommand("read")
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    ~ReadScenesNameSupport()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNameSupport(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportScenesNameSupport : public ModelCommand
{
public:
    ReportScenesNameSupport() : ModelCommand("report")
    {
        AddArgument("attr-name", "name-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesNameSupport()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNameSupport(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNameSupport(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadScenesClusterRevision : public ModelCommand
{
public:
    ReadScenesClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadScenesClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportScenesClusterRevision : public ModelCommand
{
public:
    ReportScenesClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0005) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ScenesCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster SoftwareDiagnostics                                         | 0x0034 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetWatermarks                                                   |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ThreadMetrics                                                     | 0x0000 |
| * CurrentHeapFree                                                   | 0x0001 |
| * CurrentHeapUsed                                                   | 0x0002 |
| * CurrentHeapHighWatermark                                          | 0x0003 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetWatermarks
 */
class SoftwareDiagnosticsResetWatermarks : public ModelCommand
{
public:
    SoftwareDiagnosticsResetWatermarks() : ModelCommand("reset-watermarks") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::SoftwareDiagnostics::Commands::ResetWatermarks::Type mRequest;
};

/*
 * Attribute ThreadMetrics
 */
class ReadSoftwareDiagnosticsThreadMetrics : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsThreadMetrics() : ModelCommand("read")
    {
        AddArgument("attr-name", "thread-metrics");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsThreadMetrics()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0034) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::SoftwareDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeThreadMetrics(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<SoftwareDiagnosticsThreadMetricsListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<SoftwareDiagnosticsThreadMetricsListAttributeCallback>(
            OnSoftwareDiagnosticsThreadMetricsListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute CurrentHeapFree
 */
class ReadSoftwareDiagnosticsCurrentHeapFree : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsCurrentHeapFree() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-free");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapFree()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0034) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::SoftwareDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentHeapFree(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportSoftwareDiagnosticsCurrentHeapFree : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsCurrentHeapFree() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-heap-free");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsCurrentHeapFree()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0034) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::SoftwareDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentHeapFree(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentHeapFree(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapUsed
 */
class ReadSoftwareDiagnosticsCurrentHeapUsed : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsCurrentHeapUsed() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-used");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapUsed()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0034) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::SoftwareDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentHeapUsed(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportSoftwareDiagnosticsCurrentHeapUsed : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsCurrentHeapUsed() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-heap-used");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsCurrentHeapUsed()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0034) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::SoftwareDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentHeapUsed(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentHeapUsed(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapHighWatermark
 */
class ReadSoftwareDiagnosticsCurrentHeapHighWatermark : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsCurrentHeapHighWatermark() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-high-watermark");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapHighWatermark()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0034) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::SoftwareDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentHeapHighWatermark(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportSoftwareDiagnosticsCurrentHeapHighWatermark : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsCurrentHeapHighWatermark() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-heap-high-watermark");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsCurrentHeapHighWatermark()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0034) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::SoftwareDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentHeapHighWatermark(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentHeapHighWatermark(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                  mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadSoftwareDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReadSoftwareDiagnosticsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0034) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::SoftwareDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportSoftwareDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReportSoftwareDiagnosticsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0034) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::SoftwareDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Switch                                                      | 0x003B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NumberOfPositions                                                 | 0x0000 |
| * CurrentPosition                                                   | 0x0001 |
| * MultiPressMax                                                     | 0x0002 |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute NumberOfPositions
 */
class ReadSwitchNumberOfPositions : public ModelCommand
{
public:
    ReadSwitchNumberOfPositions() : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-positions");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchNumberOfPositions()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003B) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::SwitchCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNumberOfPositions(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportSwitchNumberOfPositions : public ModelCommand
{
public:
    ReportSwitchNumberOfPositions() : ModelCommand("report")
    {
        AddArgument("attr-name", "number-of-positions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchNumberOfPositions()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003B) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::SwitchCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNumberOfPositions(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNumberOfPositions(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPosition
 */
class ReadSwitchCurrentPosition : public ModelCommand
{
public:
    ReadSwitchCurrentPosition() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchCurrentPosition()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003B) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::SwitchCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentPosition(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportSwitchCurrentPosition : public ModelCommand
{
public:
    ReportSwitchCurrentPosition() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchCurrentPosition()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003B) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::SwitchCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentPosition(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentPosition(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MultiPressMax
 */
class ReadSwitchMultiPressMax : public ModelCommand
{
public:
    ReadSwitchMultiPressMax() : ModelCommand("read")
    {
        AddArgument("attr-name", "multi-press-max");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchMultiPressMax()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003B) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::SwitchCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMultiPressMax(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportSwitchMultiPressMax : public ModelCommand
{
public:
    ReportSwitchMultiPressMax() : ModelCommand("report")
    {
        AddArgument("attr-name", "multi-press-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchMultiPressMax()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003B) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::SwitchCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMultiPressMax(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMultiPressMax(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadSwitchFeatureMap : public ModelCommand
{
public:
    ReadSwitchFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchFeatureMap()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003B) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::SwitchCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeFeatureMap(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportSwitchFeatureMap : public ModelCommand
{
public:
    ReportSwitchFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchFeatureMap()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003B) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::SwitchCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeFeatureMap(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeFeatureMap(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadSwitchClusterRevision : public ModelCommand
{
public:
    ReadSwitchClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003B) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::SwitchCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportSwitchClusterRevision : public ModelCommand
{
public:
    ReportSwitchClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x003B) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::SwitchCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TvChannel                                                   | 0x0504 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeChannel                                                     |   0x00 |
| * ChangeChannelByNumber                                             |   0x01 |
| * SkipChannel                                                       |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TvChannelList                                                     | 0x0000 |
| * TvChannelLineup                                                   | 0x0001 |
| * CurrentTvChannel                                                  | 0x0002 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeChannel
 */
class TvChannelChangeChannel : public ModelCommand
{
public:
    TvChannelChangeChannel() : ModelCommand("change-channel")
    {
        AddArgument("Match", &mRequest.match);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTvChannelChangeChannelResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::TvChannel::Commands::ChangeChannel::Type mRequest;
};

/*
 * Command ChangeChannelByNumber
 */
class TvChannelChangeChannelByNumber : public ModelCommand
{
public:
    TvChannelChangeChannelByNumber() : ModelCommand("change-channel-by-number")
    {
        AddArgument("MajorNumber", 0, UINT16_MAX, &mRequest.majorNumber);
        AddArgument("MinorNumber", 0, UINT16_MAX, &mRequest.minorNumber);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::TvChannel::Commands::ChangeChannelByNumber::Type mRequest;
};

/*
 * Command SkipChannel
 */
class TvChannelSkipChannel : public ModelCommand
{
public:
    TvChannelSkipChannel() : ModelCommand("skip-channel")
    {
        AddArgument("Count", 0, UINT16_MAX, &mRequest.count);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::TvChannel::Commands::SkipChannel::Type mRequest;
};

/*
 * Attribute TvChannelList
 */
class ReadTvChannelTvChannelList : public ModelCommand
{
public:
    ReadTvChannelTvChannelList() : ModelCommand("read")
    {
        AddArgument("attr-name", "tv-channel-list");
        ModelCommand::AddArguments();
    }

    ~ReadTvChannelTvChannelList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0504) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TvChannelCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTvChannelList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<TvChannelTvChannelListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<TvChannelTvChannelListListAttributeCallback>(OnTvChannelTvChannelListListAttributeResponse,
                                                                                  this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute TvChannelLineup
 */
class ReadTvChannelTvChannelLineup : public ModelCommand
{
public:
    ReadTvChannelTvChannelLineup() : ModelCommand("read")
    {
        AddArgument("attr-name", "tv-channel-lineup");
        ModelCommand::AddArguments();
    }

    ~ReadTvChannelTvChannelLineup()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0504) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TvChannelCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTvChannelLineup(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OctetStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportTvChannelTvChannelLineup : public ModelCommand
{
public:
    ReportTvChannelTvChannelLineup() : ModelCommand("report")
    {
        AddArgument("attr-name", "tv-channel-lineup");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTvChannelTvChannelLineup()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0504) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TvChannelCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTvChannelLineup(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTvChannelLineup(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<OctetStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentTvChannel
 */
class ReadTvChannelCurrentTvChannel : public ModelCommand
{
public:
    ReadTvChannelCurrentTvChannel() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-tv-channel");
        ModelCommand::AddArguments();
    }

    ~ReadTvChannelCurrentTvChannel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0504) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TvChannelCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentTvChannel(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OctetStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportTvChannelCurrentTvChannel : public ModelCommand
{
public:
    ReportTvChannelCurrentTvChannel() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-tv-channel");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTvChannelCurrentTvChannel()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0504) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TvChannelCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentTvChannel(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentTvChannel(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<OctetStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTvChannelClusterRevision : public ModelCommand
{
public:
    ReadTvChannelClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTvChannelClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0504) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TvChannelCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportTvChannelClusterRevision : public ModelCommand
{
public:
    ReportTvChannelClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTvChannelClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0504) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TvChannelCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TargetNavigator                                             | 0x0505 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * NavigateTarget                                                    |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TargetNavigatorList                                               | 0x0000 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command NavigateTarget
 */
class TargetNavigatorNavigateTarget : public ModelCommand
{
public:
    TargetNavigatorNavigateTarget() : ModelCommand("navigate-target")
    {
        AddArgument("Target", 0, UINT8_MAX, &mRequest.target);
        AddArgument("Data", &mRequest.data);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTargetNavigatorNavigateTargetResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type mRequest;
};

/*
 * Attribute TargetNavigatorList
 */
class ReadTargetNavigatorTargetNavigatorList : public ModelCommand
{
public:
    ReadTargetNavigatorTargetNavigatorList() : ModelCommand("read")
    {
        AddArgument("attr-name", "target-navigator-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorTargetNavigatorList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0505) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TargetNavigatorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTargetNavigatorList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<TargetNavigatorTargetNavigatorListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<TargetNavigatorTargetNavigatorListListAttributeCallback>(
            OnTargetNavigatorTargetNavigatorListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ClusterRevision
 */
class ReadTargetNavigatorClusterRevision : public ModelCommand
{
public:
    ReadTargetNavigatorClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0505) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TargetNavigatorCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportTargetNavigatorClusterRevision : public ModelCommand
{
public:
    ReportTargetNavigatorClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0505) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TargetNavigatorCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TemperatureMeasurement                                      | 0x0402 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadTemperatureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0402) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TemperatureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportTemperatureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportTemperatureMeasurementMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0402) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TemperatureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadTemperatureMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMinMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMinMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0402) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TemperatureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportTemperatureMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReportTemperatureMeasurementMinMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementMinMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0402) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TemperatureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadTemperatureMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMaxMeasuredValue() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMaxMeasuredValue()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0402) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TemperatureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxMeasuredValue(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportTemperatureMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReportTemperatureMeasurementMaxMeasuredValue() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementMaxMeasuredValue()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0402) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TemperatureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxMeasuredValue(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxMeasuredValue(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadTemperatureMeasurementTolerance : public ModelCommand
{
public:
    ReadTemperatureMeasurementTolerance() : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementTolerance()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0402) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TemperatureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTolerance(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportTemperatureMeasurementTolerance : public ModelCommand
{
public:
    ReportTemperatureMeasurementTolerance() : ModelCommand("report")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementTolerance()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0402) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TemperatureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTolerance(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTolerance(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTemperatureMeasurementClusterRevision : public ModelCommand
{
public:
    ReadTemperatureMeasurementClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0402) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TemperatureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportTemperatureMeasurementClusterRevision : public ModelCommand
{
public:
    ReportTemperatureMeasurementClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0402) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TemperatureMeasurementCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TestCluster                                                 | 0x050F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Test                                                              |   0x00 |
| * TestAddArguments                                                  |   0x04 |
| * TestEnumsRequest                                                  |   0x0E |
| * TestListInt8UArgumentRequest                                      |   0x0A |
| * TestListInt8UReverseRequest                                       |   0x0D |
| * TestListStructArgumentRequest                                     |   0x09 |
| * TestNotHandled                                                    |   0x01 |
| * TestNullableOptionalRequest                                       |   0x0F |
| * TestSpecific                                                      |   0x02 |
| * TestStructArgumentRequest                                         |   0x07 |
| * TestUnknownCommand                                                |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Boolean                                                           | 0x0000 |
| * Bitmap8                                                           | 0x0001 |
| * Bitmap16                                                          | 0x0002 |
| * Bitmap32                                                          | 0x0003 |
| * Bitmap64                                                          | 0x0004 |
| * Int8u                                                             | 0x0005 |
| * Int16u                                                            | 0x0006 |
| * Int32u                                                            | 0x0008 |
| * Int64u                                                            | 0x000C |
| * Int8s                                                             | 0x000D |
| * Int16s                                                            | 0x000E |
| * Int32s                                                            | 0x0010 |
| * Int64s                                                            | 0x0014 |
| * Enum8                                                             | 0x0015 |
| * Enum16                                                            | 0x0016 |
| * OctetString                                                       | 0x0019 |
| * ListInt8u                                                         | 0x001A |
| * ListOctetString                                                   | 0x001B |
| * ListStructOctetString                                             | 0x001C |
| * LongOctetString                                                   | 0x001D |
| * CharString                                                        | 0x001E |
| * LongCharString                                                    | 0x001F |
| * EpochUs                                                           | 0x0020 |
| * EpochS                                                            | 0x0021 |
| * VendorId                                                          | 0x0022 |
| * ListNullablesAndOptionalsStruct                                   | 0x0023 |
| * Unsupported                                                       | 0x00FF |
| * NullableBoolean                                                   | 0x8000 |
| * NullableBitmap8                                                   | 0x8001 |
| * NullableBitmap16                                                  | 0x8002 |
| * NullableBitmap32                                                  | 0x8003 |
| * NullableBitmap64                                                  | 0x8004 |
| * NullableInt8u                                                     | 0x8005 |
| * NullableInt16u                                                    | 0x8006 |
| * NullableInt32u                                                    | 0x8008 |
| * NullableInt64u                                                    | 0x800C |
| * NullableInt8s                                                     | 0x800D |
| * NullableInt16s                                                    | 0x800E |
| * NullableInt32s                                                    | 0x8010 |
| * NullableInt64s                                                    | 0x8014 |
| * NullableEnum8                                                     | 0x8015 |
| * NullableEnum16                                                    | 0x8016 |
| * NullableOctetString                                               | 0x8019 |
| * NullableCharString                                                | 0x801E |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command Test
 */
class TestClusterTest : public ModelCommand
{
public:
    TestClusterTest() : ModelCommand("test") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::Test::Type mRequest;
};

/*
 * Command TestAddArguments
 */
class TestClusterTestAddArguments : public ModelCommand
{
public:
    TestClusterTestAddArguments() : ModelCommand("test-add-arguments")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mRequest.arg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mRequest.arg2);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestAddArgumentsResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type mRequest;
};

/*
 * Command TestEnumsRequest
 */
class TestClusterTestEnumsRequest : public ModelCommand
{
public:
    TestClusterTestEnumsRequest() : ModelCommand("test-enums-request")
    {
        AddArgument("Arg1", 0, UINT16_MAX, &mRequest.arg1);
        AddArgument("Arg2", 0, UINT8_MAX, reinterpret_cast<std::underlying_type_t<decltype(mRequest.arg2)> *>(&mRequest.arg2));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000E) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestEnumsResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type mRequest;
};

/*
 * Command TestListInt8UArgumentRequest
 */
class TestClusterTestListInt8UArgumentRequest : public ModelCommand
{
public:
    TestClusterTestListInt8UArgumentRequest() : ModelCommand("test-list-int8uargument-request")
    {
        // arg1 Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000A) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterBooleanResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type mRequest;
};

/*
 * Command TestListInt8UReverseRequest
 */
class TestClusterTestListInt8UReverseRequest : public ModelCommand
{
public:
    TestClusterTestListInt8UReverseRequest() : ModelCommand("test-list-int8ureverse-request")
    {
        // arg1 Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000D) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestListInt8UReverseResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type mRequest;
};

/*
 * Command TestListStructArgumentRequest
 */
class TestClusterTestListStructArgumentRequest : public ModelCommand
{
public:
    TestClusterTestListStructArgumentRequest() : ModelCommand("test-list-struct-argument-request")
    {
        // arg1 Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000009) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterBooleanResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type mRequest;
};

/*
 * Command TestNotHandled
 */
class TestClusterTestNotHandled : public ModelCommand
{
public:
    TestClusterTestNotHandled() : ModelCommand("test-not-handled") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type mRequest;
};

/*
 * Command TestNullableOptionalRequest
 */
class TestClusterTestNullableOptionalRequest : public ModelCommand
{
public:
    TestClusterTestNullableOptionalRequest() : ModelCommand("test-nullable-optional-request")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mRequest.arg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000F) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestNullableOptionalResponseSuccess, OnDefaultFailure,
                                               endpointId, mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type mRequest;
};

/*
 * Command TestSpecific
 */
class TestClusterTestSpecific : public ModelCommand
{
public:
    TestClusterTestSpecific() : ModelCommand("test-specific") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterTestSpecificResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestSpecific::Type mRequest;
};

/*
 * Command TestStructArgumentRequest
 */
class TestClusterTestStructArgumentRequest : public ModelCommand
{
public:
    TestClusterTestStructArgumentRequest() : ModelCommand("test-struct-argument-request")
    {
        // arg1 Struct parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000007) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnTestClusterBooleanResponseSuccess, OnDefaultFailure, endpointId,
                                               mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type mRequest;
};

/*
 * Command TestUnknownCommand
 */
class TestClusterTestUnknownCommand : public ModelCommand
{
public:
    TestClusterTestUnknownCommand() : ModelCommand("test-unknown-command") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000003) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::TestCluster::Commands::TestUnknownCommand::Type mRequest;
};

/*
 * Attribute Boolean
 */
class ReadTestClusterBoolean : public ModelCommand
{
public:
    ReadTestClusterBoolean() : ModelCommand("read")
    {
        AddArgument("attr-name", "boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBoolean()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBoolean(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterBoolean : public ModelCommand
{
public:
    WriteTestClusterBoolean() : ModelCommand("write")
    {
        AddArgument("attr-name", "boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBoolean()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeBoolean(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    bool mValue;
};

class ReportTestClusterBoolean : public ModelCommand
{
public:
    ReportTestClusterBoolean() : ModelCommand("report")
    {
        AddArgument("attr-name", "boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBoolean()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBoolean(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBoolean(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap8
 */
class ReadTestClusterBitmap8 : public ModelCommand
{
public:
    ReadTestClusterBitmap8() : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap8()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBitmap8(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterBitmap8 : public ModelCommand
{
public:
    WriteTestClusterBitmap8() : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap8()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeBitmap8(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportTestClusterBitmap8 : public ModelCommand
{
public:
    ReportTestClusterBitmap8() : ModelCommand("report")
    {
        AddArgument("attr-name", "bitmap8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap8()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBitmap8(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBitmap8(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap16
 */
class ReadTestClusterBitmap16 : public ModelCommand
{
public:
    ReadTestClusterBitmap16() : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap16()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBitmap16(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterBitmap16 : public ModelCommand
{
public:
    WriteTestClusterBitmap16() : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap16()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeBitmap16(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportTestClusterBitmap16 : public ModelCommand
{
public:
    ReportTestClusterBitmap16() : ModelCommand("report")
    {
        AddArgument("attr-name", "bitmap16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap16()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBitmap16(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBitmap16(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap32
 */
class ReadTestClusterBitmap32 : public ModelCommand
{
public:
    ReadTestClusterBitmap32() : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap32");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap32()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBitmap32(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterBitmap32 : public ModelCommand
{
public:
    WriteTestClusterBitmap32() : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap32");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap32()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeBitmap32(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint32_t mValue;
};

class ReportTestClusterBitmap32 : public ModelCommand
{
public:
    ReportTestClusterBitmap32() : ModelCommand("report")
    {
        AddArgument("attr-name", "bitmap32");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap32()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBitmap32(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBitmap32(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap64
 */
class ReadTestClusterBitmap64 : public ModelCommand
{
public:
    ReadTestClusterBitmap64() : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap64");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap64()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBitmap64(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterBitmap64 : public ModelCommand
{
public:
    WriteTestClusterBitmap64() : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap64");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap64()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeBitmap64(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint64_t mValue;
};

class ReportTestClusterBitmap64 : public ModelCommand
{
public:
    ReportTestClusterBitmap64() : ModelCommand("report")
    {
        AddArgument("attr-name", "bitmap64");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap64()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBitmap64(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBitmap64(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int8u
 */
class ReadTestClusterInt8u : public ModelCommand
{
public:
    ReadTestClusterInt8u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt8u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInt8u(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterInt8u : public ModelCommand
{
public:
    WriteTestClusterInt8u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt8u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeInt8u(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportTestClusterInt8u : public ModelCommand
{
public:
    ReportTestClusterInt8u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt8u()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInt8u(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInt8u(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int16u
 */
class ReadTestClusterInt16u : public ModelCommand
{
public:
    ReadTestClusterInt16u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt16u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInt16u(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterInt16u : public ModelCommand
{
public:
    WriteTestClusterInt16u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt16u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeInt16u(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportTestClusterInt16u : public ModelCommand
{
public:
    ReportTestClusterInt16u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt16u()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInt16u(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInt16u(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int32u
 */
class ReadTestClusterInt32u : public ModelCommand
{
public:
    ReadTestClusterInt32u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int32u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt32u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInt32u(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterInt32u : public ModelCommand
{
public:
    WriteTestClusterInt32u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int32u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt32u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeInt32u(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint32_t mValue;
};

class ReportTestClusterInt32u : public ModelCommand
{
public:
    ReportTestClusterInt32u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int32u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt32u()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInt32u(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInt32u(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int64u
 */
class ReadTestClusterInt64u : public ModelCommand
{
public:
    ReadTestClusterInt64u() : ModelCommand("read")
    {
        AddArgument("attr-name", "int64u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt64u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInt64u(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterInt64u : public ModelCommand
{
public:
    WriteTestClusterInt64u() : ModelCommand("write")
    {
        AddArgument("attr-name", "int64u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt64u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeInt64u(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint64_t mValue;
};

class ReportTestClusterInt64u : public ModelCommand
{
public:
    ReportTestClusterInt64u() : ModelCommand("report")
    {
        AddArgument("attr-name", "int64u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt64u()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInt64u(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInt64u(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int8s
 */
class ReadTestClusterInt8s : public ModelCommand
{
public:
    ReadTestClusterInt8s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt8s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInt8s(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8sAttributeCallback>(OnInt8sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterInt8s : public ModelCommand
{
public:
    WriteTestClusterInt8s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt8s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeInt8s(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int8_t mValue;
};

class ReportTestClusterInt8s : public ModelCommand
{
public:
    ReportTestClusterInt8s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt8s()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInt8s(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInt8s(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8sAttributeCallback>(OnInt8sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int16s
 */
class ReadTestClusterInt16s : public ModelCommand
{
public:
    ReadTestClusterInt16s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt16s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInt16s(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterInt16s : public ModelCommand
{
public:
    WriteTestClusterInt16s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt16s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeInt16s(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int16_t mValue;
};

class ReportTestClusterInt16s : public ModelCommand
{
public:
    ReportTestClusterInt16s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt16s()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInt16s(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInt16s(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int32s
 */
class ReadTestClusterInt32s : public ModelCommand
{
public:
    ReadTestClusterInt32s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int32s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt32s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInt32s(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32sAttributeCallback>(OnInt32sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterInt32s : public ModelCommand
{
public:
    WriteTestClusterInt32s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int32s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt32s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeInt32s(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int32_t mValue;
};

class ReportTestClusterInt32s : public ModelCommand
{
public:
    ReportTestClusterInt32s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int32s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt32s()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInt32s(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInt32s(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32sAttributeCallback>(OnInt32sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int64s
 */
class ReadTestClusterInt64s : public ModelCommand
{
public:
    ReadTestClusterInt64s() : ModelCommand("read")
    {
        AddArgument("attr-name", "int64s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt64s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInt64s(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64sAttributeCallback>(OnInt64sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterInt64s : public ModelCommand
{
public:
    WriteTestClusterInt64s() : ModelCommand("write")
    {
        AddArgument("attr-name", "int64s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt64s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeInt64s(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int64_t mValue;
};

class ReportTestClusterInt64s : public ModelCommand
{
public:
    ReportTestClusterInt64s() : ModelCommand("report")
    {
        AddArgument("attr-name", "int64s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt64s()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInt64s(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInt64s(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64sAttributeCallback>(OnInt64sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Enum8
 */
class ReadTestClusterEnum8 : public ModelCommand
{
public:
    ReadTestClusterEnum8() : ModelCommand("read")
    {
        AddArgument("attr-name", "enum8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnum8()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeEnum8(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterEnum8 : public ModelCommand
{
public:
    WriteTestClusterEnum8() : ModelCommand("write")
    {
        AddArgument("attr-name", "enum8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnum8()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeEnum8(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportTestClusterEnum8 : public ModelCommand
{
public:
    ReportTestClusterEnum8() : ModelCommand("report")
    {
        AddArgument("attr-name", "enum8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEnum8()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeEnum8(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeEnum8(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Enum16
 */
class ReadTestClusterEnum16 : public ModelCommand
{
public:
    ReadTestClusterEnum16() : ModelCommand("read")
    {
        AddArgument("attr-name", "enum16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnum16()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeEnum16(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterEnum16 : public ModelCommand
{
public:
    WriteTestClusterEnum16() : ModelCommand("write")
    {
        AddArgument("attr-name", "enum16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnum16()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeEnum16(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportTestClusterEnum16 : public ModelCommand
{
public:
    ReportTestClusterEnum16() : ModelCommand("report")
    {
        AddArgument("attr-name", "enum16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEnum16()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeEnum16(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeEnum16(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OctetString
 */
class ReadTestClusterOctetString : public ModelCommand
{
public:
    ReadTestClusterOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterOctetString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOctetString(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OctetStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterOctetString : public ModelCommand
{
public:
    WriteTestClusterOctetString() : ModelCommand("write")
    {
        AddArgument("attr-name", "octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterOctetString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOctetString(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::ByteSpan mValue;
};

class ReportTestClusterOctetString : public ModelCommand
{
public:
    ReportTestClusterOctetString() : ModelCommand("report")
    {
        AddArgument("attr-name", "octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterOctetString()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOctetString(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOctetString(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<OctetStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListInt8u
 */
class ReadTestClusterListInt8u : public ModelCommand
{
public:
    ReadTestClusterListInt8u() : ModelCommand("read")
    {
        AddArgument("attr-name", "list-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListInt8u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeListInt8u(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<TestClusterListInt8uListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<TestClusterListInt8uListAttributeCallback>(OnTestClusterListInt8uListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ListOctetString
 */
class ReadTestClusterListOctetString : public ModelCommand
{
public:
    ReadTestClusterListOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "list-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListOctetString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeListOctetString(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<TestClusterListOctetStringListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<TestClusterListOctetStringListAttributeCallback>(
            OnTestClusterListOctetStringListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ListStructOctetString
 */
class ReadTestClusterListStructOctetString : public ModelCommand
{
public:
    ReadTestClusterListStructOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "list-struct-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListStructOctetString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeListStructOctetString(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<TestClusterListStructOctetStringListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<TestClusterListStructOctetStringListAttributeCallback>(
            OnTestClusterListStructOctetStringListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute LongOctetString
 */
class ReadTestClusterLongOctetString : public ModelCommand
{
public:
    ReadTestClusterLongOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "long-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterLongOctetString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLongOctetString(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OctetStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterLongOctetString : public ModelCommand
{
public:
    WriteTestClusterLongOctetString() : ModelCommand("write")
    {
        AddArgument("attr-name", "long-octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterLongOctetString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeLongOctetString(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::ByteSpan mValue;
};

class ReportTestClusterLongOctetString : public ModelCommand
{
public:
    ReportTestClusterLongOctetString() : ModelCommand("report")
    {
        AddArgument("attr-name", "long-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterLongOctetString()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLongOctetString(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLongOctetString(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<OctetStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CharString
 */
class ReadTestClusterCharString : public ModelCommand
{
public:
    ReadTestClusterCharString() : ModelCommand("read")
    {
        AddArgument("attr-name", "char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterCharString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCharString(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterCharString : public ModelCommand
{
public:
    WriteTestClusterCharString() : ModelCommand("write")
    {
        AddArgument("attr-name", "char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterCharString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeCharString(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::CharSpan mValue;
};

class ReportTestClusterCharString : public ModelCommand
{
public:
    ReportTestClusterCharString() : ModelCommand("report")
    {
        AddArgument("attr-name", "char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterCharString()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCharString(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCharString(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LongCharString
 */
class ReadTestClusterLongCharString : public ModelCommand
{
public:
    ReadTestClusterLongCharString() : ModelCommand("read")
    {
        AddArgument("attr-name", "long-char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterLongCharString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLongCharString(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterLongCharString : public ModelCommand
{
public:
    WriteTestClusterLongCharString() : ModelCommand("write")
    {
        AddArgument("attr-name", "long-char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterLongCharString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeLongCharString(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::CharSpan mValue;
};

class ReportTestClusterLongCharString : public ModelCommand
{
public:
    ReportTestClusterLongCharString() : ModelCommand("report")
    {
        AddArgument("attr-name", "long-char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterLongCharString()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLongCharString(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLongCharString(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EpochUs
 */
class ReadTestClusterEpochUs : public ModelCommand
{
public:
    ReadTestClusterEpochUs() : ModelCommand("read")
    {
        AddArgument("attr-name", "epoch-us");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEpochUs()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeEpochUs(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterEpochUs : public ModelCommand
{
public:
    WriteTestClusterEpochUs() : ModelCommand("write")
    {
        AddArgument("attr-name", "epoch-us");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEpochUs()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeEpochUs(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint64_t mValue;
};

class ReportTestClusterEpochUs : public ModelCommand
{
public:
    ReportTestClusterEpochUs() : ModelCommand("report")
    {
        AddArgument("attr-name", "epoch-us");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEpochUs()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeEpochUs(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeEpochUs(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EpochS
 */
class ReadTestClusterEpochS : public ModelCommand
{
public:
    ReadTestClusterEpochS() : ModelCommand("read")
    {
        AddArgument("attr-name", "epoch-s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEpochS()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeEpochS(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterEpochS : public ModelCommand
{
public:
    WriteTestClusterEpochS() : ModelCommand("write")
    {
        AddArgument("attr-name", "epoch-s");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEpochS()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeEpochS(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint32_t mValue;
};

class ReportTestClusterEpochS : public ModelCommand
{
public:
    ReportTestClusterEpochS() : ModelCommand("report")
    {
        AddArgument("attr-name", "epoch-s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEpochS()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeEpochS(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeEpochS(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorId
 */
class ReadTestClusterVendorId : public ModelCommand
{
public:
    ReadTestClusterVendorId() : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterVendorId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeVendorId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterVendorId : public ModelCommand
{
public:
    WriteTestClusterVendorId() : ModelCommand("write")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterVendorId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeVendorId(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::VendorId mValue;
};

class ReportTestClusterVendorId : public ModelCommand
{
public:
    ReportTestClusterVendorId() : ModelCommand("report")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterVendorId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeVendorId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeVendorId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListNullablesAndOptionalsStruct
 */
class ReadTestClusterListNullablesAndOptionalsStruct : public ModelCommand
{
public:
    ReadTestClusterListNullablesAndOptionalsStruct() : ModelCommand("read")
    {
        AddArgument("attr-name", "list-nullables-and-optionals-struct");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListNullablesAndOptionalsStruct()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeListNullablesAndOptionalsStruct(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<TestClusterListNullablesAndOptionalsStructListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<TestClusterListNullablesAndOptionalsStructListAttributeCallback>(
            OnTestClusterListNullablesAndOptionalsStructListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute Unsupported
 */
class ReadTestClusterUnsupported : public ModelCommand
{
public:
    ReadTestClusterUnsupported() : ModelCommand("read")
    {
        AddArgument("attr-name", "unsupported");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterUnsupported()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeUnsupported(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterUnsupported : public ModelCommand
{
public:
    WriteTestClusterUnsupported() : ModelCommand("write")
    {
        AddArgument("attr-name", "unsupported");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterUnsupported()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeUnsupported(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    bool mValue;
};

class ReportTestClusterUnsupported : public ModelCommand
{
public:
    ReportTestClusterUnsupported() : ModelCommand("report")
    {
        AddArgument("attr-name", "unsupported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterUnsupported()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeUnsupported(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeUnsupported(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBoolean
 */
class ReadTestClusterNullableBoolean : public ModelCommand
{
public:
    ReadTestClusterNullableBoolean() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBoolean()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableBoolean(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<BooleanAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableBoolean : public ModelCommand
{
public:
    WriteTestClusterNullableBoolean() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBoolean()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableBoolean(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    bool mValue;
};

class ReportTestClusterNullableBoolean : public ModelCommand
{
public:
    ReportTestClusterNullableBoolean() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBoolean()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableBoolean(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableBoolean(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<BooleanAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<BooleanAttributeCallback>(OnBooleanAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap8
 */
class ReadTestClusterNullableBitmap8 : public ModelCommand
{
public:
    ReadTestClusterNullableBitmap8() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap8()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableBitmap8(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableBitmap8 : public ModelCommand
{
public:
    WriteTestClusterNullableBitmap8() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap8()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableBitmap8(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportTestClusterNullableBitmap8 : public ModelCommand
{
public:
    ReportTestClusterNullableBitmap8() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap8()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableBitmap8(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableBitmap8(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap16
 */
class ReadTestClusterNullableBitmap16 : public ModelCommand
{
public:
    ReadTestClusterNullableBitmap16() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap16()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableBitmap16(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableBitmap16 : public ModelCommand
{
public:
    WriteTestClusterNullableBitmap16() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap16()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableBitmap16(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportTestClusterNullableBitmap16 : public ModelCommand
{
public:
    ReportTestClusterNullableBitmap16() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap16()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableBitmap16(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableBitmap16(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap32
 */
class ReadTestClusterNullableBitmap32 : public ModelCommand
{
public:
    ReadTestClusterNullableBitmap32() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap32()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableBitmap32(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableBitmap32 : public ModelCommand
{
public:
    WriteTestClusterNullableBitmap32() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap32()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableBitmap32(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint32_t mValue;
};

class ReportTestClusterNullableBitmap32 : public ModelCommand
{
public:
    ReportTestClusterNullableBitmap32() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap32()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableBitmap32(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableBitmap32(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap64
 */
class ReadTestClusterNullableBitmap64 : public ModelCommand
{
public:
    ReadTestClusterNullableBitmap64() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap64()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableBitmap64(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableBitmap64 : public ModelCommand
{
public:
    WriteTestClusterNullableBitmap64() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap64()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableBitmap64(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint64_t mValue;
};

class ReportTestClusterNullableBitmap64 : public ModelCommand
{
public:
    ReportTestClusterNullableBitmap64() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap64()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableBitmap64(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableBitmap64(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt8u
 */
class ReadTestClusterNullableInt8u : public ModelCommand
{
public:
    ReadTestClusterNullableInt8u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt8u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableInt8u(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableInt8u : public ModelCommand
{
public:
    WriteTestClusterNullableInt8u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt8u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableInt8u(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportTestClusterNullableInt8u : public ModelCommand
{
public:
    ReportTestClusterNullableInt8u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt8u()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableInt8u(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableInt8u(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt16u
 */
class ReadTestClusterNullableInt16u : public ModelCommand
{
public:
    ReadTestClusterNullableInt16u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt16u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableInt16u(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableInt16u : public ModelCommand
{
public:
    WriteTestClusterNullableInt16u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt16u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableInt16u(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportTestClusterNullableInt16u : public ModelCommand
{
public:
    ReportTestClusterNullableInt16u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt16u()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableInt16u(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableInt16u(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt32u
 */
class ReadTestClusterNullableInt32u : public ModelCommand
{
public:
    ReadTestClusterNullableInt32u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int32u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt32u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableInt32u(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableInt32u : public ModelCommand
{
public:
    WriteTestClusterNullableInt32u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int32u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt32u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableInt32u(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint32_t mValue;
};

class ReportTestClusterNullableInt32u : public ModelCommand
{
public:
    ReportTestClusterNullableInt32u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int32u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt32u()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableInt32u(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableInt32u(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt64u
 */
class ReadTestClusterNullableInt64u : public ModelCommand
{
public:
    ReadTestClusterNullableInt64u() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int64u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt64u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableInt64u(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableInt64u : public ModelCommand
{
public:
    WriteTestClusterNullableInt64u() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int64u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt64u()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableInt64u(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint64_t mValue;
};

class ReportTestClusterNullableInt64u : public ModelCommand
{
public:
    ReportTestClusterNullableInt64u() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int64u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt64u()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableInt64u(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableInt64u(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt8s
 */
class ReadTestClusterNullableInt8s : public ModelCommand
{
public:
    ReadTestClusterNullableInt8s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt8s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableInt8s(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8sAttributeCallback>(OnInt8sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableInt8s : public ModelCommand
{
public:
    WriteTestClusterNullableInt8s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt8s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableInt8s(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int8_t mValue;
};

class ReportTestClusterNullableInt8s : public ModelCommand
{
public:
    ReportTestClusterNullableInt8s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt8s()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableInt8s(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableInt8s(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8sAttributeCallback>(OnInt8sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt16s
 */
class ReadTestClusterNullableInt16s : public ModelCommand
{
public:
    ReadTestClusterNullableInt16s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt16s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableInt16s(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableInt16s : public ModelCommand
{
public:
    WriteTestClusterNullableInt16s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt16s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableInt16s(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int16_t mValue;
};

class ReportTestClusterNullableInt16s : public ModelCommand
{
public:
    ReportTestClusterNullableInt16s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt16s()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableInt16s(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableInt16s(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt32s
 */
class ReadTestClusterNullableInt32s : public ModelCommand
{
public:
    ReadTestClusterNullableInt32s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int32s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt32s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableInt32s(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32sAttributeCallback>(OnInt32sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableInt32s : public ModelCommand
{
public:
    WriteTestClusterNullableInt32s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int32s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt32s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableInt32s(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int32_t mValue;
};

class ReportTestClusterNullableInt32s : public ModelCommand
{
public:
    ReportTestClusterNullableInt32s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int32s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt32s()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableInt32s(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableInt32s(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32sAttributeCallback>(OnInt32sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt64s
 */
class ReadTestClusterNullableInt64s : public ModelCommand
{
public:
    ReadTestClusterNullableInt64s() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int64s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt64s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableInt64s(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64sAttributeCallback>(OnInt64sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableInt64s : public ModelCommand
{
public:
    WriteTestClusterNullableInt64s() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int64s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt64s()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableInt64s(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int64_t mValue;
};

class ReportTestClusterNullableInt64s : public ModelCommand
{
public:
    ReportTestClusterNullableInt64s() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-int64s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt64s()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableInt64s(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableInt64s(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64sAttributeCallback>(OnInt64sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnum8
 */
class ReadTestClusterNullableEnum8 : public ModelCommand
{
public:
    ReadTestClusterNullableEnum8() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnum8()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableEnum8(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableEnum8 : public ModelCommand
{
public:
    WriteTestClusterNullableEnum8() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnum8()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableEnum8(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportTestClusterNullableEnum8 : public ModelCommand
{
public:
    ReportTestClusterNullableEnum8() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-enum8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableEnum8()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableEnum8(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableEnum8(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnum16
 */
class ReadTestClusterNullableEnum16 : public ModelCommand
{
public:
    ReadTestClusterNullableEnum16() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnum16()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableEnum16(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableEnum16 : public ModelCommand
{
public:
    WriteTestClusterNullableEnum16() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnum16()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableEnum16(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint16_t mValue;
};

class ReportTestClusterNullableEnum16 : public ModelCommand
{
public:
    ReportTestClusterNullableEnum16() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-enum16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableEnum16()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableEnum16(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableEnum16(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableOctetString
 */
class ReadTestClusterNullableOctetString : public ModelCommand
{
public:
    ReadTestClusterNullableOctetString() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableOctetString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableOctetString(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OctetStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableOctetString : public ModelCommand
{
public:
    WriteTestClusterNullableOctetString() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableOctetString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableOctetString(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::ByteSpan mValue;
};

class ReportTestClusterNullableOctetString : public ModelCommand
{
public:
    ReportTestClusterNullableOctetString() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableOctetString()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableOctetString(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableOctetString(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<OctetStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableCharString
 */
class ReadTestClusterNullableCharString : public ModelCommand
{
public:
    ReadTestClusterNullableCharString() : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableCharString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNullableCharString(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteTestClusterNullableCharString : public ModelCommand
{
public:
    WriteTestClusterNullableCharString() : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableCharString()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeNullableCharString(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::CharSpan mValue;
};

class ReportTestClusterNullableCharString : public ModelCommand
{
public:
    ReportTestClusterNullableCharString() : ModelCommand("report")
    {
        AddArgument("attr-name", "nullable-char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableCharString()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNullableCharString(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNullableCharString(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTestClusterClusterRevision : public ModelCommand
{
public:
    ReadTestClusterClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportTestClusterClusterRevision : public ModelCommand
{
public:
    ReportTestClusterClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x050F) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::TestClusterCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Thermostat                                                  | 0x0201 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ClearWeeklySchedule                                               |   0x03 |
| * GetRelayStatusLog                                                 |   0x04 |
| * GetWeeklySchedule                                                 |   0x02 |
| * SetWeeklySchedule                                                 |   0x01 |
| * SetpointRaiseLower                                                |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LocalTemperature                                                  | 0x0000 |
| * AbsMinHeatSetpointLimit                                           | 0x0003 |
| * AbsMaxHeatSetpointLimit                                           | 0x0004 |
| * AbsMinCoolSetpointLimit                                           | 0x0005 |
| * AbsMaxCoolSetpointLimit                                           | 0x0006 |
| * OccupiedCoolingSetpoint                                           | 0x0011 |
| * OccupiedHeatingSetpoint                                           | 0x0012 |
| * MinHeatSetpointLimit                                              | 0x0015 |
| * MaxHeatSetpointLimit                                              | 0x0016 |
| * MinCoolSetpointLimit                                              | 0x0017 |
| * MaxCoolSetpointLimit                                              | 0x0018 |
| * MinSetpointDeadBand                                               | 0x0019 |
| * ControlSequenceOfOperation                                        | 0x001B |
| * SystemMode                                                        | 0x001C |
| * StartOfWeek                                                       | 0x0020 |
| * NumberOfWeeklyTransitions                                         | 0x0021 |
| * NumberOfDailyTransitions                                          | 0x0022 |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ClearWeeklySchedule
 */
class ThermostatClearWeeklySchedule : public ModelCommand
{
public:
    ThermostatClearWeeklySchedule() : ModelCommand("clear-weekly-schedule") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000003) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Thermostat::Commands::ClearWeeklySchedule::Type mRequest;
};

/*
 * Command GetRelayStatusLog
 */
class ThermostatGetRelayStatusLog : public ModelCommand
{
public:
    ThermostatGetRelayStatusLog() : ModelCommand("get-relay-status-log") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Thermostat::Commands::GetRelayStatusLog::Type mRequest;
};

/*
 * Command GetWeeklySchedule
 */
class ThermostatGetWeeklySchedule : public ModelCommand
{
public:
    ThermostatGetWeeklySchedule() : ModelCommand("get-weekly-schedule")
    {
        AddArgument("DaysToReturn", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<chip::app::Clusters::Thermostat::DayOfWeek> *>(&mRequest.daysToReturn));
        AddArgument(
            "ModeToReturn", 0, UINT8_MAX,
            reinterpret_cast<std::underlying_type_t<chip::app::Clusters::Thermostat::ModeForSequence> *>(&mRequest.modeToReturn));
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Thermostat::Commands::GetWeeklySchedule::Type mRequest;
};

/*
 * Command SetWeeklySchedule
 */
class ThermostatSetWeeklySchedule : public ModelCommand
{
public:
    ThermostatSetWeeklySchedule() : ModelCommand("set-weekly-schedule")
    {
        AddArgument("NumberOfTransitionsForSequence", 0, UINT8_MAX, &mRequest.numberOfTransitionsForSequence);
        AddArgument(
            "DayOfWeekForSequence", 0, UINT8_MAX,
            reinterpret_cast<std::underlying_type_t<chip::app::Clusters::Thermostat::DayOfWeek> *>(&mRequest.dayOfWeekForSequence));
        AddArgument("ModeForSequence", 0, UINT8_MAX,
                    reinterpret_cast<std::underlying_type_t<chip::app::Clusters::Thermostat::ModeForSequence> *>(
                        &mRequest.modeForSequence));
        // payload Array parsing is not supported yet
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Thermostat::Commands::SetWeeklySchedule::Type mRequest;
};

/*
 * Command SetpointRaiseLower
 */
class ThermostatSetpointRaiseLower : public ModelCommand
{
public:
    ThermostatSetpointRaiseLower() : ModelCommand("setpoint-raise-lower")
    {
        AddArgument("Mode", 0, UINT8_MAX, reinterpret_cast<std::underlying_type_t<decltype(mRequest.mode)> *>(&mRequest.mode));
        AddArgument("Amount", INT8_MIN, INT8_MAX, &mRequest.amount);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::Thermostat::Commands::SetpointRaiseLower::Type mRequest;
};

/*
 * Attribute LocalTemperature
 */
class ReadThermostatLocalTemperature : public ModelCommand
{
public:
    ReadThermostatLocalTemperature() : ModelCommand("read")
    {
        AddArgument("attr-name", "local-temperature");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatLocalTemperature()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLocalTemperature(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatLocalTemperature : public ModelCommand
{
public:
    ReportThermostatLocalTemperature() : ModelCommand("report")
    {
        AddArgument("attr-name", "local-temperature");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatLocalTemperature()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLocalTemperature(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLocalTemperature(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMinHeatSetpointLimit
 */
class ReadThermostatAbsMinHeatSetpointLimit : public ModelCommand
{
public:
    ReadThermostatAbsMinHeatSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-min-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMinHeatSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeAbsMinHeatSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatAbsMinHeatSetpointLimit : public ModelCommand
{
public:
    ReportThermostatAbsMinHeatSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "abs-min-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMinHeatSetpointLimit()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeAbsMinHeatSetpointLimit(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeAbsMinHeatSetpointLimit(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                 mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMaxHeatSetpointLimit
 */
class ReadThermostatAbsMaxHeatSetpointLimit : public ModelCommand
{
public:
    ReadThermostatAbsMaxHeatSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-max-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMaxHeatSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeAbsMaxHeatSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatAbsMaxHeatSetpointLimit : public ModelCommand
{
public:
    ReportThermostatAbsMaxHeatSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "abs-max-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMaxHeatSetpointLimit()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeAbsMaxHeatSetpointLimit(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeAbsMaxHeatSetpointLimit(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                 mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMinCoolSetpointLimit
 */
class ReadThermostatAbsMinCoolSetpointLimit : public ModelCommand
{
public:
    ReadThermostatAbsMinCoolSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-min-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMinCoolSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeAbsMinCoolSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatAbsMinCoolSetpointLimit : public ModelCommand
{
public:
    ReportThermostatAbsMinCoolSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "abs-min-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMinCoolSetpointLimit()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeAbsMinCoolSetpointLimit(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeAbsMinCoolSetpointLimit(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                 mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMaxCoolSetpointLimit
 */
class ReadThermostatAbsMaxCoolSetpointLimit : public ModelCommand
{
public:
    ReadThermostatAbsMaxCoolSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-max-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMaxCoolSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeAbsMaxCoolSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatAbsMaxCoolSetpointLimit : public ModelCommand
{
public:
    ReportThermostatAbsMaxCoolSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "abs-max-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMaxCoolSetpointLimit()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeAbsMaxCoolSetpointLimit(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeAbsMaxCoolSetpointLimit(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                 mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupiedCoolingSetpoint
 */
class ReadThermostatOccupiedCoolingSetpoint : public ModelCommand
{
public:
    ReadThermostatOccupiedCoolingSetpoint() : ModelCommand("read")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatOccupiedCoolingSetpoint()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOccupiedCoolingSetpoint(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatOccupiedCoolingSetpoint : public ModelCommand
{
public:
    WriteThermostatOccupiedCoolingSetpoint() : ModelCommand("write")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatOccupiedCoolingSetpoint()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOccupiedCoolingSetpoint(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int16_t mValue;
};

class ReportThermostatOccupiedCoolingSetpoint : public ModelCommand
{
public:
    ReportThermostatOccupiedCoolingSetpoint() : ModelCommand("report")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatOccupiedCoolingSetpoint()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOccupiedCoolingSetpoint(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOccupiedCoolingSetpoint(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                 mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupiedHeatingSetpoint
 */
class ReadThermostatOccupiedHeatingSetpoint : public ModelCommand
{
public:
    ReadThermostatOccupiedHeatingSetpoint() : ModelCommand("read")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatOccupiedHeatingSetpoint()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOccupiedHeatingSetpoint(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatOccupiedHeatingSetpoint : public ModelCommand
{
public:
    WriteThermostatOccupiedHeatingSetpoint() : ModelCommand("write")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatOccupiedHeatingSetpoint()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeOccupiedHeatingSetpoint(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int16_t mValue;
};

class ReportThermostatOccupiedHeatingSetpoint : public ModelCommand
{
public:
    ReportThermostatOccupiedHeatingSetpoint() : ModelCommand("report")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatOccupiedHeatingSetpoint()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOccupiedHeatingSetpoint(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOccupiedHeatingSetpoint(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                 mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinHeatSetpointLimit
 */
class ReadThermostatMinHeatSetpointLimit : public ModelCommand
{
public:
    ReadThermostatMinHeatSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinHeatSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinHeatSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatMinHeatSetpointLimit : public ModelCommand
{
public:
    WriteThermostatMinHeatSetpointLimit() : ModelCommand("write")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinHeatSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeMinHeatSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int16_t mValue;
};

class ReportThermostatMinHeatSetpointLimit : public ModelCommand
{
public:
    ReportThermostatMinHeatSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMinHeatSetpointLimit()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinHeatSetpointLimit(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinHeatSetpointLimit(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxHeatSetpointLimit
 */
class ReadThermostatMaxHeatSetpointLimit : public ModelCommand
{
public:
    ReadThermostatMaxHeatSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMaxHeatSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxHeatSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatMaxHeatSetpointLimit : public ModelCommand
{
public:
    WriteThermostatMaxHeatSetpointLimit() : ModelCommand("write")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMaxHeatSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeMaxHeatSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int16_t mValue;
};

class ReportThermostatMaxHeatSetpointLimit : public ModelCommand
{
public:
    ReportThermostatMaxHeatSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMaxHeatSetpointLimit()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxHeatSetpointLimit(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxHeatSetpointLimit(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinCoolSetpointLimit
 */
class ReadThermostatMinCoolSetpointLimit : public ModelCommand
{
public:
    ReadThermostatMinCoolSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinCoolSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinCoolSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatMinCoolSetpointLimit : public ModelCommand
{
public:
    WriteThermostatMinCoolSetpointLimit() : ModelCommand("write")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinCoolSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeMinCoolSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int16_t mValue;
};

class ReportThermostatMinCoolSetpointLimit : public ModelCommand
{
public:
    ReportThermostatMinCoolSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMinCoolSetpointLimit()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinCoolSetpointLimit(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinCoolSetpointLimit(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxCoolSetpointLimit
 */
class ReadThermostatMaxCoolSetpointLimit : public ModelCommand
{
public:
    ReadThermostatMaxCoolSetpointLimit() : ModelCommand("read")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMaxCoolSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMaxCoolSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatMaxCoolSetpointLimit : public ModelCommand
{
public:
    WriteThermostatMaxCoolSetpointLimit() : ModelCommand("write")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMaxCoolSetpointLimit()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeMaxCoolSetpointLimit(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int16_t mValue;
};

class ReportThermostatMaxCoolSetpointLimit : public ModelCommand
{
public:
    ReportThermostatMaxCoolSetpointLimit() : ModelCommand("report")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMaxCoolSetpointLimit()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMaxCoolSetpointLimit(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMaxCoolSetpointLimit(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16sAttributeCallback>(OnInt16sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinSetpointDeadBand
 */
class ReadThermostatMinSetpointDeadBand : public ModelCommand
{
public:
    ReadThermostatMinSetpointDeadBand() : ModelCommand("read")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinSetpointDeadBand()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMinSetpointDeadBand(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8sAttributeCallback>(OnInt8sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatMinSetpointDeadBand : public ModelCommand
{
public:
    WriteThermostatMinSetpointDeadBand() : ModelCommand("write")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinSetpointDeadBand()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeMinSetpointDeadBand(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    int8_t mValue;
};

class ReportThermostatMinSetpointDeadBand : public ModelCommand
{
public:
    ReportThermostatMinSetpointDeadBand() : ModelCommand("report")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMinSetpointDeadBand()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMinSetpointDeadBand(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMinSetpointDeadBand(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8sAttributeCallback>(OnInt8sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ControlSequenceOfOperation
 */
class ReadThermostatControlSequenceOfOperation : public ModelCommand
{
public:
    ReadThermostatControlSequenceOfOperation() : ModelCommand("read")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatControlSequenceOfOperation()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeControlSequenceOfOperation(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatControlSequenceOfOperation : public ModelCommand
{
public:
    WriteThermostatControlSequenceOfOperation() : ModelCommand("write")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatControlSequenceOfOperation()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeControlSequenceOfOperation(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportThermostatControlSequenceOfOperation : public ModelCommand
{
public:
    ReportThermostatControlSequenceOfOperation() : ModelCommand("report")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatControlSequenceOfOperation()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeControlSequenceOfOperation(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeControlSequenceOfOperation(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                    mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SystemMode
 */
class ReadThermostatSystemMode : public ModelCommand
{
public:
    ReadThermostatSystemMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "system-mode");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatSystemMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSystemMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatSystemMode : public ModelCommand
{
public:
    WriteThermostatSystemMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "system-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatSystemMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeSystemMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportThermostatSystemMode : public ModelCommand
{
public:
    ReportThermostatSystemMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "system-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatSystemMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSystemMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSystemMode(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartOfWeek
 */
class ReadThermostatStartOfWeek : public ModelCommand
{
public:
    ReadThermostatStartOfWeek() : ModelCommand("read")
    {
        AddArgument("attr-name", "start-of-week");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatStartOfWeek()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeStartOfWeek(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatStartOfWeek : public ModelCommand
{
public:
    ReportThermostatStartOfWeek() : ModelCommand("report")
    {
        AddArgument("attr-name", "start-of-week");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatStartOfWeek()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeStartOfWeek(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeStartOfWeek(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfWeeklyTransitions
 */
class ReadThermostatNumberOfWeeklyTransitions : public ModelCommand
{
public:
    ReadThermostatNumberOfWeeklyTransitions() : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-weekly-transitions");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatNumberOfWeeklyTransitions()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNumberOfWeeklyTransitions(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatNumberOfWeeklyTransitions : public ModelCommand
{
public:
    ReportThermostatNumberOfWeeklyTransitions() : ModelCommand("report")
    {
        AddArgument("attr-name", "number-of-weekly-transitions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatNumberOfWeeklyTransitions()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNumberOfWeeklyTransitions(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNumberOfWeeklyTransitions(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                   mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfDailyTransitions
 */
class ReadThermostatNumberOfDailyTransitions : public ModelCommand
{
public:
    ReadThermostatNumberOfDailyTransitions() : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-daily-transitions");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatNumberOfDailyTransitions()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNumberOfDailyTransitions(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatNumberOfDailyTransitions : public ModelCommand
{
public:
    ReportThermostatNumberOfDailyTransitions() : ModelCommand("report")
    {
        AddArgument("attr-name", "number-of-daily-transitions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatNumberOfDailyTransitions()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNumberOfDailyTransitions(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNumberOfDailyTransitions(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                  mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadThermostatFeatureMap : public ModelCommand
{
public:
    ReadThermostatFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatFeatureMap()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeFeatureMap(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatFeatureMap : public ModelCommand
{
public:
    ReportThermostatFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatFeatureMap()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeFeatureMap(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeFeatureMap(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThermostatClusterRevision : public ModelCommand
{
public:
    ReadThermostatClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatClusterRevision : public ModelCommand
{
public:
    ReportThermostatClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0201) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ThermostatUserInterfaceConfiguration                        | 0x0204 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TemperatureDisplayMode                                            | 0x0000 |
| * KeypadLockout                                                     | 0x0001 |
| * ScheduleProgrammingVisibility                                     | 0x0002 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute TemperatureDisplayMode
 */
class ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand
{
public:
    ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "temperature-display-mode");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTemperatureDisplayMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand
{
public:
    WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "temperature-display-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeTemperatureDisplayMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand
{
public:
    ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "temperature-display-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTemperatureDisplayMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTemperatureDisplayMode(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute KeypadLockout
 */
class ReadThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand
{
public:
    ReadThermostatUserInterfaceConfigurationKeypadLockout() : ModelCommand("read")
    {
        AddArgument("attr-name", "keypad-lockout");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationKeypadLockout()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeKeypadLockout(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand
{
public:
    WriteThermostatUserInterfaceConfigurationKeypadLockout() : ModelCommand("write")
    {
        AddArgument("attr-name", "keypad-lockout");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationKeypadLockout()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeKeypadLockout(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand
{
public:
    ReportThermostatUserInterfaceConfigurationKeypadLockout() : ModelCommand("report")
    {
        AddArgument("attr-name", "keypad-lockout");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationKeypadLockout()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeKeypadLockout(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeKeypadLockout(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ScheduleProgrammingVisibility
 */
class ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand
{
public:
    ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() : ModelCommand("read")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeScheduleProgrammingVisibility(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand
{
public:
    WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() : ModelCommand("write")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeScheduleProgrammingVisibility(onSuccessCallback->Cancel(), onFailureCallback->Cancel(),
                                                                   mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand
{
public:
    ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() : ModelCommand("report")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeScheduleProgrammingVisibility(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeScheduleProgrammingVisibility(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                       mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThermostatUserInterfaceConfigurationClusterRevision : public ModelCommand
{
public:
    ReadThermostatUserInterfaceConfigurationClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThermostatUserInterfaceConfigurationClusterRevision : public ModelCommand
{
public:
    ReportThermostatUserInterfaceConfigurationClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0204) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThermostatUserInterfaceConfigurationCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ThreadNetworkDiagnostics                                    | 0x0035 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Channel                                                           | 0x0000 |
| * RoutingRole                                                       | 0x0001 |
| * NetworkName                                                       | 0x0002 |
| * PanId                                                             | 0x0003 |
| * ExtendedPanId                                                     | 0x0004 |
| * MeshLocalPrefix                                                   | 0x0005 |
| * OverrunCount                                                      | 0x0006 |
| * NeighborTableList                                                 | 0x0007 |
| * RouteTableList                                                    | 0x0008 |
| * PartitionId                                                       | 0x0009 |
| * Weighting                                                         | 0x000A |
| * DataVersion                                                       | 0x000B |
| * StableDataVersion                                                 | 0x000C |
| * LeaderRouterId                                                    | 0x000D |
| * DetachedRoleCount                                                 | 0x000E |
| * ChildRoleCount                                                    | 0x000F |
| * RouterRoleCount                                                   | 0x0010 |
| * LeaderRoleCount                                                   | 0x0011 |
| * AttachAttemptCount                                                | 0x0012 |
| * PartitionIdChangeCount                                            | 0x0013 |
| * BetterPartitionAttachAttemptCount                                 | 0x0014 |
| * ParentChangeCount                                                 | 0x0015 |
| * TxTotalCount                                                      | 0x0016 |
| * TxUnicastCount                                                    | 0x0017 |
| * TxBroadcastCount                                                  | 0x0018 |
| * TxAckRequestedCount                                               | 0x0019 |
| * TxAckedCount                                                      | 0x001A |
| * TxNoAckRequestedCount                                             | 0x001B |
| * TxDataCount                                                       | 0x001C |
| * TxDataPollCount                                                   | 0x001D |
| * TxBeaconCount                                                     | 0x001E |
| * TxBeaconRequestCount                                              | 0x001F |
| * TxOtherCount                                                      | 0x0020 |
| * TxRetryCount                                                      | 0x0021 |
| * TxDirectMaxRetryExpiryCount                                       | 0x0022 |
| * TxIndirectMaxRetryExpiryCount                                     | 0x0023 |
| * TxErrCcaCount                                                     | 0x0024 |
| * TxErrAbortCount                                                   | 0x0025 |
| * TxErrBusyChannelCount                                             | 0x0026 |
| * RxTotalCount                                                      | 0x0027 |
| * RxUnicastCount                                                    | 0x0028 |
| * RxBroadcastCount                                                  | 0x0029 |
| * RxDataCount                                                       | 0x002A |
| * RxDataPollCount                                                   | 0x002B |
| * RxBeaconCount                                                     | 0x002C |
| * RxBeaconRequestCount                                              | 0x002D |
| * RxOtherCount                                                      | 0x002E |
| * RxAddressFilteredCount                                            | 0x002F |
| * RxDestAddrFilteredCount                                           | 0x0030 |
| * RxDuplicatedCount                                                 | 0x0031 |
| * RxErrNoFrameCount                                                 | 0x0032 |
| * RxErrUnknownNeighborCount                                         | 0x0033 |
| * RxErrInvalidSrcAddrCount                                          | 0x0034 |
| * RxErrSecCount                                                     | 0x0035 |
| * RxErrFcsCount                                                     | 0x0036 |
| * RxErrOtherCount                                                   | 0x0037 |
| * ActiveTimestamp                                                   | 0x0038 |
| * PendingTimestamp                                                  | 0x0039 |
| * Delay                                                             | 0x003A |
| * SecurityPolicy                                                    | 0x003B |
| * ChannelMask                                                       | 0x003C |
| * OperationalDatasetComponents                                      | 0x003D |
| * ActiveNetworkFaultsList                                           | 0x003E |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class ThreadNetworkDiagnosticsResetCounts : public ModelCommand
{
public:
    ThreadNetworkDiagnosticsResetCounts() : ModelCommand("reset-counts") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::ThreadNetworkDiagnostics::Commands::ResetCounts::Type mRequest;
};

/*
 * Attribute Channel
 */
class ReadThreadNetworkDiagnosticsChannel : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsChannel() : ModelCommand("read")
    {
        AddArgument("attr-name", "channel");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChannel()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeChannel(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsChannel : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsChannel() : ModelCommand("report")
    {
        AddArgument("attr-name", "channel");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsChannel()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeChannel(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeChannel(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RoutingRole
 */
class ReadThreadNetworkDiagnosticsRoutingRole : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRoutingRole() : ModelCommand("read")
    {
        AddArgument("attr-name", "routing-role");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRoutingRole()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRoutingRole(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRoutingRole : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRoutingRole() : ModelCommand("report")
    {
        AddArgument("attr-name", "routing-role");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRoutingRole()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRoutingRole(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRoutingRole(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NetworkName
 */
class ReadThreadNetworkDiagnosticsNetworkName : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsNetworkName() : ModelCommand("read")
    {
        AddArgument("attr-name", "network-name");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsNetworkName()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNetworkName(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OctetStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsNetworkName : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsNetworkName() : ModelCommand("report")
    {
        AddArgument("attr-name", "network-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsNetworkName()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeNetworkName(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeNetworkName(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<OctetStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PanId
 */
class ReadThreadNetworkDiagnosticsPanId : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsPanId() : ModelCommand("read")
    {
        AddArgument("attr-name", "pan-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPanId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePanId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsPanId : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsPanId() : ModelCommand("report")
    {
        AddArgument("attr-name", "pan-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPanId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePanId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePanId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ExtendedPanId
 */
class ReadThreadNetworkDiagnosticsExtendedPanId : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsExtendedPanId() : ModelCommand("read")
    {
        AddArgument("attr-name", "extended-pan-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsExtendedPanId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeExtendedPanId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsExtendedPanId : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsExtendedPanId() : ModelCommand("report")
    {
        AddArgument("attr-name", "extended-pan-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsExtendedPanId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeExtendedPanId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeExtendedPanId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeshLocalPrefix
 */
class ReadThreadNetworkDiagnosticsMeshLocalPrefix : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsMeshLocalPrefix() : ModelCommand("read")
    {
        AddArgument("attr-name", "mesh-local-prefix");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsMeshLocalPrefix()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMeshLocalPrefix(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OctetStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsMeshLocalPrefix : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsMeshLocalPrefix() : ModelCommand("report")
    {
        AddArgument("attr-name", "mesh-local-prefix");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsMeshLocalPrefix()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMeshLocalPrefix(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMeshLocalPrefix(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<OctetStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadThreadNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsOverrunCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsOverrunCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOverrunCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsOverrunCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsOverrunCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOverrunCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOverrunCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NeighborTableList
 */
class ReadThreadNetworkDiagnosticsNeighborTableList : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsNeighborTableList() : ModelCommand("read")
    {
        AddArgument("attr-name", "neighbor-table-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsNeighborTableList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeNeighborTableList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback>(
            OnThreadNetworkDiagnosticsNeighborTableListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute RouteTableList
 */
class ReadThreadNetworkDiagnosticsRouteTableList : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRouteTableList() : ModelCommand("read")
    {
        AddArgument("attr-name", "route-table-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRouteTableList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRouteTableList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback>(
            OnThreadNetworkDiagnosticsRouteTableListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute PartitionId
 */
class ReadThreadNetworkDiagnosticsPartitionId : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsPartitionId() : ModelCommand("read")
    {
        AddArgument("attr-name", "partition-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPartitionId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePartitionId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsPartitionId : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsPartitionId() : ModelCommand("report")
    {
        AddArgument("attr-name", "partition-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPartitionId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePartitionId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePartitionId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Weighting
 */
class ReadThreadNetworkDiagnosticsWeighting : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsWeighting() : ModelCommand("read")
    {
        AddArgument("attr-name", "weighting");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsWeighting()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeWeighting(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsWeighting : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsWeighting() : ModelCommand("report")
    {
        AddArgument("attr-name", "weighting");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsWeighting()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeWeighting(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeWeighting(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DataVersion
 */
class ReadThreadNetworkDiagnosticsDataVersion : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsDataVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "data-version");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDataVersion()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeDataVersion(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsDataVersion : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsDataVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "data-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsDataVersion()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeDataVersion(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeDataVersion(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StableDataVersion
 */
class ReadThreadNetworkDiagnosticsStableDataVersion : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsStableDataVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "stable-data-version");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsStableDataVersion()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeStableDataVersion(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsStableDataVersion : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsStableDataVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "stable-data-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsStableDataVersion()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeStableDataVersion(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeStableDataVersion(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LeaderRouterId
 */
class ReadThreadNetworkDiagnosticsLeaderRouterId : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsLeaderRouterId() : ModelCommand("read")
    {
        AddArgument("attr-name", "leader-router-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsLeaderRouterId()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLeaderRouterId(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsLeaderRouterId : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsLeaderRouterId() : ModelCommand("report")
    {
        AddArgument("attr-name", "leader-router-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsLeaderRouterId()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLeaderRouterId(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLeaderRouterId(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DetachedRoleCount
 */
class ReadThreadNetworkDiagnosticsDetachedRoleCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsDetachedRoleCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "detached-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDetachedRoleCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeDetachedRoleCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsDetachedRoleCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsDetachedRoleCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "detached-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsDetachedRoleCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeDetachedRoleCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeDetachedRoleCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChildRoleCount
 */
class ReadThreadNetworkDiagnosticsChildRoleCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsChildRoleCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "child-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChildRoleCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeChildRoleCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsChildRoleCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsChildRoleCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "child-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsChildRoleCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeChildRoleCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeChildRoleCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RouterRoleCount
 */
class ReadThreadNetworkDiagnosticsRouterRoleCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRouterRoleCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "router-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRouterRoleCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRouterRoleCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRouterRoleCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRouterRoleCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "router-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRouterRoleCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRouterRoleCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRouterRoleCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LeaderRoleCount
 */
class ReadThreadNetworkDiagnosticsLeaderRoleCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsLeaderRoleCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "leader-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsLeaderRoleCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeLeaderRoleCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsLeaderRoleCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsLeaderRoleCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "leader-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsLeaderRoleCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeLeaderRoleCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeLeaderRoleCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttachAttemptCount
 */
class ReadThreadNetworkDiagnosticsAttachAttemptCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsAttachAttemptCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "attach-attempt-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsAttachAttemptCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeAttachAttemptCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsAttachAttemptCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsAttachAttemptCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "attach-attempt-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsAttachAttemptCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeAttachAttemptCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeAttachAttemptCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                            mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartitionIdChangeCount
 */
class ReadThreadNetworkDiagnosticsPartitionIdChangeCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsPartitionIdChangeCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "partition-id-change-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPartitionIdChangeCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePartitionIdChangeCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsPartitionIdChangeCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsPartitionIdChangeCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "partition-id-change-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPartitionIdChangeCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePartitionIdChangeCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePartitionIdChangeCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BetterPartitionAttachAttemptCount
 */
class ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "better-partition-attach-attempt-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBetterPartitionAttachAttemptCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "better-partition-attach-attempt-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBetterPartitionAttachAttemptCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBetterPartitionAttachAttemptCount(successCallback, onFailureCallback->Cancel(),
                                                                           mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ParentChangeCount
 */
class ReadThreadNetworkDiagnosticsParentChangeCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsParentChangeCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "parent-change-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsParentChangeCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeParentChangeCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsParentChangeCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsParentChangeCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "parent-change-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsParentChangeCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeParentChangeCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeParentChangeCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxTotalCount
 */
class ReadThreadNetworkDiagnosticsTxTotalCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxTotalCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-total-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxTotalCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxTotalCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxTotalCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxTotalCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-total-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxTotalCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxTotalCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxTotalCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxUnicastCount
 */
class ReadThreadNetworkDiagnosticsTxUnicastCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxUnicastCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-unicast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxUnicastCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxUnicastCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxUnicastCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxUnicastCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-unicast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxUnicastCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxUnicastCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxUnicastCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBroadcastCount
 */
class ReadThreadNetworkDiagnosticsTxBroadcastCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxBroadcastCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-broadcast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBroadcastCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxBroadcastCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxBroadcastCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxBroadcastCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-broadcast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxBroadcastCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxBroadcastCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxBroadcastCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxAckRequestedCount
 */
class ReadThreadNetworkDiagnosticsTxAckRequestedCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxAckRequestedCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-ack-requested-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxAckRequestedCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxAckRequestedCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxAckRequestedCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxAckRequestedCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-ack-requested-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxAckRequestedCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxAckRequestedCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxAckRequestedCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxAckedCount
 */
class ReadThreadNetworkDiagnosticsTxAckedCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxAckedCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-acked-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxAckedCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxAckedCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxAckedCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxAckedCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-acked-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxAckedCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxAckedCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxAckedCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxNoAckRequestedCount
 */
class ReadThreadNetworkDiagnosticsTxNoAckRequestedCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxNoAckRequestedCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-no-ack-requested-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxNoAckRequestedCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxNoAckRequestedCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxNoAckRequestedCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxNoAckRequestedCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-no-ack-requested-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxNoAckRequestedCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxNoAckRequestedCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxNoAckRequestedCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                               mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDataCount
 */
class ReadThreadNetworkDiagnosticsTxDataCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxDataCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-data-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDataCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxDataCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxDataCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxDataCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-data-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxDataCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxDataCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxDataCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDataPollCount
 */
class ReadThreadNetworkDiagnosticsTxDataPollCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxDataPollCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-data-poll-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDataPollCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxDataPollCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxDataPollCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxDataPollCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-data-poll-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxDataPollCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxDataPollCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxDataPollCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBeaconCount
 */
class ReadThreadNetworkDiagnosticsTxBeaconCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxBeaconCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-beacon-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBeaconCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxBeaconCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxBeaconCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxBeaconCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-beacon-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxBeaconCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxBeaconCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxBeaconCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBeaconRequestCount
 */
class ReadThreadNetworkDiagnosticsTxBeaconRequestCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxBeaconRequestCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-beacon-request-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBeaconRequestCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxBeaconRequestCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxBeaconRequestCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxBeaconRequestCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-beacon-request-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxBeaconRequestCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxBeaconRequestCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxBeaconRequestCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxOtherCount
 */
class ReadThreadNetworkDiagnosticsTxOtherCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxOtherCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxOtherCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxOtherCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxOtherCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxOtherCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxOtherCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxOtherCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxOtherCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxRetryCount
 */
class ReadThreadNetworkDiagnosticsTxRetryCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxRetryCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-retry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxRetryCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxRetryCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxRetryCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxRetryCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-retry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxRetryCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxRetryCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxRetryCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDirectMaxRetryExpiryCount
 */
class ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-direct-max-retry-expiry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxDirectMaxRetryExpiryCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-direct-max-retry-expiry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxDirectMaxRetryExpiryCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxDirectMaxRetryExpiryCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                     mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxIndirectMaxRetryExpiryCount
 */
class ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-indirect-max-retry-expiry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxIndirectMaxRetryExpiryCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-indirect-max-retry-expiry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxIndirectMaxRetryExpiryCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxIndirectMaxRetryExpiryCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                       mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrCcaCount
 */
class ReadThreadNetworkDiagnosticsTxErrCcaCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxErrCcaCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-cca-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrCcaCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxErrCcaCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxErrCcaCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxErrCcaCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-err-cca-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxErrCcaCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxErrCcaCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxErrCcaCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrAbortCount
 */
class ReadThreadNetworkDiagnosticsTxErrAbortCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxErrAbortCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-abort-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrAbortCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxErrAbortCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxErrAbortCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxErrAbortCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-err-abort-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxErrAbortCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxErrAbortCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxErrAbortCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrBusyChannelCount
 */
class ReadThreadNetworkDiagnosticsTxErrBusyChannelCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsTxErrBusyChannelCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-busy-channel-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrBusyChannelCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTxErrBusyChannelCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsTxErrBusyChannelCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsTxErrBusyChannelCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "tx-err-busy-channel-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxErrBusyChannelCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTxErrBusyChannelCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTxErrBusyChannelCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                               mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxTotalCount
 */
class ReadThreadNetworkDiagnosticsRxTotalCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxTotalCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-total-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxTotalCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxTotalCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxTotalCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxTotalCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-total-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxTotalCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxTotalCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxTotalCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxUnicastCount
 */
class ReadThreadNetworkDiagnosticsRxUnicastCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxUnicastCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-unicast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxUnicastCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxUnicastCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxUnicastCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxUnicastCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-unicast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxUnicastCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxUnicastCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxUnicastCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBroadcastCount
 */
class ReadThreadNetworkDiagnosticsRxBroadcastCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxBroadcastCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-broadcast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBroadcastCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxBroadcastCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxBroadcastCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxBroadcastCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-broadcast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxBroadcastCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxBroadcastCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxBroadcastCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDataCount
 */
class ReadThreadNetworkDiagnosticsRxDataCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxDataCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-data-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDataCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxDataCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxDataCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxDataCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-data-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDataCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxDataCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxDataCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDataPollCount
 */
class ReadThreadNetworkDiagnosticsRxDataPollCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxDataPollCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-data-poll-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDataPollCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxDataPollCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxDataPollCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxDataPollCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-data-poll-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDataPollCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxDataPollCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxDataPollCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBeaconCount
 */
class ReadThreadNetworkDiagnosticsRxBeaconCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxBeaconCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-beacon-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBeaconCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxBeaconCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxBeaconCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxBeaconCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-beacon-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxBeaconCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxBeaconCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxBeaconCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBeaconRequestCount
 */
class ReadThreadNetworkDiagnosticsRxBeaconRequestCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxBeaconRequestCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-beacon-request-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBeaconRequestCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxBeaconRequestCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxBeaconRequestCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxBeaconRequestCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-beacon-request-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxBeaconRequestCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxBeaconRequestCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxBeaconRequestCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxOtherCount
 */
class ReadThreadNetworkDiagnosticsRxOtherCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxOtherCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxOtherCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxOtherCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxOtherCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxOtherCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxOtherCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxOtherCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxOtherCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxAddressFilteredCount
 */
class ReadThreadNetworkDiagnosticsRxAddressFilteredCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxAddressFilteredCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-address-filtered-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxAddressFilteredCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxAddressFilteredCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxAddressFilteredCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxAddressFilteredCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-address-filtered-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxAddressFilteredCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxAddressFilteredCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxAddressFilteredCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDestAddrFilteredCount
 */
class ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-dest-addr-filtered-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxDestAddrFilteredCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-dest-addr-filtered-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxDestAddrFilteredCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxDestAddrFilteredCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                 mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDuplicatedCount
 */
class ReadThreadNetworkDiagnosticsRxDuplicatedCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxDuplicatedCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-duplicated-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDuplicatedCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxDuplicatedCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxDuplicatedCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxDuplicatedCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-duplicated-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDuplicatedCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxDuplicatedCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxDuplicatedCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrNoFrameCount
 */
class ReadThreadNetworkDiagnosticsRxErrNoFrameCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrNoFrameCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-no-frame-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrNoFrameCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxErrNoFrameCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxErrNoFrameCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrNoFrameCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-no-frame-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrNoFrameCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxErrNoFrameCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxErrNoFrameCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrUnknownNeighborCount
 */
class ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-unknown-neighbor-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxErrUnknownNeighborCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-unknown-neighbor-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxErrUnknownNeighborCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxErrUnknownNeighborCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                   mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrInvalidSrcAddrCount
 */
class ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-invalid-src-addr-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxErrInvalidSrcAddrCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-invalid-src-addr-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxErrInvalidSrcAddrCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxErrInvalidSrcAddrCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                  mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrSecCount
 */
class ReadThreadNetworkDiagnosticsRxErrSecCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrSecCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-sec-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrSecCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxErrSecCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxErrSecCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrSecCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-sec-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrSecCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxErrSecCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxErrSecCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrFcsCount
 */
class ReadThreadNetworkDiagnosticsRxErrFcsCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrFcsCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-fcs-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrFcsCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxErrFcsCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxErrFcsCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrFcsCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-fcs-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrFcsCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxErrFcsCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxErrFcsCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrOtherCount
 */
class ReadThreadNetworkDiagnosticsRxErrOtherCount : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsRxErrOtherCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrOtherCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRxErrOtherCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsRxErrOtherCount : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsRxErrOtherCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "rx-err-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrOtherCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRxErrOtherCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRxErrOtherCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveTimestamp
 */
class ReadThreadNetworkDiagnosticsActiveTimestamp : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsActiveTimestamp() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-timestamp");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsActiveTimestamp()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActiveTimestamp(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsActiveTimestamp : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsActiveTimestamp() : ModelCommand("report")
    {
        AddArgument("attr-name", "active-timestamp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsActiveTimestamp()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeActiveTimestamp(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeActiveTimestamp(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PendingTimestamp
 */
class ReadThreadNetworkDiagnosticsPendingTimestamp : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsPendingTimestamp() : ModelCommand("read")
    {
        AddArgument("attr-name", "pending-timestamp");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPendingTimestamp()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePendingTimestamp(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsPendingTimestamp : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsPendingTimestamp() : ModelCommand("report")
    {
        AddArgument("attr-name", "pending-timestamp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPendingTimestamp()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePendingTimestamp(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePendingTimestamp(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Delay
 */
class ReadThreadNetworkDiagnosticsDelay : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsDelay() : ModelCommand("read")
    {
        AddArgument("attr-name", "delay");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDelay()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeDelay(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsDelay : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsDelay() : ModelCommand("report")
    {
        AddArgument("attr-name", "delay");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsDelay()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeDelay(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeDelay(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SecurityPolicy
 */
class ReadThreadNetworkDiagnosticsSecurityPolicy : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsSecurityPolicy() : ModelCommand("read")
    {
        AddArgument("attr-name", "security-policy");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsSecurityPolicy()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSecurityPolicy(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback>(
            OnThreadNetworkDiagnosticsSecurityPolicyListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ChannelMask
 */
class ReadThreadNetworkDiagnosticsChannelMask : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsChannelMask() : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-mask");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChannelMask()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeChannelMask(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OctetStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsChannelMask : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsChannelMask() : ModelCommand("report")
    {
        AddArgument("attr-name", "channel-mask");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsChannelMask()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeChannelMask(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeChannelMask(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<OctetStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationalDatasetComponents
 */
class ReadThreadNetworkDiagnosticsOperationalDatasetComponents : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsOperationalDatasetComponents() : ModelCommand("read")
    {
        AddArgument("attr-name", "operational-dataset-components");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsOperationalDatasetComponents()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOperationalDatasetComponents(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback>(
            OnThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ActiveNetworkFaultsList
 */
class ReadThreadNetworkDiagnosticsActiveNetworkFaultsList : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsActiveNetworkFaultsList() : ModelCommand("read")
    {
        AddArgument("attr-name", "active-network-faults-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsActiveNetworkFaultsList()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeActiveNetworkFaultsList(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback>(
            OnThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ClusterRevision
 */
class ReadThreadNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReadThreadNetworkDiagnosticsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportThreadNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReportThreadNetworkDiagnosticsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0035) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::ThreadNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WakeOnLan                                                   | 0x0503 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * WakeOnLanMacAddress                                               | 0x0000 |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Attribute WakeOnLanMacAddress
 */
class ReadWakeOnLanWakeOnLanMacAddress : public ModelCommand
{
public:
    ReadWakeOnLanWakeOnLanMacAddress() : ModelCommand("read")
    {
        AddArgument("attr-name", "wake-on-lan-mac-address");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanWakeOnLanMacAddress()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0503) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WakeOnLanCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeWakeOnLanMacAddress(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<CharStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWakeOnLanWakeOnLanMacAddress : public ModelCommand
{
public:
    ReportWakeOnLanWakeOnLanMacAddress() : ModelCommand("report")
    {
        AddArgument("attr-name", "wake-on-lan-mac-address");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWakeOnLanWakeOnLanMacAddress()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0503) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WakeOnLanCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeWakeOnLanMacAddress(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeWakeOnLanMacAddress(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<CharStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<CharStringAttributeCallback>(OnCharStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWakeOnLanClusterRevision : public ModelCommand
{
public:
    ReadWakeOnLanClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0503) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WakeOnLanCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWakeOnLanClusterRevision : public ModelCommand
{
public:
    ReportWakeOnLanClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWakeOnLanClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0503) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WakeOnLanCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WiFiNetworkDiagnostics                                      | 0x0036 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Bssid                                                             | 0x0000 |
| * SecurityType                                                      | 0x0001 |
| * WiFiVersion                                                       | 0x0002 |
| * ChannelNumber                                                     | 0x0003 |
| * Rssi                                                              | 0x0004 |
| * BeaconLostCount                                                   | 0x0005 |
| * BeaconRxCount                                                     | 0x0006 |
| * PacketMulticastRxCount                                            | 0x0007 |
| * PacketMulticastTxCount                                            | 0x0008 |
| * PacketUnicastRxCount                                              | 0x0009 |
| * PacketUnicastTxCount                                              | 0x000A |
| * CurrentMaxRate                                                    | 0x000B |
| * OverrunCount                                                      | 0x000C |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class WiFiNetworkDiagnosticsResetCounts : public ModelCommand
{
public:
    WiFiNetworkDiagnosticsResetCounts() : ModelCommand("reset-counts") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::WiFiNetworkDiagnostics::Commands::ResetCounts::Type mRequest;
};

/*
 * Attribute Bssid
 */
class ReadWiFiNetworkDiagnosticsBssid : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsBssid() : ModelCommand("read")
    {
        AddArgument("attr-name", "bssid");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBssid()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBssid(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<OctetStringAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsBssid : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsBssid() : ModelCommand("report")
    {
        AddArgument("attr-name", "bssid");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsBssid()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBssid(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBssid(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<OctetStringAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<OctetStringAttributeCallback>(OnOctetStringAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SecurityType
 */
class ReadWiFiNetworkDiagnosticsSecurityType : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsSecurityType() : ModelCommand("read")
    {
        AddArgument("attr-name", "security-type");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsSecurityType()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSecurityType(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsSecurityType : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsSecurityType() : ModelCommand("report")
    {
        AddArgument("attr-name", "security-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsSecurityType()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSecurityType(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSecurityType(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WiFiVersion
 */
class ReadWiFiNetworkDiagnosticsWiFiVersion : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsWiFiVersion() : ModelCommand("read")
    {
        AddArgument("attr-name", "wi-fi-version");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsWiFiVersion()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeWiFiVersion(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsWiFiVersion : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsWiFiVersion() : ModelCommand("report")
    {
        AddArgument("attr-name", "wi-fi-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsWiFiVersion()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeWiFiVersion(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeWiFiVersion(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChannelNumber
 */
class ReadWiFiNetworkDiagnosticsChannelNumber : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsChannelNumber() : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-number");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsChannelNumber()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeChannelNumber(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsChannelNumber : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsChannelNumber() : ModelCommand("report")
    {
        AddArgument("attr-name", "channel-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsChannelNumber()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeChannelNumber(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeChannelNumber(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Rssi
 */
class ReadWiFiNetworkDiagnosticsRssi : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsRssi() : ModelCommand("read")
    {
        AddArgument("attr-name", "rssi");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsRssi()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeRssi(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8sAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8sAttributeCallback>(OnInt8sAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsRssi : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsRssi() : ModelCommand("report")
    {
        AddArgument("attr-name", "rssi");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsRssi()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeRssi(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeRssi(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8sAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8sAttributeCallback>(OnInt8sAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BeaconLostCount
 */
class ReadWiFiNetworkDiagnosticsBeaconLostCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsBeaconLostCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "beacon-lost-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBeaconLostCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBeaconLostCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsBeaconLostCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsBeaconLostCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "beacon-lost-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsBeaconLostCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBeaconLostCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBeaconLostCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BeaconRxCount
 */
class ReadWiFiNetworkDiagnosticsBeaconRxCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsBeaconRxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "beacon-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBeaconRxCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeBeaconRxCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsBeaconRxCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsBeaconRxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "beacon-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsBeaconRxCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeBeaconRxCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeBeaconRxCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketMulticastRxCount
 */
class ReadWiFiNetworkDiagnosticsPacketMulticastRxCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsPacketMulticastRxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-multicast-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketMulticastRxCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePacketMulticastRxCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsPacketMulticastRxCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsPacketMulticastRxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-multicast-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketMulticastRxCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePacketMulticastRxCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePacketMulticastRxCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketMulticastTxCount
 */
class ReadWiFiNetworkDiagnosticsPacketMulticastTxCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsPacketMulticastTxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-multicast-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketMulticastTxCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePacketMulticastTxCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsPacketMulticastTxCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsPacketMulticastTxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-multicast-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketMulticastTxCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePacketMulticastTxCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePacketMulticastTxCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketUnicastRxCount
 */
class ReadWiFiNetworkDiagnosticsPacketUnicastRxCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsPacketUnicastRxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-unicast-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketUnicastRxCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePacketUnicastRxCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsPacketUnicastRxCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsPacketUnicastRxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-unicast-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketUnicastRxCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePacketUnicastRxCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePacketUnicastRxCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketUnicastTxCount
 */
class ReadWiFiNetworkDiagnosticsPacketUnicastTxCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsPacketUnicastTxCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-unicast-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketUnicastTxCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributePacketUnicastTxCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsPacketUnicastTxCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsPacketUnicastTxCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "packet-unicast-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketUnicastTxCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributePacketUnicastTxCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributePacketUnicastTxCount(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                              mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentMaxRate
 */
class ReadWiFiNetworkDiagnosticsCurrentMaxRate : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsCurrentMaxRate() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-max-rate");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsCurrentMaxRate()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentMaxRate(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsCurrentMaxRate : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsCurrentMaxRate() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-max-rate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsCurrentMaxRate()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentMaxRate(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentMaxRate(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadWiFiNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsOverrunCount() : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsOverrunCount()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOverrunCount(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int64uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsOverrunCount : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsOverrunCount() : ModelCommand("report")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsOverrunCount()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOverrunCount(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOverrunCount(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int64uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int64uAttributeCallback>(OnInt64uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadWiFiNetworkDiagnosticsFeatureMap : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsFeatureMap()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeFeatureMap(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

/*
 * Attribute ClusterRevision
 */
class ReadWiFiNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReadWiFiNetworkDiagnosticsClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWiFiNetworkDiagnosticsClusterRevision : public ModelCommand
{
public:
    ReportWiFiNetworkDiagnosticsClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0036) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WiFiNetworkDiagnosticsCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WindowCovering                                              | 0x0102 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * DownOrClose                                                       |   0x01 |
| * GoToLiftPercentage                                                |   0x05 |
| * GoToLiftValue                                                     |   0x04 |
| * GoToTiltPercentage                                                |   0x08 |
| * GoToTiltValue                                                     |   0x07 |
| * StopMotion                                                        |   0x02 |
| * UpOrOpen                                                          |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Type                                                              | 0x0000 |
| * CurrentPositionLift                                               | 0x0003 |
| * CurrentPositionTilt                                               | 0x0004 |
| * ConfigStatus                                                      | 0x0007 |
| * CurrentPositionLiftPercentage                                     | 0x0008 |
| * CurrentPositionTiltPercentage                                     | 0x0009 |
| * OperationalStatus                                                 | 0x000A |
| * TargetPositionLiftPercent100ths                                   | 0x000B |
| * TargetPositionTiltPercent100ths                                   | 0x000C |
| * EndProductType                                                    | 0x000D |
| * CurrentPositionLiftPercent100ths                                  | 0x000E |
| * CurrentPositionTiltPercent100ths                                  | 0x000F |
| * InstalledOpenLimitLift                                            | 0x0010 |
| * InstalledClosedLimitLift                                          | 0x0011 |
| * InstalledOpenLimitTilt                                            | 0x0012 |
| * InstalledClosedLimitTilt                                          | 0x0013 |
| * Mode                                                              | 0x0017 |
| * SafetyStatus                                                      | 0x001A |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
\*----------------------------------------------------------------------------*/

/*
 * Command DownOrClose
 */
class WindowCoveringDownOrClose : public ModelCommand
{
public:
    WindowCoveringDownOrClose() : ModelCommand("down-or-close") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000001) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type mRequest;
};

/*
 * Command GoToLiftPercentage
 */
class WindowCoveringGoToLiftPercentage : public ModelCommand
{
public:
    WindowCoveringGoToLiftPercentage() : ModelCommand("go-to-lift-percentage")
    {
        AddArgument("LiftPercentageValue", 0, UINT8_MAX, &mRequest.liftPercentageValue);
        AddArgument("LiftPercent100thsValue", 0, UINT16_MAX, &mRequest.liftPercent100thsValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000005) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type mRequest;
};

/*
 * Command GoToLiftValue
 */
class WindowCoveringGoToLiftValue : public ModelCommand
{
public:
    WindowCoveringGoToLiftValue() : ModelCommand("go-to-lift-value")
    {
        AddArgument("LiftValue", 0, UINT16_MAX, &mRequest.liftValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000004) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::GoToLiftValue::Type mRequest;
};

/*
 * Command GoToTiltPercentage
 */
class WindowCoveringGoToTiltPercentage : public ModelCommand
{
public:
    WindowCoveringGoToTiltPercentage() : ModelCommand("go-to-tilt-percentage")
    {
        AddArgument("TiltPercentageValue", 0, UINT8_MAX, &mRequest.tiltPercentageValue);
        AddArgument("TiltPercent100thsValue", 0, UINT16_MAX, &mRequest.tiltPercent100thsValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000008) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type mRequest;
};

/*
 * Command GoToTiltValue
 */
class WindowCoveringGoToTiltValue : public ModelCommand
{
public:
    WindowCoveringGoToTiltValue() : ModelCommand("go-to-tilt-value")
    {
        AddArgument("TiltValue", 0, UINT16_MAX, &mRequest.tiltValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000007) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::GoToTiltValue::Type mRequest;
};

/*
 * Command StopMotion
 */
class WindowCoveringStopMotion : public ModelCommand
{
public:
    WindowCoveringStopMotion() : ModelCommand("stop-motion") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000002) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::StopMotion::Type mRequest;
};

/*
 * Command UpOrOpen
 */
class WindowCoveringUpOrOpen : public ModelCommand
{
public:
    WindowCoveringUpOrOpen() : ModelCommand("up-or-open") { ModelCommand::AddArguments(); }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000000) on endpoint %" PRIu8, endpointId);

        return chip::Controller::InvokeCommand(device, this, OnDefaultSuccess, OnDefaultFailure, endpointId, mRequest);
    }

private:
    chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type mRequest;
};

/*
 * Attribute Type
 */
class ReadWindowCoveringType : public ModelCommand
{
public:
    ReadWindowCoveringType() : ModelCommand("read")
    {
        AddArgument("attr-name", "type");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringType()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeType(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringType : public ModelCommand
{
public:
    ReportWindowCoveringType() : ModelCommand("report")
    {
        AddArgument("attr-name", "type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringType()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeType(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeType(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLift
 */
class ReadWindowCoveringCurrentPositionLift : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionLift() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLift()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentPositionLift(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringCurrentPositionLift : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionLift() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionLift()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentPositionLift(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentPositionLift(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTilt
 */
class ReadWindowCoveringCurrentPositionTilt : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionTilt() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTilt()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentPositionTilt(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringCurrentPositionTilt : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionTilt() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionTilt()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentPositionTilt(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentPositionTilt(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                             mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ConfigStatus
 */
class ReadWindowCoveringConfigStatus : public ModelCommand
{
public:
    ReadWindowCoveringConfigStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "config-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringConfigStatus()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeConfigStatus(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringConfigStatus : public ModelCommand
{
public:
    ReportWindowCoveringConfigStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "config-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringConfigStatus()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeConfigStatus(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeConfigStatus(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLiftPercentage
 */
class ReadWindowCoveringCurrentPositionLiftPercentage : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionLiftPercentage() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift-percentage");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLiftPercentage()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentPositionLiftPercentage(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringCurrentPositionLiftPercentage : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionLiftPercentage() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-lift-percentage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionLiftPercentage()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentPositionLiftPercentage(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentPositionLiftPercentage(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                       mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTiltPercentage
 */
class ReadWindowCoveringCurrentPositionTiltPercentage : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionTiltPercentage() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt-percentage");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTiltPercentage()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentPositionTiltPercentage(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringCurrentPositionTiltPercentage : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionTiltPercentage() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-tilt-percentage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionTiltPercentage()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentPositionTiltPercentage(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentPositionTiltPercentage(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                       mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationalStatus
 */
class ReadWindowCoveringOperationalStatus : public ModelCommand
{
public:
    ReadWindowCoveringOperationalStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "operational-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringOperationalStatus()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeOperationalStatus(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringOperationalStatus : public ModelCommand
{
public:
    ReportWindowCoveringOperationalStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "operational-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringOperationalStatus()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeOperationalStatus(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeOperationalStatus(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                           mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetPositionLiftPercent100ths
 */
class ReadWindowCoveringTargetPositionLiftPercent100ths : public ModelCommand
{
public:
    ReadWindowCoveringTargetPositionLiftPercent100ths() : ModelCommand("read")
    {
        AddArgument("attr-name", "target-position-lift-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringTargetPositionLiftPercent100ths()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTargetPositionLiftPercent100ths(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringTargetPositionLiftPercent100ths : public ModelCommand
{
public:
    ReportWindowCoveringTargetPositionLiftPercent100ths() : ModelCommand("report")
    {
        AddArgument("attr-name", "target-position-lift-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringTargetPositionLiftPercent100ths()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTargetPositionLiftPercent100ths(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTargetPositionLiftPercent100ths(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                         mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetPositionTiltPercent100ths
 */
class ReadWindowCoveringTargetPositionTiltPercent100ths : public ModelCommand
{
public:
    ReadWindowCoveringTargetPositionTiltPercent100ths() : ModelCommand("read")
    {
        AddArgument("attr-name", "target-position-tilt-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringTargetPositionTiltPercent100ths()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeTargetPositionTiltPercent100ths(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringTargetPositionTiltPercent100ths : public ModelCommand
{
public:
    ReportWindowCoveringTargetPositionTiltPercent100ths() : ModelCommand("report")
    {
        AddArgument("attr-name", "target-position-tilt-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringTargetPositionTiltPercent100ths()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeTargetPositionTiltPercent100ths(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeTargetPositionTiltPercent100ths(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                         mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EndProductType
 */
class ReadWindowCoveringEndProductType : public ModelCommand
{
public:
    ReadWindowCoveringEndProductType() : ModelCommand("read")
    {
        AddArgument("attr-name", "end-product-type");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringEndProductType()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeEndProductType(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringEndProductType : public ModelCommand
{
public:
    ReportWindowCoveringEndProductType() : ModelCommand("report")
    {
        AddArgument("attr-name", "end-product-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringEndProductType()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeEndProductType(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeEndProductType(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLiftPercent100ths
 */
class ReadWindowCoveringCurrentPositionLiftPercent100ths : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionLiftPercent100ths() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLiftPercent100ths()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentPositionLiftPercent100ths(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringCurrentPositionLiftPercent100ths : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionLiftPercent100ths() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-lift-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionLiftPercent100ths()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentPositionLiftPercent100ths(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentPositionLiftPercent100ths(successCallback, onFailureCallback->Cancel(),
                                                                          mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTiltPercent100ths
 */
class ReadWindowCoveringCurrentPositionTiltPercent100ths : public ModelCommand
{
public:
    ReadWindowCoveringCurrentPositionTiltPercent100ths() : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTiltPercent100ths()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeCurrentPositionTiltPercent100ths(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringCurrentPositionTiltPercent100ths : public ModelCommand
{
public:
    ReportWindowCoveringCurrentPositionTiltPercent100ths() : ModelCommand("report")
    {
        AddArgument("attr-name", "current-position-tilt-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionTiltPercent100ths()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeCurrentPositionTiltPercent100ths(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeCurrentPositionTiltPercent100ths(successCallback, onFailureCallback->Cancel(),
                                                                          mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledOpenLimitLift
 */
class ReadWindowCoveringInstalledOpenLimitLift : public ModelCommand
{
public:
    ReadWindowCoveringInstalledOpenLimitLift() : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-open-limit-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledOpenLimitLift()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInstalledOpenLimitLift(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringInstalledOpenLimitLift : public ModelCommand
{
public:
    ReportWindowCoveringInstalledOpenLimitLift() : ModelCommand("report")
    {
        AddArgument("attr-name", "installed-open-limit-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledOpenLimitLift()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInstalledOpenLimitLift(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInstalledOpenLimitLift(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledClosedLimitLift
 */
class ReadWindowCoveringInstalledClosedLimitLift : public ModelCommand
{
public:
    ReadWindowCoveringInstalledClosedLimitLift() : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-closed-limit-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledClosedLimitLift()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInstalledClosedLimitLift(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringInstalledClosedLimitLift : public ModelCommand
{
public:
    ReportWindowCoveringInstalledClosedLimitLift() : ModelCommand("report")
    {
        AddArgument("attr-name", "installed-closed-limit-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledClosedLimitLift()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInstalledClosedLimitLift(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInstalledClosedLimitLift(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                  mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledOpenLimitTilt
 */
class ReadWindowCoveringInstalledOpenLimitTilt : public ModelCommand
{
public:
    ReadWindowCoveringInstalledOpenLimitTilt() : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-open-limit-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledOpenLimitTilt()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInstalledOpenLimitTilt(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringInstalledOpenLimitTilt : public ModelCommand
{
public:
    ReportWindowCoveringInstalledOpenLimitTilt() : ModelCommand("report")
    {
        AddArgument("attr-name", "installed-open-limit-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledOpenLimitTilt()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInstalledOpenLimitTilt(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInstalledOpenLimitTilt(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledClosedLimitTilt
 */
class ReadWindowCoveringInstalledClosedLimitTilt : public ModelCommand
{
public:
    ReadWindowCoveringInstalledClosedLimitTilt() : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-closed-limit-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledClosedLimitTilt()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeInstalledClosedLimitTilt(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringInstalledClosedLimitTilt : public ModelCommand
{
public:
    ReportWindowCoveringInstalledClosedLimitTilt() : ModelCommand("report")
    {
        AddArgument("attr-name", "installed-closed-limit-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledClosedLimitTilt()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeInstalledClosedLimitTilt(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeInstalledClosedLimitTilt(successCallback, onFailureCallback->Cancel(), mMinInterval,
                                                                  mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Mode
 */
class ReadWindowCoveringMode : public ModelCommand
{
public:
    ReadWindowCoveringMode() : ModelCommand("read")
    {
        AddArgument("attr-name", "mode");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int8uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class WriteWindowCoveringMode : public ModelCommand
{
public:
    WriteWindowCoveringMode() : ModelCommand("write")
    {
        AddArgument("attr-name", "mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteWindowCoveringMode()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x01) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.WriteAttributeMode(onSuccessCallback->Cancel(), onFailureCallback->Cancel(), mValue);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    uint8_t mValue;
};

class ReportWindowCoveringMode : public ModelCommand
{
public:
    ReportWindowCoveringMode() : ModelCommand("report")
    {
        AddArgument("attr-name", "mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringMode()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeMode(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeMode(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int8uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int8uAttributeCallback>(OnInt8uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SafetyStatus
 */
class ReadWindowCoveringSafetyStatus : public ModelCommand
{
public:
    ReadWindowCoveringSafetyStatus() : ModelCommand("read")
    {
        AddArgument("attr-name", "safety-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringSafetyStatus()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeSafetyStatus(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringSafetyStatus : public ModelCommand
{
public:
    ReportWindowCoveringSafetyStatus() : ModelCommand("report")
    {
        AddArgument("attr-name", "safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringSafetyStatus()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeSafetyStatus(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeSafetyStatus(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadWindowCoveringFeatureMap : public ModelCommand
{
public:
    ReadWindowCoveringFeatureMap() : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringFeatureMap()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeFeatureMap(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int32uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringFeatureMap : public ModelCommand
{
public:
    ReportWindowCoveringFeatureMap() : ModelCommand("report")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringFeatureMap()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeFeatureMap(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeFeatureMap(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int32uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int32uAttributeCallback>(OnInt32uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWindowCoveringClusterRevision : public ModelCommand
{
public:
    ReadWindowCoveringClusterRevision() : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringClusterRevision()
    {
        delete onSuccessCallback;
        delete onFailureCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x00) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);
        return cluster.ReadAttributeClusterRevision(onSuccessCallback->Cancel(), onFailureCallback->Cancel());
    }

private:
    chip::Callback::Callback<Int16uAttributeCallback> * onSuccessCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeResponse, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
};

class ReportWindowCoveringClusterRevision : public ModelCommand
{
public:
    ReportWindowCoveringClusterRevision() : ModelCommand("report")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringClusterRevision()
    {
        delete onSuccessCallback;
        delete onSuccessCallbackWithoutExit;
        delete onFailureCallback;
        delete onReportCallback;
    }

    CHIP_ERROR SendCommand(ChipDevice * device, uint8_t endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0102) command (0x06) on endpoint %" PRIu8, endpointId);

        chip::Controller::WindowCoveringCluster cluster;
        cluster.Associate(device, endpointId);

        ReturnErrorOnFailure(cluster.ReportAttributeClusterRevision(onReportCallback->Cancel()));

        chip::Callback::Cancelable * successCallback = mWait ? onSuccessCallbackWithoutExit->Cancel() : onSuccessCallback->Cancel();
        return cluster.SubscribeAttributeClusterRevision(successCallback, onFailureCallback->Cancel(), mMinInterval, mMaxInterval);
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallback =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponse, this);
    chip::Callback::Callback<DefaultSuccessCallback> * onSuccessCallbackWithoutExit =
        new chip::Callback::Callback<DefaultSuccessCallback>(OnDefaultSuccessResponseWithoutExit, this);
    chip::Callback::Callback<DefaultFailureCallback> * onFailureCallback =
        new chip::Callback::Callback<DefaultFailureCallback>(OnDefaultFailureResponse, this);
    chip::Callback::Callback<Int16uAttributeCallback> * onReportCallback =
        new chip::Callback::Callback<Int16uAttributeCallback>(OnInt16uAttributeReport, this);
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Register all Clusters commands                                               |
\*----------------------------------------------------------------------------*/
void registerClusterAccountLogin(Commands & commands)
{
    const char * clusterName = "AccountLogin";

    commands_list clusterCommands = {
        make_unique<AccountLoginGetSetupPIN>(),           //
        make_unique<AccountLoginLogin>(),                 //
        make_unique<ReadAccountLoginClusterRevision>(),   //
        make_unique<ReportAccountLoginClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAdministratorCommissioning(Commands & commands)
{
    const char * clusterName = "AdministratorCommissioning";

    commands_list clusterCommands = {
        make_unique<AdministratorCommissioningOpenBasicCommissioningWindow>(), //
        make_unique<AdministratorCommissioningOpenCommissioningWindow>(),      //
        make_unique<AdministratorCommissioningRevokeCommissioning>(),          //
        make_unique<ReadAdministratorCommissioningClusterRevision>(),          //
        make_unique<ReportAdministratorCommissioningClusterRevision>(),        //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterApplicationBasic(Commands & commands)
{
    const char * clusterName = "ApplicationBasic";

    commands_list clusterCommands = {
        make_unique<ApplicationBasicChangeStatus>(),            //
        make_unique<ReadApplicationBasicVendorName>(),          //
        make_unique<ReportApplicationBasicVendorName>(),        //
        make_unique<ReadApplicationBasicVendorId>(),            //
        make_unique<ReportApplicationBasicVendorId>(),          //
        make_unique<ReadApplicationBasicApplicationName>(),     //
        make_unique<ReportApplicationBasicApplicationName>(),   //
        make_unique<ReadApplicationBasicProductId>(),           //
        make_unique<ReportApplicationBasicProductId>(),         //
        make_unique<ReadApplicationBasicApplicationId>(),       //
        make_unique<ReportApplicationBasicApplicationId>(),     //
        make_unique<ReadApplicationBasicCatalogVendorId>(),     //
        make_unique<ReportApplicationBasicCatalogVendorId>(),   //
        make_unique<ReadApplicationBasicApplicationStatus>(),   //
        make_unique<ReportApplicationBasicApplicationStatus>(), //
        make_unique<ReadApplicationBasicClusterRevision>(),     //
        make_unique<ReportApplicationBasicClusterRevision>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterApplicationLauncher(Commands & commands)
{
    const char * clusterName = "ApplicationLauncher";

    commands_list clusterCommands = {
        make_unique<ApplicationLauncherLaunchApp>(),                   //
        make_unique<ReadApplicationLauncherApplicationLauncherList>(), //
        make_unique<ReadApplicationLauncherCatalogVendorId>(),         //
        make_unique<ReportApplicationLauncherCatalogVendorId>(),       //
        make_unique<ReadApplicationLauncherApplicationId>(),           //
        make_unique<ReportApplicationLauncherApplicationId>(),         //
        make_unique<ReadApplicationLauncherClusterRevision>(),         //
        make_unique<ReportApplicationLauncherClusterRevision>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAudioOutput(Commands & commands)
{
    const char * clusterName = "AudioOutput";

    commands_list clusterCommands = {
        make_unique<AudioOutputRenameOutput>(),             //
        make_unique<AudioOutputSelectOutput>(),             //
        make_unique<ReadAudioOutputAudioOutputList>(),      //
        make_unique<ReadAudioOutputCurrentAudioOutput>(),   //
        make_unique<ReportAudioOutputCurrentAudioOutput>(), //
        make_unique<ReadAudioOutputClusterRevision>(),      //
        make_unique<ReportAudioOutputClusterRevision>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBarrierControl(Commands & commands)
{
    const char * clusterName = "BarrierControl";

    commands_list clusterCommands = {
        make_unique<BarrierControlBarrierControlGoToPercent>(), //
        make_unique<BarrierControlBarrierControlStop>(),        //
        make_unique<ReadBarrierControlBarrierMovingState>(),    //
        make_unique<ReportBarrierControlBarrierMovingState>(),  //
        make_unique<ReadBarrierControlBarrierSafetyStatus>(),   //
        make_unique<ReportBarrierControlBarrierSafetyStatus>(), //
        make_unique<ReadBarrierControlBarrierCapabilities>(),   //
        make_unique<ReportBarrierControlBarrierCapabilities>(), //
        make_unique<ReadBarrierControlBarrierPosition>(),       //
        make_unique<ReportBarrierControlBarrierPosition>(),     //
        make_unique<ReadBarrierControlClusterRevision>(),       //
        make_unique<ReportBarrierControlClusterRevision>(),     //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBasic(Commands & commands)
{
    const char * clusterName = "Basic";

    commands_list clusterCommands = {
        make_unique<BasicMfgSpecificPing>(),               //
        make_unique<ReadBasicInteractionModelVersion>(),   //
        make_unique<ReportBasicInteractionModelVersion>(), //
        make_unique<ReadBasicVendorName>(),                //
        make_unique<ReportBasicVendorName>(),              //
        make_unique<ReadBasicVendorID>(),                  //
        make_unique<ReportBasicVendorID>(),                //
        make_unique<ReadBasicProductName>(),               //
        make_unique<ReportBasicProductName>(),             //
        make_unique<ReadBasicProductID>(),                 //
        make_unique<ReportBasicProductID>(),               //
        make_unique<ReadBasicUserLabel>(),                 //
        make_unique<WriteBasicUserLabel>(),                //
        make_unique<ReportBasicUserLabel>(),               //
        make_unique<ReadBasicLocation>(),                  //
        make_unique<WriteBasicLocation>(),                 //
        make_unique<ReportBasicLocation>(),                //
        make_unique<ReadBasicHardwareVersion>(),           //
        make_unique<ReportBasicHardwareVersion>(),         //
        make_unique<ReadBasicHardwareVersionString>(),     //
        make_unique<ReportBasicHardwareVersionString>(),   //
        make_unique<ReadBasicSoftwareVersion>(),           //
        make_unique<ReportBasicSoftwareVersion>(),         //
        make_unique<ReadBasicSoftwareVersionString>(),     //
        make_unique<ReportBasicSoftwareVersionString>(),   //
        make_unique<ReadBasicManufacturingDate>(),         //
        make_unique<ReportBasicManufacturingDate>(),       //
        make_unique<ReadBasicPartNumber>(),                //
        make_unique<ReportBasicPartNumber>(),              //
        make_unique<ReadBasicProductURL>(),                //
        make_unique<ReportBasicProductURL>(),              //
        make_unique<ReadBasicProductLabel>(),              //
        make_unique<ReportBasicProductLabel>(),            //
        make_unique<ReadBasicSerialNumber>(),              //
        make_unique<ReportBasicSerialNumber>(),            //
        make_unique<ReadBasicLocalConfigDisabled>(),       //
        make_unique<WriteBasicLocalConfigDisabled>(),      //
        make_unique<ReportBasicLocalConfigDisabled>(),     //
        make_unique<ReadBasicReachable>(),                 //
        make_unique<ReportBasicReachable>(),               //
        make_unique<ReadBasicClusterRevision>(),           //
        make_unique<ReportBasicClusterRevision>(),         //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBinaryInputBasic(Commands & commands)
{
    const char * clusterName = "BinaryInputBasic";

    commands_list clusterCommands = {
        make_unique<ReadBinaryInputBasicOutOfService>(),      //
        make_unique<WriteBinaryInputBasicOutOfService>(),     //
        make_unique<ReportBinaryInputBasicOutOfService>(),    //
        make_unique<ReadBinaryInputBasicPresentValue>(),      //
        make_unique<WriteBinaryInputBasicPresentValue>(),     //
        make_unique<ReportBinaryInputBasicPresentValue>(),    //
        make_unique<ReadBinaryInputBasicStatusFlags>(),       //
        make_unique<ReportBinaryInputBasicStatusFlags>(),     //
        make_unique<ReadBinaryInputBasicClusterRevision>(),   //
        make_unique<ReportBinaryInputBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBinding(Commands & commands)
{
    const char * clusterName = "Binding";

    commands_list clusterCommands = {
        make_unique<BindingBind>(),                  //
        make_unique<BindingUnbind>(),                //
        make_unique<ReadBindingClusterRevision>(),   //
        make_unique<ReportBindingClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBooleanState(Commands & commands)
{
    const char * clusterName = "BooleanState";

    commands_list clusterCommands = {
        make_unique<ReadBooleanStateStateValue>(),        //
        make_unique<ReportBooleanStateStateValue>(),      //
        make_unique<ReadBooleanStateClusterRevision>(),   //
        make_unique<ReportBooleanStateClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBridgedActions(Commands & commands)
{
    const char * clusterName = "BridgedActions";

    commands_list clusterCommands = {
        make_unique<BridgedActionsDisableAction>(),               //
        make_unique<BridgedActionsDisableActionWithDuration>(),   //
        make_unique<BridgedActionsEnableAction>(),                //
        make_unique<BridgedActionsEnableActionWithDuration>(),    //
        make_unique<BridgedActionsInstantAction>(),               //
        make_unique<BridgedActionsInstantActionWithTransition>(), //
        make_unique<BridgedActionsPauseAction>(),                 //
        make_unique<BridgedActionsPauseActionWithDuration>(),     //
        make_unique<BridgedActionsResumeAction>(),                //
        make_unique<BridgedActionsStartAction>(),                 //
        make_unique<BridgedActionsStartActionWithDuration>(),     //
        make_unique<BridgedActionsStopAction>(),                  //
        make_unique<ReadBridgedActionsActionList>(),              //
        make_unique<ReadBridgedActionsEndpointList>(),            //
        make_unique<ReadBridgedActionsSetupUrl>(),                //
        make_unique<ReportBridgedActionsSetupUrl>(),              //
        make_unique<ReadBridgedActionsClusterRevision>(),         //
        make_unique<ReportBridgedActionsClusterRevision>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBridgedDeviceBasicInformation(Commands & commands)
{
    const char * clusterName = "BridgedDeviceBasicInformation";

    commands_list clusterCommands = {
        make_unique<ReadBridgedDeviceBasicInformationClusterRevision>(),   //
        make_unique<ReportBridgedDeviceBasicInformationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterColorControl(Commands & commands)
{
    const char * clusterName = "ColorControl";

    commands_list clusterCommands = {
        make_unique<ColorControlColorLoopSet>(),                          //
        make_unique<ColorControlEnhancedMoveHue>(),                       //
        make_unique<ColorControlEnhancedMoveToHue>(),                     //
        make_unique<ColorControlEnhancedMoveToHueAndSaturation>(),        //
        make_unique<ColorControlEnhancedStepHue>(),                       //
        make_unique<ColorControlMoveColor>(),                             //
        make_unique<ColorControlMoveColorTemperature>(),                  //
        make_unique<ColorControlMoveHue>(),                               //
        make_unique<ColorControlMoveSaturation>(),                        //
        make_unique<ColorControlMoveToColor>(),                           //
        make_unique<ColorControlMoveToColorTemperature>(),                //
        make_unique<ColorControlMoveToHue>(),                             //
        make_unique<ColorControlMoveToHueAndSaturation>(),                //
        make_unique<ColorControlMoveToSaturation>(),                      //
        make_unique<ColorControlStepColor>(),                             //
        make_unique<ColorControlStepColorTemperature>(),                  //
        make_unique<ColorControlStepHue>(),                               //
        make_unique<ColorControlStepSaturation>(),                        //
        make_unique<ColorControlStopMoveStep>(),                          //
        make_unique<ReadColorControlCurrentHue>(),                        //
        make_unique<ReportColorControlCurrentHue>(),                      //
        make_unique<ReadColorControlCurrentSaturation>(),                 //
        make_unique<ReportColorControlCurrentSaturation>(),               //
        make_unique<ReadColorControlRemainingTime>(),                     //
        make_unique<ReportColorControlRemainingTime>(),                   //
        make_unique<ReadColorControlCurrentX>(),                          //
        make_unique<ReportColorControlCurrentX>(),                        //
        make_unique<ReadColorControlCurrentY>(),                          //
        make_unique<ReportColorControlCurrentY>(),                        //
        make_unique<ReadColorControlDriftCompensation>(),                 //
        make_unique<ReportColorControlDriftCompensation>(),               //
        make_unique<ReadColorControlCompensationText>(),                  //
        make_unique<ReportColorControlCompensationText>(),                //
        make_unique<ReadColorControlColorTemperature>(),                  //
        make_unique<ReportColorControlColorTemperature>(),                //
        make_unique<ReadColorControlColorMode>(),                         //
        make_unique<ReportColorControlColorMode>(),                       //
        make_unique<ReadColorControlColorControlOptions>(),               //
        make_unique<WriteColorControlColorControlOptions>(),              //
        make_unique<ReportColorControlColorControlOptions>(),             //
        make_unique<ReadColorControlNumberOfPrimaries>(),                 //
        make_unique<ReportColorControlNumberOfPrimaries>(),               //
        make_unique<ReadColorControlPrimary1X>(),                         //
        make_unique<ReportColorControlPrimary1X>(),                       //
        make_unique<ReadColorControlPrimary1Y>(),                         //
        make_unique<ReportColorControlPrimary1Y>(),                       //
        make_unique<ReadColorControlPrimary1Intensity>(),                 //
        make_unique<ReportColorControlPrimary1Intensity>(),               //
        make_unique<ReadColorControlPrimary2X>(),                         //
        make_unique<ReportColorControlPrimary2X>(),                       //
        make_unique<ReadColorControlPrimary2Y>(),                         //
        make_unique<ReportColorControlPrimary2Y>(),                       //
        make_unique<ReadColorControlPrimary2Intensity>(),                 //
        make_unique<ReportColorControlPrimary2Intensity>(),               //
        make_unique<ReadColorControlPrimary3X>(),                         //
        make_unique<ReportColorControlPrimary3X>(),                       //
        make_unique<ReadColorControlPrimary3Y>(),                         //
        make_unique<ReportColorControlPrimary3Y>(),                       //
        make_unique<ReadColorControlPrimary3Intensity>(),                 //
        make_unique<ReportColorControlPrimary3Intensity>(),               //
        make_unique<ReadColorControlPrimary4X>(),                         //
        make_unique<ReportColorControlPrimary4X>(),                       //
        make_unique<ReadColorControlPrimary4Y>(),                         //
        make_unique<ReportColorControlPrimary4Y>(),                       //
        make_unique<ReadColorControlPrimary4Intensity>(),                 //
        make_unique<ReportColorControlPrimary4Intensity>(),               //
        make_unique<ReadColorControlPrimary5X>(),                         //
        make_unique<ReportColorControlPrimary5X>(),                       //
        make_unique<ReadColorControlPrimary5Y>(),                         //
        make_unique<ReportColorControlPrimary5Y>(),                       //
        make_unique<ReadColorControlPrimary5Intensity>(),                 //
        make_unique<ReportColorControlPrimary5Intensity>(),               //
        make_unique<ReadColorControlPrimary6X>(),                         //
        make_unique<ReportColorControlPrimary6X>(),                       //
        make_unique<ReadColorControlPrimary6Y>(),                         //
        make_unique<ReportColorControlPrimary6Y>(),                       //
        make_unique<ReadColorControlPrimary6Intensity>(),                 //
        make_unique<ReportColorControlPrimary6Intensity>(),               //
        make_unique<ReadColorControlWhitePointX>(),                       //
        make_unique<WriteColorControlWhitePointX>(),                      //
        make_unique<ReportColorControlWhitePointX>(),                     //
        make_unique<ReadColorControlWhitePointY>(),                       //
        make_unique<WriteColorControlWhitePointY>(),                      //
        make_unique<ReportColorControlWhitePointY>(),                     //
        make_unique<ReadColorControlColorPointRX>(),                      //
        make_unique<WriteColorControlColorPointRX>(),                     //
        make_unique<ReportColorControlColorPointRX>(),                    //
        make_unique<ReadColorControlColorPointRY>(),                      //
        make_unique<WriteColorControlColorPointRY>(),                     //
        make_unique<ReportColorControlColorPointRY>(),                    //
        make_unique<ReadColorControlColorPointRIntensity>(),              //
        make_unique<WriteColorControlColorPointRIntensity>(),             //
        make_unique<ReportColorControlColorPointRIntensity>(),            //
        make_unique<ReadColorControlColorPointGX>(),                      //
        make_unique<WriteColorControlColorPointGX>(),                     //
        make_unique<ReportColorControlColorPointGX>(),                    //
        make_unique<ReadColorControlColorPointGY>(),                      //
        make_unique<WriteColorControlColorPointGY>(),                     //
        make_unique<ReportColorControlColorPointGY>(),                    //
        make_unique<ReadColorControlColorPointGIntensity>(),              //
        make_unique<WriteColorControlColorPointGIntensity>(),             //
        make_unique<ReportColorControlColorPointGIntensity>(),            //
        make_unique<ReadColorControlColorPointBX>(),                      //
        make_unique<WriteColorControlColorPointBX>(),                     //
        make_unique<ReportColorControlColorPointBX>(),                    //
        make_unique<ReadColorControlColorPointBY>(),                      //
        make_unique<WriteColorControlColorPointBY>(),                     //
        make_unique<ReportColorControlColorPointBY>(),                    //
        make_unique<ReadColorControlColorPointBIntensity>(),              //
        make_unique<WriteColorControlColorPointBIntensity>(),             //
        make_unique<ReportColorControlColorPointBIntensity>(),            //
        make_unique<ReadColorControlEnhancedCurrentHue>(),                //
        make_unique<ReportColorControlEnhancedCurrentHue>(),              //
        make_unique<ReadColorControlEnhancedColorMode>(),                 //
        make_unique<ReportColorControlEnhancedColorMode>(),               //
        make_unique<ReadColorControlColorLoopActive>(),                   //
        make_unique<ReportColorControlColorLoopActive>(),                 //
        make_unique<ReadColorControlColorLoopDirection>(),                //
        make_unique<ReportColorControlColorLoopDirection>(),              //
        make_unique<ReadColorControlColorLoopTime>(),                     //
        make_unique<ReportColorControlColorLoopTime>(),                   //
        make_unique<ReadColorControlColorLoopStartEnhancedHue>(),         //
        make_unique<ReportColorControlColorLoopStartEnhancedHue>(),       //
        make_unique<ReadColorControlColorLoopStoredEnhancedHue>(),        //
        make_unique<ReportColorControlColorLoopStoredEnhancedHue>(),      //
        make_unique<ReadColorControlColorCapabilities>(),                 //
        make_unique<ReportColorControlColorCapabilities>(),               //
        make_unique<ReadColorControlColorTempPhysicalMin>(),              //
        make_unique<ReportColorControlColorTempPhysicalMin>(),            //
        make_unique<ReadColorControlColorTempPhysicalMax>(),              //
        make_unique<ReportColorControlColorTempPhysicalMax>(),            //
        make_unique<ReadColorControlCoupleColorTempToLevelMinMireds>(),   //
        make_unique<ReportColorControlCoupleColorTempToLevelMinMireds>(), //
        make_unique<ReadColorControlStartUpColorTemperatureMireds>(),     //
        make_unique<WriteColorControlStartUpColorTemperatureMireds>(),    //
        make_unique<ReportColorControlStartUpColorTemperatureMireds>(),   //
        make_unique<ReadColorControlClusterRevision>(),                   //
        make_unique<ReportColorControlClusterRevision>(),                 //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterContentLauncher(Commands & commands)
{
    const char * clusterName = "ContentLauncher";

    commands_list clusterCommands = {
        make_unique<ContentLauncherLaunchContent>(),               //
        make_unique<ContentLauncherLaunchURL>(),                   //
        make_unique<ReadContentLauncherAcceptsHeaderList>(),       //
        make_unique<ReadContentLauncherSupportedStreamingTypes>(), //
        make_unique<ReadContentLauncherClusterRevision>(),         //
        make_unique<ReportContentLauncherClusterRevision>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDescriptor(Commands & commands)
{
    const char * clusterName = "Descriptor";

    commands_list clusterCommands = {
        make_unique<ReadDescriptorDeviceList>(),        //
        make_unique<ReadDescriptorServerList>(),        //
        make_unique<ReadDescriptorClientList>(),        //
        make_unique<ReadDescriptorPartsList>(),         //
        make_unique<ReadDescriptorClusterRevision>(),   //
        make_unique<ReportDescriptorClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDiagnosticLogs(Commands & commands)
{
    const char * clusterName = "DiagnosticLogs";

    commands_list clusterCommands = {
        make_unique<DiagnosticLogsRetrieveLogsRequest>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDoorLock(Commands & commands)
{
    const char * clusterName = "DoorLock";

    commands_list clusterCommands = {
        make_unique<DoorLockClearAllPins>(),          //
        make_unique<DoorLockClearAllRfids>(),         //
        make_unique<DoorLockClearHolidaySchedule>(),  //
        make_unique<DoorLockClearPin>(),              //
        make_unique<DoorLockClearRfid>(),             //
        make_unique<DoorLockClearWeekdaySchedule>(),  //
        make_unique<DoorLockClearYeardaySchedule>(),  //
        make_unique<DoorLockGetHolidaySchedule>(),    //
        make_unique<DoorLockGetLogRecord>(),          //
        make_unique<DoorLockGetPin>(),                //
        make_unique<DoorLockGetRfid>(),               //
        make_unique<DoorLockGetUserType>(),           //
        make_unique<DoorLockGetWeekdaySchedule>(),    //
        make_unique<DoorLockGetYeardaySchedule>(),    //
        make_unique<DoorLockLockDoor>(),              //
        make_unique<DoorLockSetHolidaySchedule>(),    //
        make_unique<DoorLockSetPin>(),                //
        make_unique<DoorLockSetRfid>(),               //
        make_unique<DoorLockSetUserType>(),           //
        make_unique<DoorLockSetWeekdaySchedule>(),    //
        make_unique<DoorLockSetYeardaySchedule>(),    //
        make_unique<DoorLockUnlockDoor>(),            //
        make_unique<DoorLockUnlockWithTimeout>(),     //
        make_unique<ReadDoorLockLockState>(),         //
        make_unique<ReportDoorLockLockState>(),       //
        make_unique<ReadDoorLockLockType>(),          //
        make_unique<ReportDoorLockLockType>(),        //
        make_unique<ReadDoorLockActuatorEnabled>(),   //
        make_unique<ReportDoorLockActuatorEnabled>(), //
        make_unique<ReadDoorLockClusterRevision>(),   //
        make_unique<ReportDoorLockClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterElectricalMeasurement(Commands & commands)
{
    const char * clusterName = "ElectricalMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadElectricalMeasurementMeasurementType>(),    //
        make_unique<ReportElectricalMeasurementMeasurementType>(),  //
        make_unique<ReadElectricalMeasurementTotalActivePower>(),   //
        make_unique<ReportElectricalMeasurementTotalActivePower>(), //
        make_unique<ReadElectricalMeasurementRmsVoltage>(),         //
        make_unique<ReportElectricalMeasurementRmsVoltage>(),       //
        make_unique<ReadElectricalMeasurementRmsVoltageMin>(),      //
        make_unique<ReportElectricalMeasurementRmsVoltageMin>(),    //
        make_unique<ReadElectricalMeasurementRmsVoltageMax>(),      //
        make_unique<ReportElectricalMeasurementRmsVoltageMax>(),    //
        make_unique<ReadElectricalMeasurementRmsCurrent>(),         //
        make_unique<ReportElectricalMeasurementRmsCurrent>(),       //
        make_unique<ReadElectricalMeasurementRmsCurrentMin>(),      //
        make_unique<ReportElectricalMeasurementRmsCurrentMin>(),    //
        make_unique<ReadElectricalMeasurementRmsCurrentMax>(),      //
        make_unique<ReportElectricalMeasurementRmsCurrentMax>(),    //
        make_unique<ReadElectricalMeasurementActivePower>(),        //
        make_unique<ReportElectricalMeasurementActivePower>(),      //
        make_unique<ReadElectricalMeasurementActivePowerMin>(),     //
        make_unique<ReportElectricalMeasurementActivePowerMin>(),   //
        make_unique<ReadElectricalMeasurementActivePowerMax>(),     //
        make_unique<ReportElectricalMeasurementActivePowerMax>(),   //
        make_unique<ReadElectricalMeasurementClusterRevision>(),    //
        make_unique<ReportElectricalMeasurementClusterRevision>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterEthernetNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "EthernetNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<EthernetNetworkDiagnosticsResetCounts>(),           //
        make_unique<ReadEthernetNetworkDiagnosticsPHYRate>(),           //
        make_unique<ReportEthernetNetworkDiagnosticsPHYRate>(),         //
        make_unique<ReadEthernetNetworkDiagnosticsFullDuplex>(),        //
        make_unique<ReportEthernetNetworkDiagnosticsFullDuplex>(),      //
        make_unique<ReadEthernetNetworkDiagnosticsPacketRxCount>(),     //
        make_unique<ReportEthernetNetworkDiagnosticsPacketRxCount>(),   //
        make_unique<ReadEthernetNetworkDiagnosticsPacketTxCount>(),     //
        make_unique<ReportEthernetNetworkDiagnosticsPacketTxCount>(),   //
        make_unique<ReadEthernetNetworkDiagnosticsTxErrCount>(),        //
        make_unique<ReportEthernetNetworkDiagnosticsTxErrCount>(),      //
        make_unique<ReadEthernetNetworkDiagnosticsCollisionCount>(),    //
        make_unique<ReportEthernetNetworkDiagnosticsCollisionCount>(),  //
        make_unique<ReadEthernetNetworkDiagnosticsOverrunCount>(),      //
        make_unique<ReportEthernetNetworkDiagnosticsOverrunCount>(),    //
        make_unique<ReadEthernetNetworkDiagnosticsCarrierDetect>(),     //
        make_unique<ReportEthernetNetworkDiagnosticsCarrierDetect>(),   //
        make_unique<ReadEthernetNetworkDiagnosticsTimeSinceReset>(),    //
        make_unique<ReportEthernetNetworkDiagnosticsTimeSinceReset>(),  //
        make_unique<ReadEthernetNetworkDiagnosticsClusterRevision>(),   //
        make_unique<ReportEthernetNetworkDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFixedLabel(Commands & commands)
{
    const char * clusterName = "FixedLabel";

    commands_list clusterCommands = {
        make_unique<ReadFixedLabelLabelList>(),         //
        make_unique<ReadFixedLabelClusterRevision>(),   //
        make_unique<ReportFixedLabelClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFlowMeasurement(Commands & commands)
{
    const char * clusterName = "FlowMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadFlowMeasurementMeasuredValue>(),      //
        make_unique<ReportFlowMeasurementMeasuredValue>(),    //
        make_unique<ReadFlowMeasurementMinMeasuredValue>(),   //
        make_unique<ReportFlowMeasurementMinMeasuredValue>(), //
        make_unique<ReadFlowMeasurementMaxMeasuredValue>(),   //
        make_unique<ReportFlowMeasurementMaxMeasuredValue>(), //
        make_unique<ReadFlowMeasurementTolerance>(),          //
        make_unique<ReportFlowMeasurementTolerance>(),        //
        make_unique<ReadFlowMeasurementClusterRevision>(),    //
        make_unique<ReportFlowMeasurementClusterRevision>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGeneralCommissioning(Commands & commands)
{
    const char * clusterName = "GeneralCommissioning";

    commands_list clusterCommands = {
        make_unique<GeneralCommissioningArmFailSafe>(),                    //
        make_unique<GeneralCommissioningCommissioningComplete>(),          //
        make_unique<GeneralCommissioningSetRegulatoryConfig>(),            //
        make_unique<ReadGeneralCommissioningBreadcrumb>(),                 //
        make_unique<WriteGeneralCommissioningBreadcrumb>(),                //
        make_unique<ReportGeneralCommissioningBreadcrumb>(),               //
        make_unique<ReadGeneralCommissioningBasicCommissioningInfoList>(), //
        make_unique<ReadGeneralCommissioningClusterRevision>(),            //
        make_unique<ReportGeneralCommissioningClusterRevision>(),          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGeneralDiagnostics(Commands & commands)
{
    const char * clusterName = "GeneralDiagnostics";

    commands_list clusterCommands = {
        make_unique<ReadGeneralDiagnosticsNetworkInterfaces>(),       //
        make_unique<ReadGeneralDiagnosticsRebootCount>(),             //
        make_unique<ReportGeneralDiagnosticsRebootCount>(),           //
        make_unique<ReadGeneralDiagnosticsUpTime>(),                  //
        make_unique<ReportGeneralDiagnosticsUpTime>(),                //
        make_unique<ReadGeneralDiagnosticsTotalOperationalHours>(),   //
        make_unique<ReportGeneralDiagnosticsTotalOperationalHours>(), //
        make_unique<ReadGeneralDiagnosticsBootReasons>(),             //
        make_unique<ReportGeneralDiagnosticsBootReasons>(),           //
        make_unique<ReadGeneralDiagnosticsActiveHardwareFaults>(),    //
        make_unique<ReadGeneralDiagnosticsActiveRadioFaults>(),       //
        make_unique<ReadGeneralDiagnosticsActiveNetworkFaults>(),     //
        make_unique<ReadGeneralDiagnosticsClusterRevision>(),         //
        make_unique<ReportGeneralDiagnosticsClusterRevision>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGroupKeyManagement(Commands & commands)
{
    const char * clusterName = "GroupKeyManagement";

    commands_list clusterCommands = {
        make_unique<ReadGroupKeyManagementGroups>(),            //
        make_unique<ReadGroupKeyManagementGroupKeys>(),         //
        make_unique<ReadGroupKeyManagementClusterRevision>(),   //
        make_unique<ReportGroupKeyManagementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGroups(Commands & commands)
{
    const char * clusterName = "Groups";

    commands_list clusterCommands = {
        make_unique<GroupsAddGroup>(),              //
        make_unique<GroupsAddGroupIfIdentifying>(), //
        make_unique<GroupsGetGroupMembership>(),    //
        make_unique<GroupsRemoveAllGroups>(),       //
        make_unique<GroupsRemoveGroup>(),           //
        make_unique<GroupsViewGroup>(),             //
        make_unique<ReadGroupsNameSupport>(),       //
        make_unique<ReportGroupsNameSupport>(),     //
        make_unique<ReadGroupsClusterRevision>(),   //
        make_unique<ReportGroupsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterIdentify(Commands & commands)
{
    const char * clusterName = "Identify";

    commands_list clusterCommands = {
        make_unique<IdentifyIdentify>(),              //
        make_unique<IdentifyIdentifyQuery>(),         //
        make_unique<IdentifyTriggerEffect>(),         //
        make_unique<ReadIdentifyIdentifyTime>(),      //
        make_unique<WriteIdentifyIdentifyTime>(),     //
        make_unique<ReportIdentifyIdentifyTime>(),    //
        make_unique<ReadIdentifyIdentifyType>(),      //
        make_unique<ReportIdentifyIdentifyType>(),    //
        make_unique<ReadIdentifyClusterRevision>(),   //
        make_unique<ReportIdentifyClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterIlluminanceMeasurement(Commands & commands)
{
    const char * clusterName = "IlluminanceMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadIlluminanceMeasurementMeasuredValue>(),      //
        make_unique<ReportIlluminanceMeasurementMeasuredValue>(),    //
        make_unique<ReadIlluminanceMeasurementMinMeasuredValue>(),   //
        make_unique<ReportIlluminanceMeasurementMinMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementMaxMeasuredValue>(),   //
        make_unique<ReportIlluminanceMeasurementMaxMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementTolerance>(),          //
        make_unique<ReportIlluminanceMeasurementTolerance>(),        //
        make_unique<ReadIlluminanceMeasurementLightSensorType>(),    //
        make_unique<ReportIlluminanceMeasurementLightSensorType>(),  //
        make_unique<ReadIlluminanceMeasurementClusterRevision>(),    //
        make_unique<ReportIlluminanceMeasurementClusterRevision>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterKeypadInput(Commands & commands)
{
    const char * clusterName = "KeypadInput";

    commands_list clusterCommands = {
        make_unique<KeypadInputSendKey>(),               //
        make_unique<ReadKeypadInputClusterRevision>(),   //
        make_unique<ReportKeypadInputClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLevelControl(Commands & commands)
{
    const char * clusterName = "LevelControl";

    commands_list clusterCommands = {
        make_unique<LevelControlMove>(),                      //
        make_unique<LevelControlMoveToLevel>(),               //
        make_unique<LevelControlMoveToLevelWithOnOff>(),      //
        make_unique<LevelControlMoveWithOnOff>(),             //
        make_unique<LevelControlStep>(),                      //
        make_unique<LevelControlStepWithOnOff>(),             //
        make_unique<LevelControlStop>(),                      //
        make_unique<LevelControlStopWithOnOff>(),             //
        make_unique<ReadLevelControlCurrentLevel>(),          //
        make_unique<ReportLevelControlCurrentLevel>(),        //
        make_unique<ReadLevelControlRemainingTime>(),         //
        make_unique<ReportLevelControlRemainingTime>(),       //
        make_unique<ReadLevelControlMinLevel>(),              //
        make_unique<ReportLevelControlMinLevel>(),            //
        make_unique<ReadLevelControlMaxLevel>(),              //
        make_unique<ReportLevelControlMaxLevel>(),            //
        make_unique<ReadLevelControlCurrentFrequency>(),      //
        make_unique<ReportLevelControlCurrentFrequency>(),    //
        make_unique<ReadLevelControlMinFrequency>(),          //
        make_unique<ReportLevelControlMinFrequency>(),        //
        make_unique<ReadLevelControlMaxFrequency>(),          //
        make_unique<ReportLevelControlMaxFrequency>(),        //
        make_unique<ReadLevelControlOptions>(),               //
        make_unique<WriteLevelControlOptions>(),              //
        make_unique<ReportLevelControlOptions>(),             //
        make_unique<ReadLevelControlOnOffTransitionTime>(),   //
        make_unique<WriteLevelControlOnOffTransitionTime>(),  //
        make_unique<ReportLevelControlOnOffTransitionTime>(), //
        make_unique<ReadLevelControlOnLevel>(),               //
        make_unique<WriteLevelControlOnLevel>(),              //
        make_unique<ReportLevelControlOnLevel>(),             //
        make_unique<ReadLevelControlOnTransitionTime>(),      //
        make_unique<WriteLevelControlOnTransitionTime>(),     //
        make_unique<ReportLevelControlOnTransitionTime>(),    //
        make_unique<ReadLevelControlOffTransitionTime>(),     //
        make_unique<WriteLevelControlOffTransitionTime>(),    //
        make_unique<ReportLevelControlOffTransitionTime>(),   //
        make_unique<ReadLevelControlDefaultMoveRate>(),       //
        make_unique<WriteLevelControlDefaultMoveRate>(),      //
        make_unique<ReportLevelControlDefaultMoveRate>(),     //
        make_unique<ReadLevelControlStartUpCurrentLevel>(),   //
        make_unique<WriteLevelControlStartUpCurrentLevel>(),  //
        make_unique<ReportLevelControlStartUpCurrentLevel>(), //
        make_unique<ReadLevelControlClusterRevision>(),       //
        make_unique<ReportLevelControlClusterRevision>(),     //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLowPower(Commands & commands)
{
    const char * clusterName = "LowPower";

    commands_list clusterCommands = {
        make_unique<LowPowerSleep>(),                 //
        make_unique<ReadLowPowerClusterRevision>(),   //
        make_unique<ReportLowPowerClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterMediaInput(Commands & commands)
{
    const char * clusterName = "MediaInput";

    commands_list clusterCommands = {
        make_unique<MediaInputHideInputStatus>(),         //
        make_unique<MediaInputRenameInput>(),             //
        make_unique<MediaInputSelectInput>(),             //
        make_unique<MediaInputShowInputStatus>(),         //
        make_unique<ReadMediaInputMediaInputList>(),      //
        make_unique<ReadMediaInputCurrentMediaInput>(),   //
        make_unique<ReportMediaInputCurrentMediaInput>(), //
        make_unique<ReadMediaInputClusterRevision>(),     //
        make_unique<ReportMediaInputClusterRevision>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterMediaPlayback(Commands & commands)
{
    const char * clusterName = "MediaPlayback";

    commands_list clusterCommands = {
        make_unique<MediaPlaybackMediaFastForward>(),        //
        make_unique<MediaPlaybackMediaNext>(),               //
        make_unique<MediaPlaybackMediaPause>(),              //
        make_unique<MediaPlaybackMediaPlay>(),               //
        make_unique<MediaPlaybackMediaPrevious>(),           //
        make_unique<MediaPlaybackMediaRewind>(),             //
        make_unique<MediaPlaybackMediaSeek>(),               //
        make_unique<MediaPlaybackMediaSkipBackward>(),       //
        make_unique<MediaPlaybackMediaSkipForward>(),        //
        make_unique<MediaPlaybackMediaStartOver>(),          //
        make_unique<MediaPlaybackMediaStop>(),               //
        make_unique<ReadMediaPlaybackPlaybackState>(),       //
        make_unique<ReportMediaPlaybackPlaybackState>(),     //
        make_unique<ReadMediaPlaybackStartTime>(),           //
        make_unique<ReportMediaPlaybackStartTime>(),         //
        make_unique<ReadMediaPlaybackDuration>(),            //
        make_unique<ReportMediaPlaybackDuration>(),          //
        make_unique<ReadMediaPlaybackPositionUpdatedAt>(),   //
        make_unique<ReportMediaPlaybackPositionUpdatedAt>(), //
        make_unique<ReadMediaPlaybackPosition>(),            //
        make_unique<ReportMediaPlaybackPosition>(),          //
        make_unique<ReadMediaPlaybackPlaybackSpeed>(),       //
        make_unique<ReportMediaPlaybackPlaybackSpeed>(),     //
        make_unique<ReadMediaPlaybackSeekRangeEnd>(),        //
        make_unique<ReportMediaPlaybackSeekRangeEnd>(),      //
        make_unique<ReadMediaPlaybackSeekRangeStart>(),      //
        make_unique<ReportMediaPlaybackSeekRangeStart>(),    //
        make_unique<ReadMediaPlaybackClusterRevision>(),     //
        make_unique<ReportMediaPlaybackClusterRevision>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterModeSelect(Commands & commands)
{
    const char * clusterName = "ModeSelect";

    commands_list clusterCommands = {
        make_unique<ModeSelectChangeToMode>(),          //
        make_unique<ReadModeSelectCurrentMode>(),       //
        make_unique<ReportModeSelectCurrentMode>(),     //
        make_unique<ReadModeSelectSupportedModes>(),    //
        make_unique<ReadModeSelectOnMode>(),            //
        make_unique<WriteModeSelectOnMode>(),           //
        make_unique<ReportModeSelectOnMode>(),          //
        make_unique<ReadModeSelectStartUpMode>(),       //
        make_unique<ReportModeSelectStartUpMode>(),     //
        make_unique<ReadModeSelectDescription>(),       //
        make_unique<ReportModeSelectDescription>(),     //
        make_unique<ReadModeSelectClusterRevision>(),   //
        make_unique<ReportModeSelectClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterNetworkCommissioning(Commands & commands)
{
    const char * clusterName = "NetworkCommissioning";

    commands_list clusterCommands = {
        make_unique<NetworkCommissioningAddThreadNetwork>(),      //
        make_unique<NetworkCommissioningAddWiFiNetwork>(),        //
        make_unique<NetworkCommissioningDisableNetwork>(),        //
        make_unique<NetworkCommissioningEnableNetwork>(),         //
        make_unique<NetworkCommissioningRemoveNetwork>(),         //
        make_unique<NetworkCommissioningScanNetworks>(),          //
        make_unique<NetworkCommissioningUpdateThreadNetwork>(),   //
        make_unique<NetworkCommissioningUpdateWiFiNetwork>(),     //
        make_unique<ReadNetworkCommissioningFeatureMap>(),        //
        make_unique<ReportNetworkCommissioningFeatureMap>(),      //
        make_unique<ReadNetworkCommissioningClusterRevision>(),   //
        make_unique<ReportNetworkCommissioningClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOtaSoftwareUpdateProvider(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateProvider";

    commands_list clusterCommands = {
        make_unique<OtaSoftwareUpdateProviderApplyUpdateRequest>(),    //
        make_unique<OtaSoftwareUpdateProviderNotifyUpdateApplied>(),   //
        make_unique<OtaSoftwareUpdateProviderQueryImage>(),            //
        make_unique<ReadOtaSoftwareUpdateProviderClusterRevision>(),   //
        make_unique<ReportOtaSoftwareUpdateProviderClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOtaSoftwareUpdateRequestor(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateRequestor";

    commands_list clusterCommands = {
        make_unique<OtaSoftwareUpdateRequestorAnnounceOtaProvider>(),      //
        make_unique<ReadOtaSoftwareUpdateRequestorDefaultOtaProvider>(),   //
        make_unique<WriteOtaSoftwareUpdateRequestorDefaultOtaProvider>(),  //
        make_unique<ReportOtaSoftwareUpdateRequestorDefaultOtaProvider>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdatePossible>(),       //
        make_unique<ReportOtaSoftwareUpdateRequestorUpdatePossible>(),     //
        make_unique<ReadOtaSoftwareUpdateRequestorClusterRevision>(),      //
        make_unique<ReportOtaSoftwareUpdateRequestorClusterRevision>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOccupancySensing(Commands & commands)
{
    const char * clusterName = "OccupancySensing";

    commands_list clusterCommands = {
        make_unique<ReadOccupancySensingOccupancy>(),                   //
        make_unique<ReportOccupancySensingOccupancy>(),                 //
        make_unique<ReadOccupancySensingOccupancySensorType>(),         //
        make_unique<ReportOccupancySensingOccupancySensorType>(),       //
        make_unique<ReadOccupancySensingOccupancySensorTypeBitmap>(),   //
        make_unique<ReportOccupancySensingOccupancySensorTypeBitmap>(), //
        make_unique<ReadOccupancySensingClusterRevision>(),             //
        make_unique<ReportOccupancySensingClusterRevision>(),           //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOnOff(Commands & commands)
{
    const char * clusterName = "OnOff";

    commands_list clusterCommands = {
        make_unique<OnOffOff>(),                      //
        make_unique<OnOffOffWithEffect>(),            //
        make_unique<OnOffOn>(),                       //
        make_unique<OnOffOnWithRecallGlobalScene>(),  //
        make_unique<OnOffOnWithTimedOff>(),           //
        make_unique<OnOffToggle>(),                   //
        make_unique<ReadOnOffOnOff>(),                //
        make_unique<ReportOnOffOnOff>(),              //
        make_unique<ReadOnOffGlobalSceneControl>(),   //
        make_unique<ReportOnOffGlobalSceneControl>(), //
        make_unique<ReadOnOffOnTime>(),               //
        make_unique<WriteOnOffOnTime>(),              //
        make_unique<ReportOnOffOnTime>(),             //
        make_unique<ReadOnOffOffWaitTime>(),          //
        make_unique<WriteOnOffOffWaitTime>(),         //
        make_unique<ReportOnOffOffWaitTime>(),        //
        make_unique<ReadOnOffStartUpOnOff>(),         //
        make_unique<WriteOnOffStartUpOnOff>(),        //
        make_unique<ReportOnOffStartUpOnOff>(),       //
        make_unique<ReadOnOffFeatureMap>(),           //
        make_unique<ReportOnOffFeatureMap>(),         //
        make_unique<ReadOnOffClusterRevision>(),      //
        make_unique<ReportOnOffClusterRevision>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOnOffSwitchConfiguration(Commands & commands)
{
    const char * clusterName = "OnOffSwitchConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadOnOffSwitchConfigurationSwitchType>(),        //
        make_unique<ReportOnOffSwitchConfigurationSwitchType>(),      //
        make_unique<ReadOnOffSwitchConfigurationSwitchActions>(),     //
        make_unique<WriteOnOffSwitchConfigurationSwitchActions>(),    //
        make_unique<ReportOnOffSwitchConfigurationSwitchActions>(),   //
        make_unique<ReadOnOffSwitchConfigurationClusterRevision>(),   //
        make_unique<ReportOnOffSwitchConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOperationalCredentials(Commands & commands)
{
    const char * clusterName = "OperationalCredentials";

    commands_list clusterCommands = {
        make_unique<OperationalCredentialsAddNOC>(),                       //
        make_unique<OperationalCredentialsAddTrustedRootCertificate>(),    //
        make_unique<OperationalCredentialsAttestationRequest>(),           //
        make_unique<OperationalCredentialsCertificateChainRequest>(),      //
        make_unique<OperationalCredentialsOpCSRRequest>(),                 //
        make_unique<OperationalCredentialsRemoveFabric>(),                 //
        make_unique<OperationalCredentialsRemoveTrustedRootCertificate>(), //
        make_unique<OperationalCredentialsUpdateFabricLabel>(),            //
        make_unique<OperationalCredentialsUpdateNOC>(),                    //
        make_unique<ReadOperationalCredentialsFabricsList>(),              //
        make_unique<ReadOperationalCredentialsSupportedFabrics>(),         //
        make_unique<ReportOperationalCredentialsSupportedFabrics>(),       //
        make_unique<ReadOperationalCredentialsCommissionedFabrics>(),      //
        make_unique<ReportOperationalCredentialsCommissionedFabrics>(),    //
        make_unique<ReadOperationalCredentialsTrustedRootCertificates>(),  //
        make_unique<ReadOperationalCredentialsCurrentFabricIndex>(),       //
        make_unique<ReportOperationalCredentialsCurrentFabricIndex>(),     //
        make_unique<ReadOperationalCredentialsClusterRevision>(),          //
        make_unique<ReportOperationalCredentialsClusterRevision>(),        //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPowerSource(Commands & commands)
{
    const char * clusterName = "PowerSource";

    commands_list clusterCommands = {
        make_unique<ReadPowerSourceStatus>(),                    //
        make_unique<ReportPowerSourceStatus>(),                  //
        make_unique<ReadPowerSourceOrder>(),                     //
        make_unique<ReportPowerSourceOrder>(),                   //
        make_unique<ReadPowerSourceDescription>(),               //
        make_unique<ReportPowerSourceDescription>(),             //
        make_unique<ReadPowerSourceBatteryVoltage>(),            //
        make_unique<ReportPowerSourceBatteryVoltage>(),          //
        make_unique<ReadPowerSourceBatteryPercentRemaining>(),   //
        make_unique<ReportPowerSourceBatteryPercentRemaining>(), //
        make_unique<ReadPowerSourceBatteryTimeRemaining>(),      //
        make_unique<ReportPowerSourceBatteryTimeRemaining>(),    //
        make_unique<ReadPowerSourceBatteryChargeLevel>(),        //
        make_unique<ReportPowerSourceBatteryChargeLevel>(),      //
        make_unique<ReadPowerSourceActiveBatteryFaults>(),       //
        make_unique<ReadPowerSourceBatteryChargeState>(),        //
        make_unique<ReportPowerSourceBatteryChargeState>(),      //
        make_unique<ReadPowerSourceFeatureMap>(),                //
        make_unique<ReportPowerSourceFeatureMap>(),              //
        make_unique<ReadPowerSourceClusterRevision>(),           //
        make_unique<ReportPowerSourceClusterRevision>(),         //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPressureMeasurement(Commands & commands)
{
    const char * clusterName = "PressureMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadPressureMeasurementMeasuredValue>(),      //
        make_unique<ReportPressureMeasurementMeasuredValue>(),    //
        make_unique<ReadPressureMeasurementMinMeasuredValue>(),   //
        make_unique<ReportPressureMeasurementMinMeasuredValue>(), //
        make_unique<ReadPressureMeasurementMaxMeasuredValue>(),   //
        make_unique<ReportPressureMeasurementMaxMeasuredValue>(), //
        make_unique<ReadPressureMeasurementClusterRevision>(),    //
        make_unique<ReportPressureMeasurementClusterRevision>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPumpConfigurationAndControl(Commands & commands)
{
    const char * clusterName = "PumpConfigurationAndControl";

    commands_list clusterCommands = {
        make_unique<ReadPumpConfigurationAndControlMaxPressure>(),              //
        make_unique<ReportPumpConfigurationAndControlMaxPressure>(),            //
        make_unique<ReadPumpConfigurationAndControlMaxSpeed>(),                 //
        make_unique<ReportPumpConfigurationAndControlMaxSpeed>(),               //
        make_unique<ReadPumpConfigurationAndControlMaxFlow>(),                  //
        make_unique<ReportPumpConfigurationAndControlMaxFlow>(),                //
        make_unique<ReadPumpConfigurationAndControlMinConstPressure>(),         //
        make_unique<ReportPumpConfigurationAndControlMinConstPressure>(),       //
        make_unique<ReadPumpConfigurationAndControlMaxConstPressure>(),         //
        make_unique<ReportPumpConfigurationAndControlMaxConstPressure>(),       //
        make_unique<ReadPumpConfigurationAndControlMinCompPressure>(),          //
        make_unique<ReportPumpConfigurationAndControlMinCompPressure>(),        //
        make_unique<ReadPumpConfigurationAndControlMaxCompPressure>(),          //
        make_unique<ReportPumpConfigurationAndControlMaxCompPressure>(),        //
        make_unique<ReadPumpConfigurationAndControlMinConstSpeed>(),            //
        make_unique<ReportPumpConfigurationAndControlMinConstSpeed>(),          //
        make_unique<ReadPumpConfigurationAndControlMaxConstSpeed>(),            //
        make_unique<ReportPumpConfigurationAndControlMaxConstSpeed>(),          //
        make_unique<ReadPumpConfigurationAndControlMinConstFlow>(),             //
        make_unique<ReportPumpConfigurationAndControlMinConstFlow>(),           //
        make_unique<ReadPumpConfigurationAndControlMaxConstFlow>(),             //
        make_unique<ReportPumpConfigurationAndControlMaxConstFlow>(),           //
        make_unique<ReadPumpConfigurationAndControlMinConstTemp>(),             //
        make_unique<ReportPumpConfigurationAndControlMinConstTemp>(),           //
        make_unique<ReadPumpConfigurationAndControlMaxConstTemp>(),             //
        make_unique<ReportPumpConfigurationAndControlMaxConstTemp>(),           //
        make_unique<ReadPumpConfigurationAndControlPumpStatus>(),               //
        make_unique<ReportPumpConfigurationAndControlPumpStatus>(),             //
        make_unique<ReadPumpConfigurationAndControlEffectiveOperationMode>(),   //
        make_unique<ReportPumpConfigurationAndControlEffectiveOperationMode>(), //
        make_unique<ReadPumpConfigurationAndControlEffectiveControlMode>(),     //
        make_unique<ReportPumpConfigurationAndControlEffectiveControlMode>(),   //
        make_unique<ReadPumpConfigurationAndControlCapacity>(),                 //
        make_unique<ReportPumpConfigurationAndControlCapacity>(),               //
        make_unique<ReadPumpConfigurationAndControlSpeed>(),                    //
        make_unique<ReportPumpConfigurationAndControlSpeed>(),                  //
        make_unique<ReadPumpConfigurationAndControlLifetimeEnergyConsumed>(),   //
        make_unique<ReportPumpConfigurationAndControlLifetimeEnergyConsumed>(), //
        make_unique<ReadPumpConfigurationAndControlOperationMode>(),            //
        make_unique<WritePumpConfigurationAndControlOperationMode>(),           //
        make_unique<ReportPumpConfigurationAndControlOperationMode>(),          //
        make_unique<ReadPumpConfigurationAndControlControlMode>(),              //
        make_unique<WritePumpConfigurationAndControlControlMode>(),             //
        make_unique<ReportPumpConfigurationAndControlControlMode>(),            //
        make_unique<ReadPumpConfigurationAndControlAlarmMask>(),                //
        make_unique<ReportPumpConfigurationAndControlAlarmMask>(),              //
        make_unique<ReadPumpConfigurationAndControlFeatureMap>(),               //
        make_unique<ReportPumpConfigurationAndControlFeatureMap>(),             //
        make_unique<ReadPumpConfigurationAndControlClusterRevision>(),          //
        make_unique<ReportPumpConfigurationAndControlClusterRevision>(),        //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterRelativeHumidityMeasurement(Commands & commands)
{
    const char * clusterName = "RelativeHumidityMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadRelativeHumidityMeasurementMeasuredValue>(),      //
        make_unique<ReportRelativeHumidityMeasurementMeasuredValue>(),    //
        make_unique<ReadRelativeHumidityMeasurementMinMeasuredValue>(),   //
        make_unique<ReportRelativeHumidityMeasurementMinMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementMaxMeasuredValue>(),   //
        make_unique<ReportRelativeHumidityMeasurementMaxMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementTolerance>(),          //
        make_unique<ReportRelativeHumidityMeasurementTolerance>(),        //
        make_unique<ReadRelativeHumidityMeasurementClusterRevision>(),    //
        make_unique<ReportRelativeHumidityMeasurementClusterRevision>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterScenes(Commands & commands)
{
    const char * clusterName = "Scenes";

    commands_list clusterCommands = {
        make_unique<ScenesAddScene>(),              //
        make_unique<ScenesGetSceneMembership>(),    //
        make_unique<ScenesRecallScene>(),           //
        make_unique<ScenesRemoveAllScenes>(),       //
        make_unique<ScenesRemoveScene>(),           //
        make_unique<ScenesStoreScene>(),            //
        make_unique<ScenesViewScene>(),             //
        make_unique<ReadScenesSceneCount>(),        //
        make_unique<ReportScenesSceneCount>(),      //
        make_unique<ReadScenesCurrentScene>(),      //
        make_unique<ReportScenesCurrentScene>(),    //
        make_unique<ReadScenesCurrentGroup>(),      //
        make_unique<ReportScenesCurrentGroup>(),    //
        make_unique<ReadScenesSceneValid>(),        //
        make_unique<ReportScenesSceneValid>(),      //
        make_unique<ReadScenesNameSupport>(),       //
        make_unique<ReportScenesNameSupport>(),     //
        make_unique<ReadScenesClusterRevision>(),   //
        make_unique<ReportScenesClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterSoftwareDiagnostics(Commands & commands)
{
    const char * clusterName = "SoftwareDiagnostics";

    commands_list clusterCommands = {
        make_unique<SoftwareDiagnosticsResetWatermarks>(),                //
        make_unique<ReadSoftwareDiagnosticsThreadMetrics>(),              //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapFree>(),            //
        make_unique<ReportSoftwareDiagnosticsCurrentHeapFree>(),          //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapUsed>(),            //
        make_unique<ReportSoftwareDiagnosticsCurrentHeapUsed>(),          //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapHighWatermark>(),   //
        make_unique<ReportSoftwareDiagnosticsCurrentHeapHighWatermark>(), //
        make_unique<ReadSoftwareDiagnosticsClusterRevision>(),            //
        make_unique<ReportSoftwareDiagnosticsClusterRevision>(),          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterSwitch(Commands & commands)
{
    const char * clusterName = "Switch";

    commands_list clusterCommands = {
        make_unique<ReadSwitchNumberOfPositions>(),   //
        make_unique<ReportSwitchNumberOfPositions>(), //
        make_unique<ReadSwitchCurrentPosition>(),     //
        make_unique<ReportSwitchCurrentPosition>(),   //
        make_unique<ReadSwitchMultiPressMax>(),       //
        make_unique<ReportSwitchMultiPressMax>(),     //
        make_unique<ReadSwitchFeatureMap>(),          //
        make_unique<ReportSwitchFeatureMap>(),        //
        make_unique<ReadSwitchClusterRevision>(),     //
        make_unique<ReportSwitchClusterRevision>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTvChannel(Commands & commands)
{
    const char * clusterName = "TvChannel";

    commands_list clusterCommands = {
        make_unique<TvChannelChangeChannel>(),          //
        make_unique<TvChannelChangeChannelByNumber>(),  //
        make_unique<TvChannelSkipChannel>(),            //
        make_unique<ReadTvChannelTvChannelList>(),      //
        make_unique<ReadTvChannelTvChannelLineup>(),    //
        make_unique<ReportTvChannelTvChannelLineup>(),  //
        make_unique<ReadTvChannelCurrentTvChannel>(),   //
        make_unique<ReportTvChannelCurrentTvChannel>(), //
        make_unique<ReadTvChannelClusterRevision>(),    //
        make_unique<ReportTvChannelClusterRevision>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTargetNavigator(Commands & commands)
{
    const char * clusterName = "TargetNavigator";

    commands_list clusterCommands = {
        make_unique<TargetNavigatorNavigateTarget>(),          //
        make_unique<ReadTargetNavigatorTargetNavigatorList>(), //
        make_unique<ReadTargetNavigatorClusterRevision>(),     //
        make_unique<ReportTargetNavigatorClusterRevision>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTemperatureMeasurement(Commands & commands)
{
    const char * clusterName = "TemperatureMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadTemperatureMeasurementMeasuredValue>(),      //
        make_unique<ReportTemperatureMeasurementMeasuredValue>(),    //
        make_unique<ReadTemperatureMeasurementMinMeasuredValue>(),   //
        make_unique<ReportTemperatureMeasurementMinMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementMaxMeasuredValue>(),   //
        make_unique<ReportTemperatureMeasurementMaxMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementTolerance>(),          //
        make_unique<ReportTemperatureMeasurementTolerance>(),        //
        make_unique<ReadTemperatureMeasurementClusterRevision>(),    //
        make_unique<ReportTemperatureMeasurementClusterRevision>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTestCluster(Commands & commands)
{
    const char * clusterName = "TestCluster";

    commands_list clusterCommands = {
        make_unique<TestClusterTest>(),                                //
        make_unique<TestClusterTestAddArguments>(),                    //
        make_unique<TestClusterTestEnumsRequest>(),                    //
        make_unique<TestClusterTestListInt8UArgumentRequest>(),        //
        make_unique<TestClusterTestListInt8UReverseRequest>(),         //
        make_unique<TestClusterTestListStructArgumentRequest>(),       //
        make_unique<TestClusterTestNotHandled>(),                      //
        make_unique<TestClusterTestNullableOptionalRequest>(),         //
        make_unique<TestClusterTestSpecific>(),                        //
        make_unique<TestClusterTestStructArgumentRequest>(),           //
        make_unique<TestClusterTestUnknownCommand>(),                  //
        make_unique<ReadTestClusterBoolean>(),                         //
        make_unique<WriteTestClusterBoolean>(),                        //
        make_unique<ReportTestClusterBoolean>(),                       //
        make_unique<ReadTestClusterBitmap8>(),                         //
        make_unique<WriteTestClusterBitmap8>(),                        //
        make_unique<ReportTestClusterBitmap8>(),                       //
        make_unique<ReadTestClusterBitmap16>(),                        //
        make_unique<WriteTestClusterBitmap16>(),                       //
        make_unique<ReportTestClusterBitmap16>(),                      //
        make_unique<ReadTestClusterBitmap32>(),                        //
        make_unique<WriteTestClusterBitmap32>(),                       //
        make_unique<ReportTestClusterBitmap32>(),                      //
        make_unique<ReadTestClusterBitmap64>(),                        //
        make_unique<WriteTestClusterBitmap64>(),                       //
        make_unique<ReportTestClusterBitmap64>(),                      //
        make_unique<ReadTestClusterInt8u>(),                           //
        make_unique<WriteTestClusterInt8u>(),                          //
        make_unique<ReportTestClusterInt8u>(),                         //
        make_unique<ReadTestClusterInt16u>(),                          //
        make_unique<WriteTestClusterInt16u>(),                         //
        make_unique<ReportTestClusterInt16u>(),                        //
        make_unique<ReadTestClusterInt32u>(),                          //
        make_unique<WriteTestClusterInt32u>(),                         //
        make_unique<ReportTestClusterInt32u>(),                        //
        make_unique<ReadTestClusterInt64u>(),                          //
        make_unique<WriteTestClusterInt64u>(),                         //
        make_unique<ReportTestClusterInt64u>(),                        //
        make_unique<ReadTestClusterInt8s>(),                           //
        make_unique<WriteTestClusterInt8s>(),                          //
        make_unique<ReportTestClusterInt8s>(),                         //
        make_unique<ReadTestClusterInt16s>(),                          //
        make_unique<WriteTestClusterInt16s>(),                         //
        make_unique<ReportTestClusterInt16s>(),                        //
        make_unique<ReadTestClusterInt32s>(),                          //
        make_unique<WriteTestClusterInt32s>(),                         //
        make_unique<ReportTestClusterInt32s>(),                        //
        make_unique<ReadTestClusterInt64s>(),                          //
        make_unique<WriteTestClusterInt64s>(),                         //
        make_unique<ReportTestClusterInt64s>(),                        //
        make_unique<ReadTestClusterEnum8>(),                           //
        make_unique<WriteTestClusterEnum8>(),                          //
        make_unique<ReportTestClusterEnum8>(),                         //
        make_unique<ReadTestClusterEnum16>(),                          //
        make_unique<WriteTestClusterEnum16>(),                         //
        make_unique<ReportTestClusterEnum16>(),                        //
        make_unique<ReadTestClusterOctetString>(),                     //
        make_unique<WriteTestClusterOctetString>(),                    //
        make_unique<ReportTestClusterOctetString>(),                   //
        make_unique<ReadTestClusterListInt8u>(),                       //
        make_unique<ReadTestClusterListOctetString>(),                 //
        make_unique<ReadTestClusterListStructOctetString>(),           //
        make_unique<ReadTestClusterLongOctetString>(),                 //
        make_unique<WriteTestClusterLongOctetString>(),                //
        make_unique<ReportTestClusterLongOctetString>(),               //
        make_unique<ReadTestClusterCharString>(),                      //
        make_unique<WriteTestClusterCharString>(),                     //
        make_unique<ReportTestClusterCharString>(),                    //
        make_unique<ReadTestClusterLongCharString>(),                  //
        make_unique<WriteTestClusterLongCharString>(),                 //
        make_unique<ReportTestClusterLongCharString>(),                //
        make_unique<ReadTestClusterEpochUs>(),                         //
        make_unique<WriteTestClusterEpochUs>(),                        //
        make_unique<ReportTestClusterEpochUs>(),                       //
        make_unique<ReadTestClusterEpochS>(),                          //
        make_unique<WriteTestClusterEpochS>(),                         //
        make_unique<ReportTestClusterEpochS>(),                        //
        make_unique<ReadTestClusterVendorId>(),                        //
        make_unique<WriteTestClusterVendorId>(),                       //
        make_unique<ReportTestClusterVendorId>(),                      //
        make_unique<ReadTestClusterListNullablesAndOptionalsStruct>(), //
        make_unique<ReadTestClusterUnsupported>(),                     //
        make_unique<WriteTestClusterUnsupported>(),                    //
        make_unique<ReportTestClusterUnsupported>(),                   //
        make_unique<ReadTestClusterNullableBoolean>(),                 //
        make_unique<WriteTestClusterNullableBoolean>(),                //
        make_unique<ReportTestClusterNullableBoolean>(),               //
        make_unique<ReadTestClusterNullableBitmap8>(),                 //
        make_unique<WriteTestClusterNullableBitmap8>(),                //
        make_unique<ReportTestClusterNullableBitmap8>(),               //
        make_unique<ReadTestClusterNullableBitmap16>(),                //
        make_unique<WriteTestClusterNullableBitmap16>(),               //
        make_unique<ReportTestClusterNullableBitmap16>(),              //
        make_unique<ReadTestClusterNullableBitmap32>(),                //
        make_unique<WriteTestClusterNullableBitmap32>(),               //
        make_unique<ReportTestClusterNullableBitmap32>(),              //
        make_unique<ReadTestClusterNullableBitmap64>(),                //
        make_unique<WriteTestClusterNullableBitmap64>(),               //
        make_unique<ReportTestClusterNullableBitmap64>(),              //
        make_unique<ReadTestClusterNullableInt8u>(),                   //
        make_unique<WriteTestClusterNullableInt8u>(),                  //
        make_unique<ReportTestClusterNullableInt8u>(),                 //
        make_unique<ReadTestClusterNullableInt16u>(),                  //
        make_unique<WriteTestClusterNullableInt16u>(),                 //
        make_unique<ReportTestClusterNullableInt16u>(),                //
        make_unique<ReadTestClusterNullableInt32u>(),                  //
        make_unique<WriteTestClusterNullableInt32u>(),                 //
        make_unique<ReportTestClusterNullableInt32u>(),                //
        make_unique<ReadTestClusterNullableInt64u>(),                  //
        make_unique<WriteTestClusterNullableInt64u>(),                 //
        make_unique<ReportTestClusterNullableInt64u>(),                //
        make_unique<ReadTestClusterNullableInt8s>(),                   //
        make_unique<WriteTestClusterNullableInt8s>(),                  //
        make_unique<ReportTestClusterNullableInt8s>(),                 //
        make_unique<ReadTestClusterNullableInt16s>(),                  //
        make_unique<WriteTestClusterNullableInt16s>(),                 //
        make_unique<ReportTestClusterNullableInt16s>(),                //
        make_unique<ReadTestClusterNullableInt32s>(),                  //
        make_unique<WriteTestClusterNullableInt32s>(),                 //
        make_unique<ReportTestClusterNullableInt32s>(),                //
        make_unique<ReadTestClusterNullableInt64s>(),                  //
        make_unique<WriteTestClusterNullableInt64s>(),                 //
        make_unique<ReportTestClusterNullableInt64s>(),                //
        make_unique<ReadTestClusterNullableEnum8>(),                   //
        make_unique<WriteTestClusterNullableEnum8>(),                  //
        make_unique<ReportTestClusterNullableEnum8>(),                 //
        make_unique<ReadTestClusterNullableEnum16>(),                  //
        make_unique<WriteTestClusterNullableEnum16>(),                 //
        make_unique<ReportTestClusterNullableEnum16>(),                //
        make_unique<ReadTestClusterNullableOctetString>(),             //
        make_unique<WriteTestClusterNullableOctetString>(),            //
        make_unique<ReportTestClusterNullableOctetString>(),           //
        make_unique<ReadTestClusterNullableCharString>(),              //
        make_unique<WriteTestClusterNullableCharString>(),             //
        make_unique<ReportTestClusterNullableCharString>(),            //
        make_unique<ReadTestClusterClusterRevision>(),                 //
        make_unique<ReportTestClusterClusterRevision>(),               //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThermostat(Commands & commands)
{
    const char * clusterName = "Thermostat";

    commands_list clusterCommands = {
        make_unique<ThermostatClearWeeklySchedule>(),              //
        make_unique<ThermostatGetRelayStatusLog>(),                //
        make_unique<ThermostatGetWeeklySchedule>(),                //
        make_unique<ThermostatSetWeeklySchedule>(),                //
        make_unique<ThermostatSetpointRaiseLower>(),               //
        make_unique<ReadThermostatLocalTemperature>(),             //
        make_unique<ReportThermostatLocalTemperature>(),           //
        make_unique<ReadThermostatAbsMinHeatSetpointLimit>(),      //
        make_unique<ReportThermostatAbsMinHeatSetpointLimit>(),    //
        make_unique<ReadThermostatAbsMaxHeatSetpointLimit>(),      //
        make_unique<ReportThermostatAbsMaxHeatSetpointLimit>(),    //
        make_unique<ReadThermostatAbsMinCoolSetpointLimit>(),      //
        make_unique<ReportThermostatAbsMinCoolSetpointLimit>(),    //
        make_unique<ReadThermostatAbsMaxCoolSetpointLimit>(),      //
        make_unique<ReportThermostatAbsMaxCoolSetpointLimit>(),    //
        make_unique<ReadThermostatOccupiedCoolingSetpoint>(),      //
        make_unique<WriteThermostatOccupiedCoolingSetpoint>(),     //
        make_unique<ReportThermostatOccupiedCoolingSetpoint>(),    //
        make_unique<ReadThermostatOccupiedHeatingSetpoint>(),      //
        make_unique<WriteThermostatOccupiedHeatingSetpoint>(),     //
        make_unique<ReportThermostatOccupiedHeatingSetpoint>(),    //
        make_unique<ReadThermostatMinHeatSetpointLimit>(),         //
        make_unique<WriteThermostatMinHeatSetpointLimit>(),        //
        make_unique<ReportThermostatMinHeatSetpointLimit>(),       //
        make_unique<ReadThermostatMaxHeatSetpointLimit>(),         //
        make_unique<WriteThermostatMaxHeatSetpointLimit>(),        //
        make_unique<ReportThermostatMaxHeatSetpointLimit>(),       //
        make_unique<ReadThermostatMinCoolSetpointLimit>(),         //
        make_unique<WriteThermostatMinCoolSetpointLimit>(),        //
        make_unique<ReportThermostatMinCoolSetpointLimit>(),       //
        make_unique<ReadThermostatMaxCoolSetpointLimit>(),         //
        make_unique<WriteThermostatMaxCoolSetpointLimit>(),        //
        make_unique<ReportThermostatMaxCoolSetpointLimit>(),       //
        make_unique<ReadThermostatMinSetpointDeadBand>(),          //
        make_unique<WriteThermostatMinSetpointDeadBand>(),         //
        make_unique<ReportThermostatMinSetpointDeadBand>(),        //
        make_unique<ReadThermostatControlSequenceOfOperation>(),   //
        make_unique<WriteThermostatControlSequenceOfOperation>(),  //
        make_unique<ReportThermostatControlSequenceOfOperation>(), //
        make_unique<ReadThermostatSystemMode>(),                   //
        make_unique<WriteThermostatSystemMode>(),                  //
        make_unique<ReportThermostatSystemMode>(),                 //
        make_unique<ReadThermostatStartOfWeek>(),                  //
        make_unique<ReportThermostatStartOfWeek>(),                //
        make_unique<ReadThermostatNumberOfWeeklyTransitions>(),    //
        make_unique<ReportThermostatNumberOfWeeklyTransitions>(),  //
        make_unique<ReadThermostatNumberOfDailyTransitions>(),     //
        make_unique<ReportThermostatNumberOfDailyTransitions>(),   //
        make_unique<ReadThermostatFeatureMap>(),                   //
        make_unique<ReportThermostatFeatureMap>(),                 //
        make_unique<ReadThermostatClusterRevision>(),              //
        make_unique<ReportThermostatClusterRevision>(),            //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThermostatUserInterfaceConfiguration(Commands & commands)
{
    const char * clusterName = "ThermostatUserInterfaceConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode>(),          //
        make_unique<WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode>(),         //
        make_unique<ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode>(),        //
        make_unique<ReadThermostatUserInterfaceConfigurationKeypadLockout>(),                   //
        make_unique<WriteThermostatUserInterfaceConfigurationKeypadLockout>(),                  //
        make_unique<ReportThermostatUserInterfaceConfigurationKeypadLockout>(),                 //
        make_unique<ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(),   //
        make_unique<WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(),  //
        make_unique<ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationClusterRevision>(),                 //
        make_unique<ReportThermostatUserInterfaceConfigurationClusterRevision>(),               //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThreadNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "ThreadNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<ThreadNetworkDiagnosticsResetCounts>(),                             //
        make_unique<ReadThreadNetworkDiagnosticsChannel>(),                             //
        make_unique<ReportThreadNetworkDiagnosticsChannel>(),                           //
        make_unique<ReadThreadNetworkDiagnosticsRoutingRole>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsRoutingRole>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsNetworkName>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsNetworkName>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsPanId>(),                               //
        make_unique<ReportThreadNetworkDiagnosticsPanId>(),                             //
        make_unique<ReadThreadNetworkDiagnosticsExtendedPanId>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsExtendedPanId>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsMeshLocalPrefix>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsMeshLocalPrefix>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsOverrunCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsOverrunCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsNeighborTableList>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsRouteTableList>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsPartitionId>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsPartitionId>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsWeighting>(),                           //
        make_unique<ReportThreadNetworkDiagnosticsWeighting>(),                         //
        make_unique<ReadThreadNetworkDiagnosticsDataVersion>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsDataVersion>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsStableDataVersion>(),                   //
        make_unique<ReportThreadNetworkDiagnosticsStableDataVersion>(),                 //
        make_unique<ReadThreadNetworkDiagnosticsLeaderRouterId>(),                      //
        make_unique<ReportThreadNetworkDiagnosticsLeaderRouterId>(),                    //
        make_unique<ReadThreadNetworkDiagnosticsDetachedRoleCount>(),                   //
        make_unique<ReportThreadNetworkDiagnosticsDetachedRoleCount>(),                 //
        make_unique<ReadThreadNetworkDiagnosticsChildRoleCount>(),                      //
        make_unique<ReportThreadNetworkDiagnosticsChildRoleCount>(),                    //
        make_unique<ReadThreadNetworkDiagnosticsRouterRoleCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsRouterRoleCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsLeaderRoleCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsLeaderRoleCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsAttachAttemptCount>(),                  //
        make_unique<ReportThreadNetworkDiagnosticsAttachAttemptCount>(),                //
        make_unique<ReadThreadNetworkDiagnosticsPartitionIdChangeCount>(),              //
        make_unique<ReportThreadNetworkDiagnosticsPartitionIdChangeCount>(),            //
        make_unique<ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount>(),   //
        make_unique<ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsParentChangeCount>(),                   //
        make_unique<ReportThreadNetworkDiagnosticsParentChangeCount>(),                 //
        make_unique<ReadThreadNetworkDiagnosticsTxTotalCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsTxTotalCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsTxUnicastCount>(),                      //
        make_unique<ReportThreadNetworkDiagnosticsTxUnicastCount>(),                    //
        make_unique<ReadThreadNetworkDiagnosticsTxBroadcastCount>(),                    //
        make_unique<ReportThreadNetworkDiagnosticsTxBroadcastCount>(),                  //
        make_unique<ReadThreadNetworkDiagnosticsTxAckRequestedCount>(),                 //
        make_unique<ReportThreadNetworkDiagnosticsTxAckRequestedCount>(),               //
        make_unique<ReadThreadNetworkDiagnosticsTxAckedCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsTxAckedCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsTxNoAckRequestedCount>(),               //
        make_unique<ReportThreadNetworkDiagnosticsTxNoAckRequestedCount>(),             //
        make_unique<ReadThreadNetworkDiagnosticsTxDataCount>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsTxDataCount>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsTxDataPollCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsTxDataPollCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsTxBeaconCount>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsTxBeaconCount>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsTxBeaconRequestCount>(),                //
        make_unique<ReportThreadNetworkDiagnosticsTxBeaconRequestCount>(),              //
        make_unique<ReadThreadNetworkDiagnosticsTxOtherCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsTxOtherCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsTxRetryCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsTxRetryCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount>(),         //
        make_unique<ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount>(),       //
        make_unique<ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount>(),       //
        make_unique<ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount>(),     //
        make_unique<ReadThreadNetworkDiagnosticsTxErrCcaCount>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsTxErrCcaCount>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsTxErrAbortCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsTxErrAbortCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsTxErrBusyChannelCount>(),               //
        make_unique<ReportThreadNetworkDiagnosticsTxErrBusyChannelCount>(),             //
        make_unique<ReadThreadNetworkDiagnosticsRxTotalCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsRxTotalCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsRxUnicastCount>(),                      //
        make_unique<ReportThreadNetworkDiagnosticsRxUnicastCount>(),                    //
        make_unique<ReadThreadNetworkDiagnosticsRxBroadcastCount>(),                    //
        make_unique<ReportThreadNetworkDiagnosticsRxBroadcastCount>(),                  //
        make_unique<ReadThreadNetworkDiagnosticsRxDataCount>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsRxDataCount>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsRxDataPollCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsRxDataPollCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsRxBeaconCount>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsRxBeaconCount>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsRxBeaconRequestCount>(),                //
        make_unique<ReportThreadNetworkDiagnosticsRxBeaconRequestCount>(),              //
        make_unique<ReadThreadNetworkDiagnosticsRxOtherCount>(),                        //
        make_unique<ReportThreadNetworkDiagnosticsRxOtherCount>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsRxAddressFilteredCount>(),              //
        make_unique<ReportThreadNetworkDiagnosticsRxAddressFilteredCount>(),            //
        make_unique<ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount>(),             //
        make_unique<ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount>(),           //
        make_unique<ReadThreadNetworkDiagnosticsRxDuplicatedCount>(),                   //
        make_unique<ReportThreadNetworkDiagnosticsRxDuplicatedCount>(),                 //
        make_unique<ReadThreadNetworkDiagnosticsRxErrNoFrameCount>(),                   //
        make_unique<ReportThreadNetworkDiagnosticsRxErrNoFrameCount>(),                 //
        make_unique<ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount>(),           //
        make_unique<ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount>(),         //
        make_unique<ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount>(),            //
        make_unique<ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount>(),          //
        make_unique<ReadThreadNetworkDiagnosticsRxErrSecCount>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsRxErrSecCount>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsRxErrFcsCount>(),                       //
        make_unique<ReportThreadNetworkDiagnosticsRxErrFcsCount>(),                     //
        make_unique<ReadThreadNetworkDiagnosticsRxErrOtherCount>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsRxErrOtherCount>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsActiveTimestamp>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsActiveTimestamp>(),                   //
        make_unique<ReadThreadNetworkDiagnosticsPendingTimestamp>(),                    //
        make_unique<ReportThreadNetworkDiagnosticsPendingTimestamp>(),                  //
        make_unique<ReadThreadNetworkDiagnosticsDelay>(),                               //
        make_unique<ReportThreadNetworkDiagnosticsDelay>(),                             //
        make_unique<ReadThreadNetworkDiagnosticsSecurityPolicy>(),                      //
        make_unique<ReadThreadNetworkDiagnosticsChannelMask>(),                         //
        make_unique<ReportThreadNetworkDiagnosticsChannelMask>(),                       //
        make_unique<ReadThreadNetworkDiagnosticsOperationalDatasetComponents>(),        //
        make_unique<ReadThreadNetworkDiagnosticsActiveNetworkFaultsList>(),             //
        make_unique<ReadThreadNetworkDiagnosticsClusterRevision>(),                     //
        make_unique<ReportThreadNetworkDiagnosticsClusterRevision>(),                   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWakeOnLan(Commands & commands)
{
    const char * clusterName = "WakeOnLan";

    commands_list clusterCommands = {
        make_unique<ReadWakeOnLanWakeOnLanMacAddress>(),   //
        make_unique<ReportWakeOnLanWakeOnLanMacAddress>(), //
        make_unique<ReadWakeOnLanClusterRevision>(),       //
        make_unique<ReportWakeOnLanClusterRevision>(),     //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWiFiNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "WiFiNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<WiFiNetworkDiagnosticsResetCounts>(),                  //
        make_unique<ReadWiFiNetworkDiagnosticsBssid>(),                    //
        make_unique<ReportWiFiNetworkDiagnosticsBssid>(),                  //
        make_unique<ReadWiFiNetworkDiagnosticsSecurityType>(),             //
        make_unique<ReportWiFiNetworkDiagnosticsSecurityType>(),           //
        make_unique<ReadWiFiNetworkDiagnosticsWiFiVersion>(),              //
        make_unique<ReportWiFiNetworkDiagnosticsWiFiVersion>(),            //
        make_unique<ReadWiFiNetworkDiagnosticsChannelNumber>(),            //
        make_unique<ReportWiFiNetworkDiagnosticsChannelNumber>(),          //
        make_unique<ReadWiFiNetworkDiagnosticsRssi>(),                     //
        make_unique<ReportWiFiNetworkDiagnosticsRssi>(),                   //
        make_unique<ReadWiFiNetworkDiagnosticsBeaconLostCount>(),          //
        make_unique<ReportWiFiNetworkDiagnosticsBeaconLostCount>(),        //
        make_unique<ReadWiFiNetworkDiagnosticsBeaconRxCount>(),            //
        make_unique<ReportWiFiNetworkDiagnosticsBeaconRxCount>(),          //
        make_unique<ReadWiFiNetworkDiagnosticsPacketMulticastRxCount>(),   //
        make_unique<ReportWiFiNetworkDiagnosticsPacketMulticastRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketMulticastTxCount>(),   //
        make_unique<ReportWiFiNetworkDiagnosticsPacketMulticastTxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketUnicastRxCount>(),     //
        make_unique<ReportWiFiNetworkDiagnosticsPacketUnicastRxCount>(),   //
        make_unique<ReadWiFiNetworkDiagnosticsPacketUnicastTxCount>(),     //
        make_unique<ReportWiFiNetworkDiagnosticsPacketUnicastTxCount>(),   //
        make_unique<ReadWiFiNetworkDiagnosticsCurrentMaxRate>(),           //
        make_unique<ReportWiFiNetworkDiagnosticsCurrentMaxRate>(),         //
        make_unique<ReadWiFiNetworkDiagnosticsOverrunCount>(),             //
        make_unique<ReportWiFiNetworkDiagnosticsOverrunCount>(),           //
        make_unique<ReadWiFiNetworkDiagnosticsFeatureMap>(),               //
        make_unique<ReadWiFiNetworkDiagnosticsClusterRevision>(),          //
        make_unique<ReportWiFiNetworkDiagnosticsClusterRevision>(),        //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWindowCovering(Commands & commands)
{
    const char * clusterName = "WindowCovering";

    commands_list clusterCommands = {
        make_unique<WindowCoveringDownOrClose>(),                            //
        make_unique<WindowCoveringGoToLiftPercentage>(),                     //
        make_unique<WindowCoveringGoToLiftValue>(),                          //
        make_unique<WindowCoveringGoToTiltPercentage>(),                     //
        make_unique<WindowCoveringGoToTiltValue>(),                          //
        make_unique<WindowCoveringStopMotion>(),                             //
        make_unique<WindowCoveringUpOrOpen>(),                               //
        make_unique<ReadWindowCoveringType>(),                               //
        make_unique<ReportWindowCoveringType>(),                             //
        make_unique<ReadWindowCoveringCurrentPositionLift>(),                //
        make_unique<ReportWindowCoveringCurrentPositionLift>(),              //
        make_unique<ReadWindowCoveringCurrentPositionTilt>(),                //
        make_unique<ReportWindowCoveringCurrentPositionTilt>(),              //
        make_unique<ReadWindowCoveringConfigStatus>(),                       //
        make_unique<ReportWindowCoveringConfigStatus>(),                     //
        make_unique<ReadWindowCoveringCurrentPositionLiftPercentage>(),      //
        make_unique<ReportWindowCoveringCurrentPositionLiftPercentage>(),    //
        make_unique<ReadWindowCoveringCurrentPositionTiltPercentage>(),      //
        make_unique<ReportWindowCoveringCurrentPositionTiltPercentage>(),    //
        make_unique<ReadWindowCoveringOperationalStatus>(),                  //
        make_unique<ReportWindowCoveringOperationalStatus>(),                //
        make_unique<ReadWindowCoveringTargetPositionLiftPercent100ths>(),    //
        make_unique<ReportWindowCoveringTargetPositionLiftPercent100ths>(),  //
        make_unique<ReadWindowCoveringTargetPositionTiltPercent100ths>(),    //
        make_unique<ReportWindowCoveringTargetPositionTiltPercent100ths>(),  //
        make_unique<ReadWindowCoveringEndProductType>(),                     //
        make_unique<ReportWindowCoveringEndProductType>(),                   //
        make_unique<ReadWindowCoveringCurrentPositionLiftPercent100ths>(),   //
        make_unique<ReportWindowCoveringCurrentPositionLiftPercent100ths>(), //
        make_unique<ReadWindowCoveringCurrentPositionTiltPercent100ths>(),   //
        make_unique<ReportWindowCoveringCurrentPositionTiltPercent100ths>(), //
        make_unique<ReadWindowCoveringInstalledOpenLimitLift>(),             //
        make_unique<ReportWindowCoveringInstalledOpenLimitLift>(),           //
        make_unique<ReadWindowCoveringInstalledClosedLimitLift>(),           //
        make_unique<ReportWindowCoveringInstalledClosedLimitLift>(),         //
        make_unique<ReadWindowCoveringInstalledOpenLimitTilt>(),             //
        make_unique<ReportWindowCoveringInstalledOpenLimitTilt>(),           //
        make_unique<ReadWindowCoveringInstalledClosedLimitTilt>(),           //
        make_unique<ReportWindowCoveringInstalledClosedLimitTilt>(),         //
        make_unique<ReadWindowCoveringMode>(),                               //
        make_unique<WriteWindowCoveringMode>(),                              //
        make_unique<ReportWindowCoveringMode>(),                             //
        make_unique<ReadWindowCoveringSafetyStatus>(),                       //
        make_unique<ReportWindowCoveringSafetyStatus>(),                     //
        make_unique<ReadWindowCoveringFeatureMap>(),                         //
        make_unique<ReportWindowCoveringFeatureMap>(),                       //
        make_unique<ReadWindowCoveringClusterRevision>(),                    //
        make_unique<ReportWindowCoveringClusterRevision>(),                  //
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusters(Commands & commands)
{
    registerClusterAccountLogin(commands);
    registerClusterAdministratorCommissioning(commands);
    registerClusterApplicationBasic(commands);
    registerClusterApplicationLauncher(commands);
    registerClusterAudioOutput(commands);
    registerClusterBarrierControl(commands);
    registerClusterBasic(commands);
    registerClusterBinaryInputBasic(commands);
    registerClusterBinding(commands);
    registerClusterBooleanState(commands);
    registerClusterBridgedActions(commands);
    registerClusterBridgedDeviceBasicInformation(commands);
    registerClusterColorControl(commands);
    registerClusterContentLauncher(commands);
    registerClusterDescriptor(commands);
    registerClusterDiagnosticLogs(commands);
    registerClusterDoorLock(commands);
    registerClusterElectricalMeasurement(commands);
    registerClusterEthernetNetworkDiagnostics(commands);
    registerClusterFixedLabel(commands);
    registerClusterFlowMeasurement(commands);
    registerClusterGeneralCommissioning(commands);
    registerClusterGeneralDiagnostics(commands);
    registerClusterGroupKeyManagement(commands);
    registerClusterGroups(commands);
    registerClusterIdentify(commands);
    registerClusterIlluminanceMeasurement(commands);
    registerClusterKeypadInput(commands);
    registerClusterLevelControl(commands);
    registerClusterLowPower(commands);
    registerClusterMediaInput(commands);
    registerClusterMediaPlayback(commands);
    registerClusterModeSelect(commands);
    registerClusterNetworkCommissioning(commands);
    registerClusterOtaSoftwareUpdateProvider(commands);
    registerClusterOtaSoftwareUpdateRequestor(commands);
    registerClusterOccupancySensing(commands);
    registerClusterOnOff(commands);
    registerClusterOnOffSwitchConfiguration(commands);
    registerClusterOperationalCredentials(commands);
    registerClusterPowerSource(commands);
    registerClusterPressureMeasurement(commands);
    registerClusterPumpConfigurationAndControl(commands);
    registerClusterRelativeHumidityMeasurement(commands);
    registerClusterScenes(commands);
    registerClusterSoftwareDiagnostics(commands);
    registerClusterSwitch(commands);
    registerClusterTvChannel(commands);
    registerClusterTargetNavigator(commands);
    registerClusterTemperatureMeasurement(commands);
    registerClusterTestCluster(commands);
    registerClusterThermostat(commands);
    registerClusterThermostatUserInterfaceConfiguration(commands);
    registerClusterThreadNetworkDiagnostics(commands);
    registerClusterWakeOnLan(commands);
    registerClusterWiFiNetworkDiagnostics(commands);
    registerClusterWindowCovering(commands);
}
